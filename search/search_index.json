{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"VCFX: A Comprehensive VCF Manipulation Toolkit","text":"<p>VCFX is a collection of specialized command-line tools designed for efficient manipulation, analysis, and transformation of VCF (Variant Call Format) files used in genomic research and bioinformatics.</p>"},{"location":"#what-is-vcfx","title":"What is VCFX?","text":"<p>VCFX follows the Unix philosophy of creating small, focused tools that do one thing well and can be combined together to form powerful workflows. Each tool in the VCFX suite is optimized for a specific VCF-related task, enabling researchers and bioinformaticians to:</p> <ul> <li>Extract specific information from VCF files</li> <li>Filter variants based on various criteria</li> <li>Transform VCF data into different formats</li> <li>Analyze genotypes and compute statistics</li> <li>Validate and check VCF file integrity</li> <li>Manipulate structural variants and complex records</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To begin using VCFX, first follow the installation instructions below, then explore the tool categories to find the right components for your workflow.</p>"},{"location":"#installation","title":"Installation","text":"<p>VCFX tools are built using CMake. To build the entire toolkit:</p> <pre><code>git clone https://github.com/ieeta-pt/VCFX.git\ncd VCFX\nmkdir -p build\ncd build\ncmake ..\nmake\n</code></pre> <p>To build a specific tool:</p> <pre><code>make VCFX_tool_name\n</code></pre>"},{"location":"#basic-example","title":"Basic Example","text":"<p>Here's a simple example of using VCFX to analyze variants:</p> <pre><code># Calculate allele frequencies for SNPs only\ncat input.vcf | \\\n  VCFX_variant_classifier --append-info | \\\n  grep 'VCF_CLASS=SNP' | \\\n  VCFX_allele_freq_calc &gt; snp_frequencies.tsv\n</code></pre>"},{"location":"#tool-categories","title":"Tool Categories","text":"<p>The VCFX toolkit includes tools in the following categories:</p>"},{"location":"#data-analysis","title":"Data Analysis","text":"<p>Tools for extracting statistical information and insights from variant data:</p> <ul> <li>VCFX_allele_freq_calc - Calculate allele frequencies</li> <li>VCFX_variant_classifier - Classify variants into SNP, INDEL, MNV, or STRUCTURAL</li> <li>VCFX_inbreeding_calculator - Calculate inbreeding coefficients</li> <li>VCFX_dosage_calculator - Calculate allele dosage from genotypes</li> <li>View all analysis tools...</li> </ul>"},{"location":"#data-filtering","title":"Data Filtering","text":"<p>Tools for selecting variants based on specific criteria:</p> <ul> <li>VCFX_phase_checker - Filter variants to keep only fully phased genotypes</li> <li>VCFX_phred_filter - Filter variants based on Phred-scaled quality scores</li> <li>VCFX_record_filter - Filter variants based on various VCF fields</li> <li>View all filtering tools...</li> </ul>"},{"location":"#data-transformation","title":"Data Transformation","text":"<p>Tools for converting or reformatting VCF data:</p> <ul> <li>VCFX_multiallelic_splitter - Split multiallelic variants into biallelic records</li> <li>VCFX_sample_extractor - Extract specific samples from a VCF file</li> <li>VCFX_indel_normalizer - Normalize indel representations</li> <li>View all transformation tools...</li> </ul>"},{"location":"#quality-control","title":"Quality Control","text":"<p>Tools for validating and checking data quality:</p> <ul> <li>VCFX_concordance_checker - Check concordance between samples in a VCF file</li> <li>VCFX_missing_detector - Detect and report missing data</li> <li>VCFX_validator - Validate VCF format compliance</li> <li>View all quality control tools...</li> </ul>"},{"location":"#file-management","title":"File Management","text":"<p>Tools for handling VCF files:</p> <ul> <li>VCFX_indexer - Create an index file for random access</li> <li>VCFX_file_splitter - Split VCF files into smaller chunks</li> <li>VCFX_compressor - Compress VCF files efficiently</li> <li>View all file management tools...</li> </ul>"},{"location":"#annotation-and-reporting","title":"Annotation and Reporting","text":"<p>Tools for annotating and extracting information from VCF files:</p> <ul> <li>VCFX_custom_annotator - Add custom annotations to VCF files</li> <li>VCFX_info_summarizer - Summarize INFO fields</li> <li>... (include a few more key tools)</li> <li>View all annotation tools...</li> </ul>"},{"location":"#data-processing","title":"Data Processing","text":"<p>Tools for processing variants and samples:</p> <ul> <li>VCFX_missing_data_handler - Handle missing data</li> <li>VCFX_quality_adjuster - Adjust quality scores</li> <li>VCFX_haplotype_phaser - Phase haplotypes</li> <li>VCFX_haplotype_extractor - Extract haplotype information</li> <li>View all processing tools...</li> </ul> <p>For a complete list of all tools and detailed usage examples, see the tools overview.</p>"},{"location":"#who-should-use-vcfx","title":"Who Should Use VCFX?","text":"<p>VCFX is designed for:</p> <ul> <li>Bioinformaticians working with genomic variant data</li> <li>Researchers analyzing VCF files from sequencing projects</li> <li>Pipeline developers creating reproducible genomic workflows</li> <li>Data scientists extracting information from genetic variants</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Composability: All tools work with standard input/output for easy pipeline integration</li> <li>Efficiency: Optimized for performance with large genomic datasets</li> <li>Robustness: Careful error handling and validation of VCF formatting</li> <li>Flexibility: Works with various VCF versions and extensions</li> <li>Simplicity: Clear, focused tools with consistent interfaces</li> </ul>"},{"location":"#common-usage-patterns","title":"Common Usage Patterns","text":"<p>VCFX tools are designed to be used in pipelines. Here are some common usage patterns:</p>"},{"location":"#basic-filtering-and-analysis","title":"Basic Filtering and Analysis","text":"<pre><code># Extract phased variants, filter by quality, and calculate allele frequencies\ncat input.vcf | \\\n  VCFX_phase_checker | \\\n  VCFX_phred_filter --phred-filter 30 | \\\n  VCFX_allele_freq_calc &gt; result.tsv\n</code></pre>"},{"location":"#sample-comparison","title":"Sample Comparison","text":"<pre><code># Check concordance between two samples in a single VCF\ncat input.vcf | VCFX_concordance_checker --samples \"SAMPLE1 SAMPLE2\" &gt; concordance_report.tsv\n</code></pre> <p>See the tools overview page for more usage examples.</p>"},{"location":"#community-and-support","title":"Community and Support","text":"<ul> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>Contributing Guidelines</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you use VCFX in your research, please cite:</p> <pre><code>@inproceedings{silva2025vcfx,\n  title={VCFX: A Minimalist, Modular Toolkit for Streamlined Variant Analysis},\n  author={Silva, Jorge Miguel and Oliveira, Jos{\\'e} Luis},\n  booktitle={12th International Work-Conference on Bioinformatics and Biomedical Engineering (IWBBIO 2025)},\n  year={2025},\n  organization={Springer}\n}\n</code></pre>"},{"location":"#license","title":"License","text":"<p>VCFX is available under MIT License. See the LICENSE file for details. </p>"},{"location":"CONTRIBUTING/","title":"Contributing to VCFX","text":"<p>Thank you for your interest in contributing to VCFX! This document provides guidelines and instructions for contributing to the project.</p>"},{"location":"CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":"<p>Please be respectful and considerate of others when contributing to this project. We aim to foster an inclusive and welcoming community.</p>"},{"location":"CONTRIBUTING/#how-to-contribute","title":"How to Contribute","text":""},{"location":"CONTRIBUTING/#reporting-bugs","title":"Reporting Bugs","text":"<p>If you find a bug in VCFX, please report it by creating an issue in our GitHub repository. When reporting a bug, please include:</p> <ul> <li>A clear, descriptive title</li> <li>A detailed description of the issue, including steps to reproduce</li> <li>The expected behavior</li> <li>The actual behavior observed</li> <li>Any relevant error messages or logs</li> <li>Your system information (OS, compiler version, etc.)</li> </ul>"},{"location":"CONTRIBUTING/#suggesting-enhancements","title":"Suggesting Enhancements","text":"<p>We welcome suggestions for new features or improvements to existing functionality. To suggest an enhancement:</p> <ol> <li>Check if the enhancement has already been suggested or implemented</li> <li>Create a new issue with a clear description of the enhancement</li> <li>Explain why this enhancement would be useful to VCFX users</li> </ol>"},{"location":"CONTRIBUTING/#contributing-code","title":"Contributing Code","text":"<ol> <li>Fork the repository</li> <li>Create a new branch for your feature or bug fix</li> <li>Write your code, following our coding standards    (run <code>clang-format -i &lt;files&gt;</code> before committing)</li> <li>Add tests for your changes</li> <li>Ensure all tests pass</li> <li>Update documentation as needed</li> <li>Commit your changes with clear, descriptive commit messages</li> <li>Submit a pull request</li> </ol>"},{"location":"CONTRIBUTING/#development-setup","title":"Development Setup","text":""},{"location":"CONTRIBUTING/#code-formatting","title":"Code Formatting","text":"<p>We use <code>clang-format</code> to keep the C++ code style consistent. A basic configuration is provided in <code>.clang-format</code> at the repository root. Please run:</p> <pre><code>clang-format -i path/to/changed_file.cpp\n</code></pre> <p>before committing changes.</p>"},{"location":"CONTRIBUTING/#prerequisites","title":"Prerequisites","text":"<ul> <li>CMake (version 3.10 or higher)</li> <li>C++11 compatible compiler (GCC, Clang, MSVC)</li> <li>Git</li> </ul>"},{"location":"CONTRIBUTING/#building-for-development","title":"Building for Development","text":"<pre><code>git clone https://github.com/ieeta-pt/VCFX.git\ncd VCFX\nmkdir build &amp;&amp; cd build\ncmake ..\nmake\n</code></pre>"},{"location":"CONTRIBUTING/#running-tests","title":"Running Tests","text":"<p>After building the project, run the test suite from the <code>build</code> directory:</p> <pre><code>ctest --output-on-failure\n</code></pre> <p>You can still run all shell tests directly if needed:</p> <pre><code>bash ../tests/test_all.sh\n</code></pre>"},{"location":"CONTRIBUTING/#coding-standards","title":"Coding Standards","text":"<ul> <li>Use consistent indentation (4 spaces)</li> <li>Follow naming conventions:</li> <li>Class names: CamelCase</li> <li>Functions and methods: camelCase</li> <li>Variables: snake_case</li> <li>Constants: UPPER_SNAKE_CASE</li> <li>Write clear, descriptive comments</li> <li>Document public API methods</li> <li>Keep lines to a reasonable length (around 80-100 characters)</li> <li>Use descriptive variable and function names</li> </ul>"},{"location":"CONTRIBUTING/#documentation","title":"Documentation","text":"<ul> <li>Update the appropriate documentation when changing functionality</li> <li>Document all public methods and classes</li> <li>Provide usage examples when relevant</li> <li>Use clear, concise language</li> <li>Check for spelling and grammar errors</li> </ul>"},{"location":"CONTRIBUTING/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Update the README.md or relevant documentation with details of changes</li> <li>Update the version number if applicable, following Semantic Versioning</li> <li>The pull request will be merged once it has been reviewed and approved by a maintainer</li> </ol>"},{"location":"CONTRIBUTING/#license","title":"License","text":"<p>By contributing to VCFX, you agree that your contributions will be licensed under the project's MIT license. </p>"},{"location":"LICENSE/","title":"MIT License","text":"<p>Copyright (c) 2024</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"VCFX_af_subsetter/","title":"VCFX_af_subsetter","text":""},{"location":"VCFX_af_subsetter/#overview","title":"Overview","text":"<p><code>VCFX_af_subsetter</code> filters variants in a VCF file based on allele frequency (AF) values, allowing selection of variants within a specified frequency range. This tool is useful for focusing analysis on variants of specific population prevalence.</p>"},{"location":"VCFX_af_subsetter/#usage","title":"Usage","text":"<pre><code>VCFX_af_subsetter --af-filter \"MIN-MAX\" &lt; input.vcf &gt; filtered.vcf\n</code></pre>"},{"location":"VCFX_af_subsetter/#options","title":"Options","text":"Option Description <code>-a</code>, <code>--af-filter &lt;MIN-MAX&gt;</code> Required. Allele frequency range for filtering (e.g., <code>0.01-0.05</code>) <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_af_subsetter/#description","title":"Description","text":"<p><code>VCFX_af_subsetter</code> processes VCF files line by line and filters variants based on their allele frequency (AF) values from the INFO field. The tool:</p> <ol> <li>Reads the VCF file from standard input</li> <li>Parses the AF values from the INFO field of each variant record</li> <li>Compares these values against the specified minimum and maximum thresholds</li> <li>Retains variants with at least one allele frequency value within the range [MIN, MAX]</li> <li>Outputs the filtered variants to standard output</li> </ol> <p>This tool is particularly useful for: - Isolating rare variants (e.g., AF &lt; 0.01) - Focusing on common variants (e.g., AF &gt; 0.05) - Selecting variants with specific population frequencies - Removing extremely rare or fixed variants from analysis</p>"},{"location":"VCFX_af_subsetter/#output-format","title":"Output Format","text":"<p>The output is a standard VCF file containing: - All original header lines from the input VCF - Only those variant records with AF values within the specified range - No modification to the content or format of the retained lines</p>"},{"location":"VCFX_af_subsetter/#examples","title":"Examples","text":""},{"location":"VCFX_af_subsetter/#basic-usage","title":"Basic Usage","text":"<p>Filter for rare variants with frequency between 1% and 5%: <pre><code>VCFX_af_subsetter --af-filter \"0.01-0.05\" &lt; input.vcf &gt; rare_variants.vcf\n</code></pre></p>"},{"location":"VCFX_af_subsetter/#common-variants","title":"Common Variants","text":"<p>Filter for common variants with frequency above 5%: <pre><code>VCFX_af_subsetter --af-filter \"0.05-1.0\" &lt; input.vcf &gt; common_variants.vcf\n</code></pre></p>"},{"location":"VCFX_af_subsetter/#extremely-rare-variants","title":"Extremely Rare Variants","text":"<p>Filter for extremely rare variants: <pre><code>VCFX_af_subsetter --af-filter \"0.0001-0.001\" &lt; input.vcf &gt; very_rare_variants.vcf\n</code></pre></p>"},{"location":"VCFX_af_subsetter/#specific-frequency-band","title":"Specific Frequency Band","text":"<p>Filter for variants with a specific frequency band: <pre><code>VCFX_af_subsetter --af-filter \"0.4-0.6\" &lt; input.vcf &gt; mid_frequency_variants.vcf\n</code></pre></p>"},{"location":"VCFX_af_subsetter/#in-pipeline","title":"In Pipeline","text":"<p>Use in a pipeline with other VCFX tools: <pre><code>cat input.vcf | VCFX_af_subsetter --af-filter \"0.01-0.05\" | VCFX_phred_filter -p 30 &gt; high_quality_rare_variants.vcf\n</code></pre></p>"},{"location":"VCFX_af_subsetter/#af-value-parsing","title":"AF Value Parsing","text":""},{"location":"VCFX_af_subsetter/#format-requirements","title":"Format Requirements","text":"<p>The tool expects AF values in the INFO field in standard VCF format: - As a key-value pair in the INFO column: <code>AF=0.123</code> - For multi-allelic sites, as comma-separated values: <code>AF=0.01,0.05,0.1</code></p>"},{"location":"VCFX_af_subsetter/#range-specification","title":"Range Specification","text":"<p>The AF range must be specified as: - Two numeric values between 0.0 and 1.0 - Connected by a hyphen (<code>-</code>) - With the first value (minimum) less than or equal to the second value (maximum)</p> <p>For example: <code>0.01-0.05</code>, <code>0.0-0.1</code>, <code>0.4-0.6</code></p>"},{"location":"VCFX_af_subsetter/#handling-special-cases","title":"Handling Special Cases","text":""},{"location":"VCFX_af_subsetter/#multi-allelic-variants","title":"Multi-allelic Variants","text":"<p>For variants with multiple alternate alleles (multi-allelic): - The INFO field may contain multiple AF values (comma-separated) - The variant is retained if ANY of the AF values fall within the specified range - This behavior allows for selective filtering of multi-allelic sites</p>"},{"location":"VCFX_af_subsetter/#missing-af-values","title":"Missing AF Values","text":"<p>Variants without an AF annotation in the INFO field: - Are skipped with a warning message - Are not included in the output - Can indicate variants where frequency information is unavailable</p>"},{"location":"VCFX_af_subsetter/#full-range","title":"Full Range","text":"<p>Using the range <code>0.0-1.0</code> will: - Keep all variants with valid AF values - Still skip variants lacking AF annotations - Effectively function as a filter for \"has valid AF information\"</p>"},{"location":"VCFX_af_subsetter/#malformed-values","title":"Malformed Values","text":"<p>The tool handles several edge cases: - Invalid range format: Reports an error if not in <code>MIN-MAX</code> format - Out-of-range values: Ensures MIN and MAX are between 0.0 and 1.0 - Inverted ranges: Reports an error if MIN &gt; MAX - Non-numeric AF values: Skips variants where AF cannot be parsed as a number</p>"},{"location":"VCFX_af_subsetter/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Processes VCF files line by line for memory efficiency</li> <li>No preprocessing or indexing required</li> <li>Linear time complexity with respect to input file size</li> <li>Minimal CPU and memory usage</li> </ul>"},{"location":"VCFX_af_subsetter/#limitations","title":"Limitations","text":"<ul> <li>Requires AF field to be present in the INFO column</li> <li>No way to customize the AF field name (hardcoded to \"AF\")</li> <li>Cannot filter based on other frequency metrics (e.g., MAF, AC, AN)</li> <li>No option to include variants with missing AF values</li> <li>No statistics provided on the number of variants filtered</li> <li>Cannot combine with other filtering criteria in a single command </li> </ul>"},{"location":"VCFX_alignment_checker/","title":"VCFX_alignment_checker","text":""},{"location":"VCFX_alignment_checker/#overview","title":"Overview","text":"<p><code>VCFX_alignment_checker</code> identifies discrepancies between VCF variant entries and a reference genome FASTA file. This tool helps validate that the reference alleles in a VCF file match the corresponding positions in the reference genome.</p>"},{"location":"VCFX_alignment_checker/#usage","title":"Usage","text":"<pre><code>VCFX_alignment_checker --alignment-discrepancy &lt;vcf_file&gt; &lt;reference.fasta&gt; &gt; discrepancies.txt\n</code></pre>"},{"location":"VCFX_alignment_checker/#options","title":"Options","text":"Option Description <code>-a</code>, <code>--alignment-discrepancy</code> Enable alignment discrepancy checking mode <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_alignment_checker/#description","title":"Description","text":"<p><code>VCFX_alignment_checker</code> compares VCF variants against a reference genome to validate sequence consistency. The tool:</p> <ol> <li>Loads a reference genome from a FASTA file into memory</li> <li>Parses each variant in the input VCF file</li> <li>For each variant:</li> <li>Retrieves the corresponding sequence from the reference genome</li> <li>Compares it with the REF and ALT values from the VCF</li> <li>Reports any discrepancies found</li> <li>Outputs a tab-separated report of all detected discrepancies</li> </ol> <p>This tool is particularly useful for: - Validating VCF files against their reference genome - Identifying potential errors in variant calling - Detecting misalignments in variant positions - Quality control of VCF data before downstream analysis</p>"},{"location":"VCFX_alignment_checker/#input-requirements","title":"Input Requirements","text":"<ul> <li>A VCF file with variant records</li> <li>A FASTA file containing the reference genome sequences</li> <li>VCF must contain standard CHROM, POS, REF, and ALT fields</li> </ul>"},{"location":"VCFX_alignment_checker/#output-format","title":"Output Format","text":"<p>The tool produces a tab-separated values (TSV) file with the following columns:</p> Column Description CHROM Chromosome of the variant POS Position of the variant ID Variant identifier REF Reference allele in the VCF ALT Alternate allele in the VCF Discrepancy_Type Type of discrepancy detected (REF_DISCREPANCY or ALT_DISCREPANCY) Reference_Value The actual sequence from the reference genome VCF_Value The value from the VCF that differs from the reference"},{"location":"VCFX_alignment_checker/#examples","title":"Examples","text":""},{"location":"VCFX_alignment_checker/#basic-usage","title":"Basic Usage","text":"<p>Check for discrepancies between variants in a VCF file and a reference genome: <pre><code>VCFX_alignment_checker --alignment-discrepancy variants.vcf reference.fa &gt; discrepancies.txt\n</code></pre></p>"},{"location":"VCFX_alignment_checker/#pipeline-integration","title":"Pipeline Integration","text":"<p>Integrate with other tools for comprehensive validation: <pre><code>VCFX_alignment_checker --alignment-discrepancy variants.vcf reference.fa | grep \"REF_DISCREPANCY\" &gt; ref_errors.tsv\n</code></pre></p>"},{"location":"VCFX_alignment_checker/#discrepancy-types","title":"Discrepancy Types","text":""},{"location":"VCFX_alignment_checker/#ref_discrepancy","title":"REF_DISCREPANCY","text":"<p>Indicates that the REF field in the VCF doesn't match the reference genome at the specified position. This type of discrepancy suggests potential issues with: - Incorrect variant calling - Reference genome version mismatch - Coordinate system errors</p>"},{"location":"VCFX_alignment_checker/#alt_discrepancy","title":"ALT_DISCREPANCY","text":"<p>Indicates that the ALT field doesn't correspond to an expected variation from the reference. For SNPs, this can happen when: - The variant quality is low - The variant caller made an error - There are assembly or alignment issues</p>"},{"location":"VCFX_alignment_checker/#handling-special-cases","title":"Handling Special Cases","text":""},{"location":"VCFX_alignment_checker/#chromosome-naming","title":"Chromosome Naming","text":"<p>The tool attempts to normalize chromosome names between the VCF and reference FASTA by: - Adding 'chr' prefix when appropriate - Checking for standard naming conventions (1-22, X, Y, MT) - This normalization helps handle common mismatches between different naming conventions</p>"},{"location":"VCFX_alignment_checker/#indels-and-complex-variants","title":"Indels and Complex Variants","text":"<p>For insertions, deletions, and complex variants: - The tool compares the available bases (minimum length of REF and ALT) - It checks if the REF allele matches the reference genome - It also checks if the ALT allele differs from the reference as expected</p>"},{"location":"VCFX_alignment_checker/#missing-reference-sequences","title":"Missing Reference Sequences","text":"<p>If a chromosome in the VCF isn't found in the reference genome: - A warning is issued to stderr - The variant is skipped from discrepancy checking - This helps identify potential naming mismatches between files</p>"},{"location":"VCFX_alignment_checker/#out-of-range-positions","title":"Out-of-Range Positions","text":"<p>For positions beyond the reference sequence length: - The tool issues a warning - The variant is excluded from the discrepancy report - This can help identify coordinate system issues</p>"},{"location":"VCFX_alignment_checker/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Loads the entire reference genome into memory for faster lookups</li> <li>Processes the VCF file sequentially, line by line</li> <li>Memory usage scales with the size of the reference genome</li> <li>Discrepancy checking is computationally efficient after loading the reference</li> </ul>"},{"location":"VCFX_alignment_checker/#limitations","title":"Limitations","text":"<ul> <li>Requires loading the entire reference genome into memory, which can be memory-intensive for large genomes</li> <li>Chromosome name normalization may not handle all naming conventions</li> <li>Doesn't account for circularity in mitochondrial or bacterial genomes</li> <li>No specialized handling for structural variants</li> <li>Minimal sanity checks for FASTA format integrity</li> <li>Cannot check variants spanning multiple chromosomes </li> </ul>"},{"location":"VCFX_allele_balance_calc/","title":"VCFX_allele_balance_calc","text":""},{"location":"VCFX_allele_balance_calc/#overview","title":"Overview","text":"<p><code>VCFX_allele_balance_calc</code> calculates the allele balance for each sample in a VCF file, which is the ratio of reference alleles to alternate alleles in heterozygous genotypes. This metric is useful for assessing potential allelic bias in sequencing data.</p>"},{"location":"VCFX_allele_balance_calc/#usage","title":"Usage","text":"<pre><code>VCFX_allele_balance_calc [OPTIONS] &lt; input.vcf &gt; allele_balance.tsv\n</code></pre>"},{"location":"VCFX_allele_balance_calc/#options","title":"Options","text":"Option Description <code>-s</code>, <code>--samples \"Sample1 Sample2...\"</code> Optional. Specify sample names to calculate allele balance for (space-separated). If omitted, all samples are processed. <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_allele_balance_calc/#description","title":"Description","text":"<p><code>VCFX_allele_balance_calc</code> processes a VCF file and calculates the allele balance for each variant in each specified sample. The tool:</p> <ol> <li>Reads a VCF file from standard input</li> <li>Identifies sample columns from the VCF header</li> <li>For each variant and each sample:</li> <li>Extracts the genotype information</li> <li>Counts reference (0) and alternate (non-0) alleles</li> <li>Calculates the allele balance as: reference allele count / alternate allele count</li> <li>Outputs a tab-separated file with allele balance values for each variant-sample combination</li> </ol> <p>This tool is particularly useful for: - Identifying potential allele-specific biases in sequencing - Quality control of variant calls - Assessing imbalanced expression of alleles - Detecting potential sample contamination</p>"},{"location":"VCFX_allele_balance_calc/#output-format","title":"Output Format","text":"<p>The tool produces a tab-separated values (TSV) file with the following columns:</p> Column Description CHROM Chromosome of the variant POS Position of the variant ID Variant identifier REF Reference allele ALT Alternate allele(s) Sample Sample name Allele_Balance Calculated allele balance value or \"NA\" for missing/invalid genotypes"},{"location":"VCFX_allele_balance_calc/#examples","title":"Examples","text":""},{"location":"VCFX_allele_balance_calc/#basic-usage-all-samples","title":"Basic Usage (All Samples)","text":"<p>Calculate allele balance for all samples in a VCF file: <pre><code>VCFX_allele_balance_calc &lt; input.vcf &gt; allele_balance_all.tsv\n</code></pre></p>"},{"location":"VCFX_allele_balance_calc/#specific-samples","title":"Specific Samples","text":"<p>Calculate allele balance for specific samples: <pre><code>VCFX_allele_balance_calc --samples \"SAMPLE1 SAMPLE2\" &lt; input.vcf &gt; allele_balance_subset.tsv\n</code></pre></p>"},{"location":"VCFX_allele_balance_calc/#filtering-results","title":"Filtering Results","text":"<p>Process the output to focus on imbalanced variants: <pre><code>VCFX_allele_balance_calc &lt; input.vcf | awk -F'\\t' '$7 != \"NA\" &amp;&amp; $7 &lt; 0.4' &gt; imbalanced_variants.tsv\n</code></pre></p>"},{"location":"VCFX_allele_balance_calc/#allele-balance-calculation","title":"Allele Balance Calculation","text":""},{"location":"VCFX_allele_balance_calc/#formula","title":"Formula","text":"<p>The allele balance is calculated as: <pre><code>Allele Balance = Number of Reference Alleles / Number of Alternate Alleles\n</code></pre></p> <p>Where: - Reference alleles are those with value \"0\" in the genotype field - Alternate alleles are any non-zero value (e.g., \"1\", \"2\", etc.) in the genotype field</p>"},{"location":"VCFX_allele_balance_calc/#interpretation","title":"Interpretation","text":"<ul> <li>Value of 0.0: No reference alleles (e.g., \"1/1\", \"1/2\")</li> <li>Value of 1.0: Equal number of reference and alternate alleles (e.g., \"0/1\")</li> <li>Value &gt; 1.0: More reference than alternate alleles (unusual for diploid organisms)</li> <li>\"NA\": Missing or invalid genotype</li> </ul>"},{"location":"VCFX_allele_balance_calc/#special-cases","title":"Special Cases","text":"<ul> <li>Homozygous reference (e.g., \"0/0\"): Returns 0.0 (technically it would be undefined due to division by zero)</li> <li>Missing genotypes (e.g., \"./.\", \".|.\"): Returns \"NA\" in the output</li> <li>Partial missing (e.g., \"0/.\"): Only valid alleles are counted</li> <li>Invalid formats: Returns \"NA\" in the output</li> </ul>"},{"location":"VCFX_allele_balance_calc/#handling-special-cases","title":"Handling Special Cases","text":""},{"location":"VCFX_allele_balance_calc/#missing-data","title":"Missing Data","text":"<ul> <li>Genotypes with missing values (<code>./.</code>, <code>.</code>) return \"NA\" for allele balance</li> <li>Partial missing genotypes only count the valid alleles present</li> </ul>"},{"location":"VCFX_allele_balance_calc/#multi-allelic-sites","title":"Multi-allelic Sites","text":"<ul> <li>All non-reference alleles are treated as \"alternate\" regardless of their specific number</li> <li>For example, in a genotype \"1/2\", both alleles are counted as alternate alleles</li> </ul>"},{"location":"VCFX_allele_balance_calc/#phased-genotypes","title":"Phased Genotypes","text":"<ul> <li>Phasing information is ignored for allele balance calculation</li> <li>Phased genotypes (e.g., \"0|1\") are treated the same as unphased (e.g., \"0/1\")</li> </ul>"},{"location":"VCFX_allele_balance_calc/#haploid-genotypes","title":"Haploid Genotypes","text":"<ul> <li>Not explicitly handled; the tool expects diploid or polyploid genotypes with separators</li> </ul>"},{"location":"VCFX_allele_balance_calc/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Processes VCF files line by line, with minimal memory requirements</li> <li>Scales linearly with input file size and number of samples</li> <li>For very large VCF files with many samples, specifying a subset of samples can improve performance</li> </ul>"},{"location":"VCFX_allele_balance_calc/#limitations","title":"Limitations","text":"<ul> <li>No option to customize the allele balance formula</li> <li>Simplified handling of multi-allelic sites (all non-reference alleles are grouped)</li> <li>No automatic filtering based on allele balance values</li> <li>Cannot account for read depth or genotype quality in calculations</li> <li>Limited to processing standard VCF genotype fields</li> <li>Does not produce summary statistics across all variants </li> </ul>"},{"location":"VCFX_allele_balance_filter/","title":"VCFX_allele_balance_filter","text":""},{"location":"VCFX_allele_balance_filter/#overview","title":"Overview","text":"<p>VCFX_allele_balance_filter filters a VCF file to keep only variants where all samples have an allele balance ratio (reference alleles / total alleles) above a specified threshold, allowing for quality control and bias detection in variant calls.</p>"},{"location":"VCFX_allele_balance_filter/#usage","title":"Usage","text":"<pre><code>VCFX_allele_balance_filter --filter-allele-balance &lt;THRESHOLD&gt; &lt; input.vcf &gt; filtered.vcf\n</code></pre>"},{"location":"VCFX_allele_balance_filter/#options","title":"Options","text":"Option Description <code>-f</code>, <code>--filter-allele-balance</code> Required. Allele balance threshold between 0.0 and 1.0 <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_allele_balance_filter/#description","title":"Description","text":"<p>VCFX_allele_balance_filter examines the genotypes in each variant record and calculates an allele balance ratio for each sample. The tool:</p> <ol> <li>Processes a VCF file line by line</li> <li>For each variant, calculates the allele balance for each sample's genotype</li> <li>Filters out variants where any sample has an allele balance below the specified threshold</li> <li>Passes through all header lines unchanged</li> <li>Outputs a filtered VCF file with only the passing variants</li> </ol> <p>Allele balance is calculated as: <pre><code>AB = (number of reference alleles) / (total number of alleles)\n</code></pre></p> <p>Where: - Reference alleles are those with value \"0\" in the genotype field - All other numeric alleles (1, 2, 3, etc.) are counted as alternate alleles - Missing or non-numeric alleles are excluded from the calculation</p> <p>This tool is useful for: - Detecting potential sequencing or mapping biases - Quality control of variant calls - Filtering out variants with skewed allele representation - Identifying potential sample contamination or mixed samples</p>"},{"location":"VCFX_allele_balance_filter/#output-format","title":"Output Format","text":"<p>The output is a standard VCF file with the same format as the input, but containing only the variant lines that pass the allele balance filter. All header lines are preserved.</p>"},{"location":"VCFX_allele_balance_filter/#examples","title":"Examples","text":""},{"location":"VCFX_allele_balance_filter/#basic-usage","title":"Basic Usage","text":"<pre><code># Keep variants where all samples have allele balance &gt;= 0.3\nVCFX_allele_balance_filter --filter-allele-balance 0.3 &lt; input.vcf &gt; balanced.vcf\n</code></pre>"},{"location":"VCFX_allele_balance_filter/#stringent-filtering","title":"Stringent Filtering","text":"<pre><code># Very stringent filtering (close to 50/50 balance required)\nVCFX_allele_balance_filter --filter-allele-balance 0.45 &lt; input.vcf &gt; highly_balanced.vcf\n</code></pre>"},{"location":"VCFX_allele_balance_filter/#counting-filtered-variants","title":"Counting Filtered Variants","text":"<pre><code># Count how many variants were filtered out\ninput_count=$(grep -v \"^#\" input.vcf | wc -l)\noutput_count=$(grep -v \"^#\" filtered.vcf | wc -l)\nfiltered_count=$((input_count - output_count))\necho \"Filtered out $filtered_count variants based on allele balance\"\n</code></pre>"},{"location":"VCFX_allele_balance_filter/#in-a-pipeline","title":"In a Pipeline","text":"<pre><code># Filter by quality then by allele balance\ngrep -v \"^#\" input.vcf | grep \"PASS\" | grep \"QUAL&gt;30\" | \\\nVCFX_allele_balance_filter --filter-allele-balance 0.4 &gt; high_quality_balanced.vcf\n</code></pre>"},{"location":"VCFX_allele_balance_filter/#genotype-interpretation","title":"Genotype Interpretation","text":"<p>The tool examines the GT field of each sample's genotype:</p> <ol> <li>Extracts the GT field (before the first colon if present)</li> <li>Treats both phased ('|') and unphased ('/') genotypes the same</li> <li>For each allele:</li> <li>'0' is counted as a reference allele</li> <li>Any other number (1, 2, 3, etc.) is counted as an alternate allele</li> <li>Non-numeric values are ignored</li> </ol> <p>For example: - \"0/0\" \u2192 AB = 2/2 = 1.0 (all reference) - \"0/1\" \u2192 AB = 1/2 = 0.5 (half reference, half alternate) - \"1/1\" \u2192 AB = 0/2 = 0.0 (all alternate) - \"0/2\" \u2192 AB = 1/2 = 0.5 (half reference, half alternate) - \"./1\" \u2192 AB = 0/1 = 0.0 (missing reference allele, only alternate counted) - \"./.\" \u2192 AB = 0/0 = 0.0 (no valid alleles)</p>"},{"location":"VCFX_allele_balance_filter/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Missing genotypes (\"./.\") are treated as having AB = 0.0</li> <li>Partial missing (\"./1\") counts only the present alleles</li> <li>Non-diploid genotypes (e.g., \"0/1/2\") are handled correctly by counting alleles individually</li> <li>Complex genotypes (non-numeric) are skipped when calculating AB</li> <li>Empty lines are ignored</li> <li>Header lines are preserved unchanged</li> <li>Malformed VCF lines with insufficient columns are skipped with a warning</li> <li>Multi-allelic variants have all non-reference alleles (1, 2, 3, etc.) treated as alternate</li> </ul>"},{"location":"VCFX_allele_balance_filter/#performance","title":"Performance","text":"<p>The tool is optimized for efficiency: - Processes the VCF file in a single pass - Minimal memory usage as it processes one variant at a time - Constant-time computation of allele balance - Stops calculating AB for a variant as soon as any sample fails the threshold</p>"},{"location":"VCFX_allele_balance_filter/#limitations","title":"Limitations","text":"<ol> <li>Uses a simple all-or-nothing approach (variant passes only if ALL samples pass)</li> <li>No option to specify which samples to include in the filtering</li> <li>Cannot handle sample-specific threshold values</li> <li>No detailed reporting on which samples/variants failed and by how much</li> <li>No option to annotate variants with their allele balance rather than filtering</li> <li>Limited to the strict definition of allele balance (ref/total), not accounting for strand bias</li> <li>Treats all alternate alleles equally, regardless of their identity </li> </ol>"},{"location":"VCFX_allele_counter/","title":"VCFX_allele_counter","text":""},{"location":"VCFX_allele_counter/#overview","title":"Overview","text":"<p><code>VCFX_allele_counter</code> counts the number of reference and alternate alleles in each sample for each variant in a VCF file. This tool provides a simple way to quantify allele occurrences across samples.</p>"},{"location":"VCFX_allele_counter/#usage","title":"Usage","text":"<pre><code>VCFX_allele_counter [OPTIONS] &lt; input.vcf &gt; allele_counts.tsv\n</code></pre>"},{"location":"VCFX_allele_counter/#options","title":"Options","text":"Option Description <code>-s</code>, <code>--samples \"Sample1 Sample2...\"</code> Optional. Specify sample names to calculate allele counts for (space-separated). If omitted, all samples are processed. <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_allele_counter/#description","title":"Description","text":"<p><code>VCFX_allele_counter</code> processes a VCF file and counts reference and alternate alleles for each variant in each specified sample. The tool:</p> <ol> <li>Reads a VCF file from standard input</li> <li>Identifies sample columns from the VCF header</li> <li>For each variant and each sample:</li> <li>Extracts the genotype information</li> <li>Counts reference alleles (0) and alternate alleles (non-0)</li> <li>Outputs both counts in a tabular format</li> <li>Outputs a tab-separated file with allele counts for each variant-sample combination</li> </ol> <p>This tool is particularly useful for: - Analyzing allele distribution across samples - Quantifying the presence of specific alleles - Preparing data for population genetics analyses - Validating genotype calls across samples</p>"},{"location":"VCFX_allele_counter/#output-format","title":"Output Format","text":"<p>The tool produces a tab-separated values (TSV) file with the following columns:</p> Column Description CHROM Chromosome of the variant POS Position of the variant ID Variant identifier REF Reference allele ALT Alternate allele(s) Sample Sample name Ref_Count Number of reference alleles (0) in the sample's genotype Alt_Count Number of alternate alleles (non-0) in the sample's genotype"},{"location":"VCFX_allele_counter/#examples","title":"Examples","text":""},{"location":"VCFX_allele_counter/#basic-usage-all-samples","title":"Basic Usage (All Samples)","text":"<p>Count alleles for all samples in a VCF file: <pre><code>VCFX_allele_counter &lt; input.vcf &gt; allele_counts_all.tsv\n</code></pre></p>"},{"location":"VCFX_allele_counter/#specific-samples","title":"Specific Samples","text":"<p>Count alleles for specific samples: <pre><code>VCFX_allele_counter --samples \"SAMPLE1 SAMPLE2\" &lt; input.vcf &gt; allele_counts_subset.tsv\n</code></pre></p>"},{"location":"VCFX_allele_counter/#using-with-other-tools","title":"Using with Other Tools","text":"<p>Process the output for further analysis: <pre><code>VCFX_allele_counter &lt; input.vcf | awk -F'\\t' '$8 &gt; 0' &gt; samples_with_alt_alleles.tsv\n</code></pre></p>"},{"location":"VCFX_allele_counter/#allele-counting-method","title":"Allele Counting Method","text":""},{"location":"VCFX_allele_counter/#reference-alleles","title":"Reference Alleles","text":"<p>The tool counts an allele as a reference allele when it has the value \"0\" in the genotype field. For example: - In genotype \"0/0\", there are 2 reference alleles - In genotype \"0/1\", there is 1 reference allele - In genotype \"1/2\", there are 0 reference alleles</p>"},{"location":"VCFX_allele_counter/#alternate-alleles","title":"Alternate Alleles","text":"<p>The tool counts an allele as an alternate allele when it has any non-zero numeric value in the genotype field. For example: - In genotype \"0/0\", there are 0 alternate alleles - In genotype \"0/1\", there is 1 alternate allele - In genotype \"1/2\", there are 2 alternate alleles - In genotype \"1/1\", there are 2 alternate alleles</p>"},{"location":"VCFX_allele_counter/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Missing genotypes (e.g., \"./.\", \".|.\"): No counts are recorded for these samples</li> <li>Partial missing (e.g., \"0/.\"): Only the valid allele is counted</li> <li>Non-numeric alleles: These are skipped and not counted</li> </ul>"},{"location":"VCFX_allele_counter/#handling-special-cases_1","title":"Handling Special Cases","text":""},{"location":"VCFX_allele_counter/#missing-data","title":"Missing Data","text":"<ul> <li>Genotypes with missing values (<code>./.</code>, <code>.</code>) are skipped</li> <li>Partial missing genotypes only count the valid alleles present</li> </ul>"},{"location":"VCFX_allele_counter/#multi-allelic-sites","title":"Multi-allelic Sites","text":"<ul> <li>All non-reference alleles are counted as \"alternate\" regardless of their specific number</li> <li>For example, in a genotype \"1/2\", both alleles count as alternate alleles</li> <li>The tool does not differentiate between different alternate alleles</li> </ul>"},{"location":"VCFX_allele_counter/#phased-genotypes","title":"Phased Genotypes","text":"<ul> <li>Phasing information is ignored for allele counting</li> <li>Phased genotypes (e.g., \"0|1\") are treated the same as unphased (e.g., \"0/1\")</li> </ul>"},{"location":"VCFX_allele_counter/#invalid-genotypes","title":"Invalid Genotypes","text":"<ul> <li>Non-numeric allele values are skipped</li> <li>Empty genotype fields are skipped</li> </ul>"},{"location":"VCFX_allele_counter/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Processes VCF files line by line, with minimal memory requirements</li> <li>Scales linearly with input file size and number of samples</li> <li>For very large VCF files with many samples, specifying a subset of samples can improve performance</li> </ul>"},{"location":"VCFX_allele_counter/#limitations","title":"Limitations","text":"<ul> <li>Does not distinguish between different alternate alleles (e.g., \"1\" vs \"2\")</li> <li>No options for filtering by allele count thresholds</li> <li>Cannot account for genotype quality or read depth</li> <li>Limited to processing standard VCF genotype fields</li> <li>Does not produce summary statistics or aggregate counts</li> <li>No direct integration with population genetics metrics </li> </ul>"},{"location":"VCFX_allele_freq_calc/","title":"VCFX_allele_freq_calc","text":""},{"location":"VCFX_allele_freq_calc/#overview","title":"Overview","text":"<p>The VCFX_allele_freq_calc tool calculates allele frequencies for variants in a VCF file. It reads a VCF file from standard input and outputs a TSV file with chromosome, position, ID, reference allele, alternate allele, and the calculated allele frequency.</p>"},{"location":"VCFX_allele_freq_calc/#usage","title":"Usage","text":"<pre><code>VCFX_allele_freq_calc [OPTIONS] &lt; input.vcf &gt; allele_frequencies.tsv\n</code></pre>"},{"location":"VCFX_allele_freq_calc/#options","title":"Options","text":"Option Description <code>--help</code>, <code>-h</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_allele_freq_calc/#description","title":"Description","text":"<p>VCFX_allele_freq_calc computes the allele frequency for each variant in a VCF file. The allele frequency is calculated as the number of alternate alleles divided by the total number of alleles (reference + alternate) across all samples, considering only non-missing genotypes.</p> <p>The tool: - Parses the GT (genotype) field for each sample - Counts reference (0) and alternate (non-zero) alleles - Calculates frequency as: <code>alternate_count / (reference_count + alternate_count)</code> - Outputs results in a clean TSV format</p>"},{"location":"VCFX_allele_freq_calc/#output-format","title":"Output Format","text":"<p>The output is a tab-separated file with the following columns:</p> <pre><code>CHROM  POS  ID  REF  ALT  Allele_Frequency\n</code></pre> <p>Where <code>Allele_Frequency</code> is a value between 0.0 and 1.0, formatted with 4 decimal places.</p>"},{"location":"VCFX_allele_freq_calc/#examples","title":"Examples","text":""},{"location":"VCFX_allele_freq_calc/#basic-usage","title":"Basic Usage","text":"<pre><code>./VCFX_allele_freq_calc &lt; input.vcf &gt; allele_frequencies.tsv\n</code></pre>"},{"location":"VCFX_allele_freq_calc/#pipe-with-other-commands","title":"Pipe with Other Commands","text":"<pre><code># Filter variants and calculate allele frequencies\ngrep -v \"^#\" input.vcf | grep \"PASS\" | ./VCFX_allele_freq_calc &gt; filtered_allele_frequencies.tsv\n</code></pre>"},{"location":"VCFX_allele_freq_calc/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Phased genotypes: Both phased (<code>|</code>) and unphased (<code>/</code>) genotypes are handled the same way</li> <li>Missing genotypes (<code>./.</code>): Missing genotypes are skipped in the frequency calculation</li> <li>Multiallelic sites: All non-reference alleles are counted as \"alternate\" regardless of the specific ALT index</li> <li>No GT field: Variants without a GT field are skipped</li> </ul>"},{"location":"VCFX_allele_freq_calc/#performance","title":"Performance","text":"<p>This tool processes VCF files line by line, with minimal memory requirements. It can handle large VCF files efficiently.</p>"},{"location":"VCFX_allele_freq_calc/#limitations","title":"Limitations","text":"<ul> <li>Requires the GT field to be present in the FORMAT column</li> <li>Does not distinguish between different alternate alleles in multiallelic sites (all non-reference alleles are counted together)</li> <li>Cannot handle malformed VCF files, though it will attempt to skip invalid lines with a warning </li> </ul>"},{"location":"VCFX_ancestry_assigner/","title":"VCFX_ancestry_assigner","text":""},{"location":"VCFX_ancestry_assigner/#overview","title":"Overview","text":"<p>VCFX_ancestry_assigner assigns samples in a VCF file to ancestral populations using a likelihood-based approach based on population-specific allele frequencies.</p>"},{"location":"VCFX_ancestry_assigner/#usage","title":"Usage","text":"<pre><code>VCFX_ancestry_assigner --assign-ancestry &lt;freq_file&gt; &lt; input.vcf &gt; ancestry_results.txt\n</code></pre>"},{"location":"VCFX_ancestry_assigner/#options","title":"Options","text":"Option Description <code>-a</code>, <code>--assign-ancestry &lt;FILE&gt;</code> Required. Path to a file containing population-specific allele frequencies <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_ancestry_assigner/#description","title":"Description","text":"<p>VCFX_ancestry_assigner determines the most likely ancestral population for each sample in a VCF file by calculating genotype likelihoods across multiple populations. The tool:</p> <ol> <li>Reads a tab-delimited file containing allele frequencies for different populations</li> <li>Processes the genotypes for each sample in the VCF file</li> <li>Computes likelihood scores for each possible ancestral population</li> <li>Assigns each sample to the population with the highest likelihood score</li> <li>Outputs a simple mapping of sample names to assigned populations</li> </ol> <p>The tool uses a statistical approach that considers the probability of observing each genotype given the population-specific allele frequencies. For each genotype: - Homozygous reference (0/0): P = (1-f)\u00b2 - Heterozygous (0/1): P = 2f(1-f)  - Homozygous alternate (1/1): P = f\u00b2</p> <p>Where f is the frequency of the alternate allele in a given population.</p>"},{"location":"VCFX_ancestry_assigner/#output-format","title":"Output Format","text":"<p>The output is a tab-delimited text file with the following columns:</p> <pre><code>Sample  Assigned_Population\n</code></pre> <p>Where: - Sample is the sample name from the VCF file - Assigned_Population is the ancestral population with the highest likelihood score</p>"},{"location":"VCFX_ancestry_assigner/#examples","title":"Examples","text":""},{"location":"VCFX_ancestry_assigner/#basic-usage","title":"Basic Usage","text":"<pre><code>./VCFX_ancestry_assigner --assign-ancestry population_freqs.tsv &lt; samples.vcf &gt; ancestry_assignments.txt\n</code></pre>"},{"location":"VCFX_ancestry_assigner/#creating-a-frequency-reference-file","title":"Creating a Frequency Reference File","text":"<p>The frequency file should have the following tab-delimited format: <pre><code>CHROM  POS  REF  ALT  EUR  ASN  AFR\nchr1   10000  A    G    0.1  0.2  0.3\nchr1   20000  C    T    0.2  0.3  0.4\nchr2   15000  T    C    0.4  0.5  0.6\n</code></pre></p>"},{"location":"VCFX_ancestry_assigner/#using-in-a-pipeline","title":"Using in a Pipeline","text":"<pre><code># Process VCF and append ancestry information as a new column in a metadata file\ncat input.vcf | ./VCFX_ancestry_assigner --assign-ancestry freq.tsv | \\\n  join -t $'\\t' metadata.txt - &gt; metadata_with_ancestry.txt\n</code></pre>"},{"location":"VCFX_ancestry_assigner/#algorithm","title":"Algorithm","text":"<p>The ancestry assignment uses a maximum likelihood approach:</p> <ol> <li>For each sample and each variant:</li> <li>Determine the sample's genotype (0/0, 0/1, or 1/1)</li> <li>For each population, calculate the log-likelihood of observing that genotype:<ul> <li>Log(P(0/0|pop)) = 2 * log(1-f)</li> <li>Log(P(0/1|pop)) = log(2) + log(f) + log(1-f)</li> <li>Log(P(1/1|pop)) = 2 * log(f)</li> </ul> </li> <li> <p>Add this log-likelihood to the population's cumulative score</p> </li> <li> <p>After processing all variants:</p> </li> <li>For each sample, identify the population with the highest cumulative log-likelihood</li> <li>Assign the sample to that population</li> </ol> <p>This approach is statistically sound and accounts for the probability distribution of genotypes under Hardy-Weinberg equilibrium.</p>"},{"location":"VCFX_ancestry_assigner/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Missing genotypes: Genotypes denoted as \"./.\" are skipped and don't contribute to likelihood calculations</li> <li>Multi-allelic variants: Treated as biallelic by considering only the first alternate allele</li> <li>Missing variants: Variants present in the VCF but not in the frequency file are skipped</li> <li>Phased genotypes: Phase information is ignored; both \"0|1\" and \"0/1\" are treated identically</li> <li>Equal likelihoods: If two populations have exactly the same likelihood (rare), the first one is assigned</li> <li>No matching variants: If a sample has no variants that match the frequency file, it's assigned to a default population</li> <li>Non-standard genotypes: Any genotype other than 0/0, 0/1, or 1/1 is skipped</li> <li>Empty VCF: Will produce no output rows (empty output file)</li> </ul>"},{"location":"VCFX_ancestry_assigner/#performance","title":"Performance","text":"<p>The tool is optimized for efficiency: - Uses hash maps for fast lookup of variant frequency data - Single-pass processing of the VCF file - Calculates log-likelihoods to avoid numerical underflow with many variants - Memory usage scales with:   - The number of variants in the frequency file   - The number of reference populations   - The number of samples in the VCF</p>"},{"location":"VCFX_ancestry_assigner/#limitations","title":"Limitations","text":"<ul> <li>Requires a pre-existing set of population-specific allele frequencies</li> <li>Assumes Hardy-Weinberg equilibrium for probability calculations</li> <li>Does not account for linkage disequilibrium between variants</li> <li>Cannot detect admixed individuals (assigns to a single population)</li> <li>No confidence metrics for population assignment</li> <li>Not designed for structural variants or complex multi-allelic sites</li> <li>No support for non-diploid genotypes or unusual ploidy</li> <li>Performance depends on the number and informativeness of the variants in the frequency file </li> </ul>"},{"location":"VCFX_ancestry_inferrer/","title":"VCFX_ancestry_inferrer","text":""},{"location":"VCFX_ancestry_inferrer/#overview","title":"Overview","text":"<p>VCFX_ancestry_inferrer infers the likely population ancestry for each sample in a VCF file by comparing sample genotypes to known population allele frequencies.</p>"},{"location":"VCFX_ancestry_inferrer/#usage","title":"Usage","text":"<pre><code>VCFX_ancestry_inferrer --frequency &lt;freq_file&gt; [OPTIONS] &lt; input.vcf &gt; ancestry_results.txt\n</code></pre>"},{"location":"VCFX_ancestry_inferrer/#options","title":"Options","text":"Option Description <code>--frequency &lt;FILE&gt;</code> Required. Path to a file containing population-specific allele frequencies <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_ancestry_inferrer/#description","title":"Description","text":"<p>VCFX_ancestry_inferrer analyzes the genotypes of samples in a VCF file and compares them to known population-specific allele frequencies to determine the most likely ancestry for each sample. The tool:</p> <ol> <li>Reads a frequency reference file containing population-specific allele frequencies</li> <li>Processes the VCF file, examining each biallelic or multiallelic variant</li> <li>For each sample, calculates ancestry scores by comparing observed genotypes to population frequency data</li> <li>Assigns each sample to the population with the highest cumulative score</li> <li>Outputs a simple table mapping each sample to its inferred population</li> </ol> <p>The ancestry inference is based on the principle that individuals from a specific population are more likely to carry alleles at frequencies matching that population's known frequency distribution.</p>"},{"location":"VCFX_ancestry_inferrer/#output-format","title":"Output Format","text":"<p>The output is a tab-delimited text file with the following columns:</p> <pre><code>Sample  Inferred_Population\n</code></pre> <p>Where: - Sample is the sample name from the VCF file - Inferred_Population is the population with the highest ancestry score</p>"},{"location":"VCFX_ancestry_inferrer/#examples","title":"Examples","text":""},{"location":"VCFX_ancestry_inferrer/#basic-usage","title":"Basic Usage","text":"<pre><code>./VCFX_ancestry_inferrer --frequency population_freqs.txt &lt; samples.vcf &gt; ancestry_results.txt\n</code></pre>"},{"location":"VCFX_ancestry_inferrer/#creating-a-frequency-reference-file","title":"Creating a Frequency Reference File","text":"<p>The frequency file should have the following tab-delimited format: <pre><code>CHROM  POS  REF  ALT  POPULATION  FREQUENCY\n1      100  A    G    EUR         0.75\n1      100  A    G    AFR         0.10\n1      100  A    G    EAS         0.25\n</code></pre></p>"},{"location":"VCFX_ancestry_inferrer/#using-with-multi-population-data","title":"Using with Multi-Population Data","text":"<pre><code># Combine ancestry results with other data\n./VCFX_ancestry_inferrer --frequency global_freqs.txt &lt; diverse_cohort.vcf | \\\n  join -t $'\\t' -1 1 -2 1 - phenotype_data.txt &gt; annotated_results.tsv\n</code></pre>"},{"location":"VCFX_ancestry_inferrer/#algorithm","title":"Algorithm","text":"<p>The ancestry inference algorithm works as follows:</p> <ol> <li>For each variant in the VCF file:</li> <li> <p>For each sample with a non-reference genotype:</p> <ul> <li>Look up the frequency of that allele in each reference population</li> <li>Add the frequency value to that population's score for the sample</li> </ul> </li> <li> <p>After processing all variants:</p> </li> <li>For each sample, find the population with the highest cumulative score</li> <li>Assign the sample to that population</li> </ol> <p>This approach assigns more weight to alleles that are common in a specific population but rare in others, making them more informative for ancestry inference.</p>"},{"location":"VCFX_ancestry_inferrer/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Multi-allelic variants: Each alternate allele is treated separately and looked up in the frequency reference</li> <li>Phased genotypes: Phase information is ignored; both \"0|1\" and \"0/1\" are treated identically</li> <li>Missing genotypes: Missing genotypes (\"./.\") are skipped and don't contribute to ancestry scores</li> <li>Missing frequency data: Variants without corresponding frequency data are skipped</li> <li>Identical scores: If two populations have identical scores for a sample, the first one alphabetically is assigned</li> <li>Diploid genotypes: Both alleles contribute independently to the ancestry score</li> <li>Empty VCF: Will produce no output rows (empty output file)</li> <li>Unknown populations: Only populations defined in the frequency file will be considered</li> </ul>"},{"location":"VCFX_ancestry_inferrer/#performance","title":"Performance","text":"<p>The tool is optimized for efficiency: - Uses hash maps for constant-time lookups of frequency data - Single-pass processing of the VCF file - Memory usage scales with:   - The number of variants in the frequency file   - The number of reference populations   - The number of samples in the VCF</p>"},{"location":"VCFX_ancestry_inferrer/#limitations","title":"Limitations","text":"<ul> <li>Accuracy depends on the quality and relevance of the population frequency data</li> <li>Works best with large numbers of variants (hundreds to thousands)</li> <li>Not designed for detecting admixed individuals (reports only the highest-scoring population)</li> <li>Assumes independence between variants (does not account for linkage disequilibrium)</li> <li>No confidence scores or statistical measures of assignment certainty</li> <li>Cannot handle non-biallelic complex variants (e.g., structural variants)</li> <li>Doesn't account for sample relatedness within the input VCF </li> </ul>"},{"location":"VCFX_annotation_extractor/","title":"VCFX_annotation_extractor","text":""},{"location":"VCFX_annotation_extractor/#overview","title":"Overview","text":"<p>VCFX_annotation_extractor extracts annotation fields from a VCF file's INFO column and converts them into a tabular format. The tool is particularly useful for extracting specific annotations (such as functional impact, gene name, or any custom annotation) from VCF files into a more analysis-friendly TSV format.</p>"},{"location":"VCFX_annotation_extractor/#usage","title":"Usage","text":"<pre><code>VCFX_annotation_extractor --annotation-extract \"FIELD1,FIELD2,...\" &lt; input.vcf &gt; extracted.tsv\n</code></pre>"},{"location":"VCFX_annotation_extractor/#options","title":"Options","text":"Option Description <code>-a</code>, <code>--annotation-extract &lt;FIELDS&gt;</code> Required. Comma-separated list of INFO field annotations to extract (e.g., \"ANN,Gene,Impact\") <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_annotation_extractor/#description","title":"Description","text":"<p>VCFX_annotation_extractor simplifies the extraction and analysis of variant annotations by:</p> <ol> <li>Reading a VCF file from standard input</li> <li>Parsing the INFO column to extract user-specified annotation fields</li> <li>Handling multi-allelic variants by creating separate rows for each ALT allele</li> <li>Aligning per-allele annotations (such as ANN) with the corresponding ALT allele</li> <li>Producing a clean tab-delimited output with standardized columns</li> </ol> <p>This tool is particularly useful for: - Converting complex VCF annotations into a format suitable for spreadsheet applications - Extracting specific annotation fields for focused analysis - Preparing variant annotation data for visualization or reporting - Working with multi-allelic variants where annotations correspond to specific alleles</p>"},{"location":"VCFX_annotation_extractor/#output-format","title":"Output Format","text":"<p>The output is a tab-separated (TSV) file with the following columns:</p> <pre><code>CHROM  POS  ID  REF  ALT  &lt;ANNOTATION1&gt;  &lt;ANNOTATION2&gt;  ...\n</code></pre> <p>Where: - The first five columns are standard VCF fields (chromosome, position, ID, reference allele, alternate allele) - Each subsequent column contains the value of a requested annotation field - Missing values are represented by \"NA\" - Multi-allelic variants are split into multiple rows, one for each ALT allele - Per-allele annotations (like ANN) are properly aligned with their corresponding ALT allele</p>"},{"location":"VCFX_annotation_extractor/#examples","title":"Examples","text":""},{"location":"VCFX_annotation_extractor/#basic-usage-extract-gene-annotations","title":"Basic Usage - Extract Gene Annotations","text":"<pre><code>./VCFX_annotation_extractor --annotation-extract \"Gene\" &lt; input.vcf &gt; genes.tsv\n</code></pre>"},{"location":"VCFX_annotation_extractor/#extract-multiple-annotation-fields","title":"Extract Multiple Annotation Fields","text":"<pre><code>./VCFX_annotation_extractor --annotation-extract \"ANN,Gene,Impact,DP\" &lt; input.vcf &gt; annotations.tsv\n</code></pre>"},{"location":"VCFX_annotation_extractor/#process-and-filter-in-a-pipeline","title":"Process and Filter in a Pipeline","text":"<pre><code># Extract annotations from only PASS variants\ngrep -e \"^#\" -e \"PASS\" input.vcf | ./VCFX_annotation_extractor --annotation-extract \"ANN,Gene,Impact\" &gt; pass_annotations.tsv\n</code></pre>"},{"location":"VCFX_annotation_extractor/#analyze-impact-distribution","title":"Analyze Impact Distribution","text":"<pre><code># Extract impact annotations and count occurrences\n./VCFX_annotation_extractor --annotation-extract \"Impact\" &lt; input.vcf | tail -n +2 | cut -f6 | sort | uniq -c\n</code></pre>"},{"location":"VCFX_annotation_extractor/#multi-allelic-variant-handling","title":"Multi-allelic Variant Handling","text":"<p>The tool handles multi-allelic variants specially:</p> <ol> <li>Each ALT allele in a multi-allelic variant gets its own row in the output</li> <li>For Number=A annotations (like ANN) that have multiple comma-separated values, each value is aligned with the corresponding ALT allele</li> <li>For single-value annotations (like Gene, Impact), the same value is used for all ALT alleles of a variant</li> <li>If there are more ALT alleles than annotation values, \"NA\" is used for the excess ALT alleles</li> </ol>"},{"location":"VCFX_annotation_extractor/#example","title":"Example","text":"<p>For a variant line with <code>ALT=T,G,C</code> and <code>ANN=missense,stop_gained,intergenic</code>: - Three rows will be generated in the output (one for each ALT) - The annotations will be properly aligned: T\u2192missense, G\u2192stop_gained, C\u2192intergenic</p>"},{"location":"VCFX_annotation_extractor/#handling-special-cases","title":"Handling Special Cases","text":"<p>The tool implements several strategies for handling edge cases:</p> <ol> <li>Missing annotations: If a requested annotation is not found, \"NA\" is output</li> <li>Malformed VCF lines: Lines with fewer than 8 columns are skipped with a warning</li> <li>Empty annotations: Empty annotation values are preserved and not replaced with \"NA\"</li> <li>Multi-value annotations: Currently, only ANN field is treated as multi-value and split by commas</li> <li>Header parsing: The tool checks for proper VCF headers before processing data</li> <li>Empty input: The tool correctly handles empty input files, producing only the header line</li> <li>Invalid characters: The tool preserves all characters in annotation values, including special characters</li> </ol>"},{"location":"VCFX_annotation_extractor/#performance","title":"Performance","text":"<p>VCFX_annotation_extractor is designed for efficiency:</p> <ol> <li>Single-pass processing reads the VCF file line-by-line without loading the entire file into memory</li> <li>Efficient string parsing with optimized splitting functions</li> <li>Uses hash maps for quick annotation lookups</li> <li>Memory usage scales with the size of individual variant lines rather than the whole file</li> <li>Output is streamed directly without intermediate storage</li> </ol>"},{"location":"VCFX_annotation_extractor/#limitations","title":"Limitations","text":"<ol> <li>Currently, only the ANN field is recognized as a per-allele (Number=A) field that needs to be split; other Number=A fields are not automatically detected</li> <li>No VCF header parsing to automatically determine which fields are Number=A vs. Number=1</li> <li>Cannot extract FORMAT fields or sample-specific information</li> <li>The output does not include QUAL or FILTER columns from the input VCF</li> <li>No wildcard or regex support for selecting annotation fields</li> <li>Annotation fields with embedded tab or newline characters may cause issues in the output format</li> <li>Limited error recovery for malformed INFO fields </li> </ol>"},{"location":"VCFX_compressor/","title":"VCFX_compressor","text":""},{"location":"VCFX_compressor/#overview","title":"Overview","text":"<p>VCFX_compressor provides simple compression and decompression functionality for VCF files using the zlib library. It allows users to compress VCF files for storage or transfer, and decompress them for analysis.</p>"},{"location":"VCFX_compressor/#usage","title":"Usage","text":"<pre><code>VCFX_compressor [OPTIONS] &lt; input_file &gt; output_file\n</code></pre>"},{"location":"VCFX_compressor/#options","title":"Options","text":"Option Description <code>-c</code>, <code>--compress</code> Compress the input VCF file (read from stdin, write to stdout) <code>-d</code>, <code>--decompress</code> Decompress the input VCF.gz file (read from stdin, write to stdout) <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_compressor/#description","title":"Description","text":"<p>VCFX_compressor is a straightforward utility that enables compression and decompression of VCF files using zlib's DEFLATE algorithm. The tool:</p> <ol> <li>Reads input data from standard input (stdin)</li> <li>Processes the data in memory-efficient chunks</li> <li>Applies compression or decompression based on the specified mode</li> <li>Writes the processed data to standard output (stdout)</li> </ol> <p>The compression mode produces output compatible with gzip, while the decompression mode can handle standard gzip-compressed files. This makes the tool interoperable with widely used genomics software that expects gzip-compressed VCF files.</p>"},{"location":"VCFX_compressor/#output-format","title":"Output Format","text":"<p>The output format depends on the chosen mode:</p> <ul> <li>Compression mode: Produces a gzip-compatible compressed binary file</li> <li>Decompression mode: Produces a plain text VCF file</li> </ul>"},{"location":"VCFX_compressor/#examples","title":"Examples","text":""},{"location":"VCFX_compressor/#compressing-a-vcf-file","title":"Compressing a VCF File","text":"<pre><code># Basic compression\n./VCFX_compressor --compress &lt; input.vcf &gt; output.vcf.gz\n\n# Compress and view file size reduction\n./VCFX_compressor --compress &lt; input.vcf &gt; output.vcf.gz\necho \"Original size: $(wc -c &lt; input.vcf) bytes\"\necho \"Compressed size: $(wc -c &lt; output.vcf.gz) bytes\"\n</code></pre>"},{"location":"VCFX_compressor/#decompressing-a-vcf-file","title":"Decompressing a VCF File","text":"<pre><code># Basic decompression\n./VCFX_compressor --decompress &lt; input.vcf.gz &gt; output.vcf\n\n# Decompress for analysis\n./VCFX_compressor --decompress &lt; input.vcf.gz | head -n 20\n</code></pre>"},{"location":"VCFX_compressor/#in-a-pipeline","title":"In a Pipeline","text":"<pre><code># Filter a VCF file, compress it, then decompress for viewing\ncat input.vcf | grep -v \"^#\" | grep \"PASS\" | ./VCFX_compressor --compress &gt; filtered.vcf.gz\n./VCFX_compressor --decompress &lt; filtered.vcf.gz | head\n</code></pre>"},{"location":"VCFX_compressor/#data-processing","title":"Data Processing","text":"<p>VCFX_compressor processes data in chunks to maintain memory efficiency. The default chunk size is 16KB, which provides a good balance between memory usage and processing efficiency. The tool:</p> <ol> <li>Reads input data in 16KB chunks</li> <li>Processes each chunk using zlib's compression/decompression functions</li> <li>Writes processed data to output immediately as each chunk is completed</li> <li>Continues until all input data has been processed</li> </ol> <p>This streaming approach allows the tool to handle files of any size without loading the entire file into memory.</p>"},{"location":"VCFX_compressor/#handling-special-cases","title":"Handling Special Cases","text":"<p>The tool implements several strategies for handling edge cases:</p> <ol> <li>Empty files: Properly handles empty input, producing valid empty output</li> <li>Truncated inputs: When decompressing, detects and warns about truncated or incomplete compressed data</li> <li>Invalid compressed data: Reports errors when attempting to decompress invalid or corrupted data</li> <li>I/O errors: Provides error messages for issues with reading input or writing output</li> <li>Incorrect usage: Enforces mutually exclusive selection of compression or decompression mode</li> </ol>"},{"location":"VCFX_compressor/#performance","title":"Performance","text":"<p>VCFX_compressor is designed for efficiency:</p> <ol> <li>Processes data in chunks, maintaining a low and consistent memory footprint</li> <li>Uses zlib's optimized compression/decompression algorithms</li> <li>Avoids unnecessary memory copying or buffering of the entire file</li> <li>Provides reasonable compression ratios typical of gzip compression</li> <li>Handles large files efficiently due to its streaming architecture</li> </ol>"},{"location":"VCFX_compressor/#limitations","title":"Limitations","text":"<ol> <li>Not BGZF compatible: Does not produce block-gzipped format required for indexed access via tabix</li> <li>No compression level control: Uses zlib's default compression level with no user-configurable options</li> <li>Single-threaded: Does not utilize multi-threading for potentially faster processing</li> <li>No integrity verification: Does not verify the integrity of decompressed data</li> <li>Limited format support: Only handles gzip compression, not other formats like bzip2 or xz</li> <li>No indexing support: Does not maintain or generate indices for compressed files</li> <li>Standard I/O only: Cannot directly specify input and output filenames (uses stdin/stdout) </li> </ol>"},{"location":"VCFX_concordance_checker/","title":"VCFX_concordance_checker","text":""},{"location":"VCFX_concordance_checker/#overview","title":"Overview","text":"<p><code>VCFX_concordance_checker</code> compares genotypes between two specified samples within a VCF file to determine concordance (agreement) or discordance (disagreement) for each variant. This tool is useful for comparing genotype calls between different samples, such as technical replicates or related individuals.</p>"},{"location":"VCFX_concordance_checker/#usage","title":"Usage","text":"<pre><code>VCFX_concordance_checker --samples \"SAMPLE1 SAMPLE2\" &lt; input.vcf &gt; concordance_report.tsv\n</code></pre>"},{"location":"VCFX_concordance_checker/#options","title":"Options","text":"Option Description <code>-s</code>, <code>--samples \"SAMPLE1 SAMPLE2\"</code> Required. Names of the two samples to compare, separated by a space <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_concordance_checker/#description","title":"Description","text":"<p><code>VCFX_concordance_checker</code> analyzes a VCF file and compares the genotypes of two specified samples for each variant. The tool:</p> <ol> <li>Normalizes genotypes by:</li> <li>Converting phased genotypes (<code>|</code>) to unphased (<code>/</code>)</li> <li>Sorting alleles numerically (e.g., <code>1/0</code> becomes <code>0/1</code>)</li> <li>Validating against available alternate alleles</li> <li>Compares the normalized genotypes between the two samples</li> <li>Classifies each variant as:</li> <li><code>Concordant</code>: Both samples have identical normalized genotypes</li> <li><code>Discordant</code>: Samples have different normalized genotypes</li> <li>Outputs detailed per-variant results to standard output</li> <li>Provides a summary of concordance statistics to standard error</li> </ol> <p>This tool is particularly useful for: - Quality control of technical replicates - Comparing genotype calls between related samples - Validating sample identity - Assessing reproducibility of variant calling pipelines</p>"},{"location":"VCFX_concordance_checker/#output-format","title":"Output Format","text":"<p>The tool produces a tab-separated values (TSV) file with the following columns:</p> Column Description CHROM Chromosome of the variant POS Position of the variant ID Variant identifier REF Reference allele ALT Alternate allele(s) SAMPLE1_GT Normalized genotype of the first sample SAMPLE2_GT Normalized genotype of the second sample Concordance Status: <code>Concordant</code> or <code>Discordant</code> <p>Additionally, a summary of statistics is printed to standard error, including: - Total number of variants compared - Number of concordant genotypes - Number of discordant genotypes</p>"},{"location":"VCFX_concordance_checker/#examples","title":"Examples","text":""},{"location":"VCFX_concordance_checker/#basic-usage","title":"Basic Usage","text":"<p>Check concordance between two samples in a VCF file: <pre><code>VCFX_concordance_checker --samples \"SAMPLE1 SAMPLE2\" &lt; input.vcf &gt; concordance_report.tsv\n</code></pre></p>"},{"location":"VCFX_concordance_checker/#filtering-for-discordant-variants","title":"Filtering for Discordant Variants","text":"<p>Identify only variants with discordant genotypes: <pre><code>VCFX_concordance_checker --samples \"SAMPLE1 SAMPLE2\" &lt; input.vcf | grep \"Discordant\" &gt; discordant_variants.tsv\n</code></pre></p>"},{"location":"VCFX_concordance_checker/#calculating-concordance-rate","title":"Calculating Concordance Rate","text":"<p>Count concordant variants and calculate rate: <pre><code>VCFX_concordance_checker --samples \"SAMPLE1 SAMPLE2\" &lt; input.vcf &gt; report.tsv 2&gt; stats.txt\ngrep -c \"Concordant\" report.tsv &gt; concordant_count.txt\n</code></pre></p>"},{"location":"VCFX_concordance_checker/#integration-with-other-tools","title":"Integration with Other Tools","text":"<p>Use as part of a larger analysis pipeline: <pre><code>cat input.vcf | VCFX_record_filter --filter \"QUAL&gt;30\" | VCFX_concordance_checker --samples \"SAMPLE1 SAMPLE2\" &gt; high_quality_concordance.tsv\n</code></pre></p>"},{"location":"VCFX_concordance_checker/#genotype-normalization","title":"Genotype Normalization","text":""},{"location":"VCFX_concordance_checker/#process","title":"Process","text":"<p>For each sample's genotype, the tool performs the following normalization steps: 1. Extracts the genotype field (GT) 2. Converts all phase separators (<code>|</code>) to unphased separators (<code>/</code>) 3. Splits the genotype into individual allele indices 4. Validates each allele (skips if missing or invalid) 5. Sorts allele indices in ascending order (e.g., <code>1/0</code> \u2192 <code>0/1</code>) 6. Rejoins the allele indices with <code>/</code> separators</p>"},{"location":"VCFX_concordance_checker/#example-normalizations","title":"Example Normalizations","text":"<ul> <li><code>0|1</code> \u2192 <code>0/1</code></li> <li><code>1/0</code> \u2192 <code>0/1</code></li> <li><code>1|2</code> \u2192 <code>1/2</code></li> <li><code>2/1</code> \u2192 <code>1/2</code></li> <li><code>./1</code> \u2192 (skipped as invalid)</li> <li><code>0/0</code> \u2192 <code>0/0</code> (unchanged)</li> </ul>"},{"location":"VCFX_concordance_checker/#handling-special-cases","title":"Handling Special Cases","text":""},{"location":"VCFX_concordance_checker/#missing-genotypes","title":"Missing Genotypes","text":"<ul> <li>Genotypes with missing values (<code>./.</code>, <code>.</code>) are excluded from comparison</li> <li>Variants where either sample has missing genotypes are skipped</li> </ul>"},{"location":"VCFX_concordance_checker/#multi-allelic-variants","title":"Multi-allelic Variants","text":"<ul> <li>Alt alleles are parsed from the ALT column (comma-separated)</li> <li>Genotype allele indices are validated against the number of alt alleles</li> <li>For multi-allelic variants, the tool correctly compares numerically sorted genotypes</li> </ul>"},{"location":"VCFX_concordance_checker/#phased-genotypes","title":"Phased Genotypes","text":"<ul> <li>Phasing information is ignored for concordance calculation</li> <li>Genotypes that differ only in phasing are considered concordant (e.g., <code>0|1</code> and <code>0/1</code>)</li> </ul>"},{"location":"VCFX_concordance_checker/#invalid-genotypes","title":"Invalid Genotypes","text":"<ul> <li>Genotypes with non-numeric allele indices are skipped</li> <li>Allele indices that exceed the number of alternate alleles are treated as invalid</li> </ul>"},{"location":"VCFX_concordance_checker/#malformed-vcf-lines","title":"Malformed VCF Lines","text":"<ul> <li>Lines with insufficient columns are skipped</li> <li>Lines encountered before the #CHROM header cause an error</li> <li>VCF files without both specified samples cause an error and program termination</li> </ul>"},{"location":"VCFX_concordance_checker/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Processes the VCF file line by line, requiring minimal memory</li> <li>No preprocessing or indexing of the VCF file is required</li> <li>Linear time complexity with respect to file size</li> <li>Provides a quick summary of concordance statistics for rapid quality assessment</li> </ul>"},{"location":"VCFX_concordance_checker/#limitations","title":"Limitations","text":"<ul> <li>Limited to exactly two samples for comparison</li> <li>Only processes diploid genotypes (e.g., <code>0/1</code>, not haploid <code>0</code> or polyploid genotypes)</li> <li>Ignores all FORMAT fields except for GT (genotype)</li> <li>No consideration of genotype quality or other metrics in concordance assessment</li> <li>Cannot generate detailed statistics on concordance by variant type</li> <li>Does not allow customizing concordance criteria beyond exact genotype match </li> </ul>"},{"location":"VCFX_cross_sample_concordance/","title":"VCFX_cross_sample_concordance","text":""},{"location":"VCFX_cross_sample_concordance/#overview","title":"Overview","text":"<p><code>VCFX_cross_sample_concordance</code> analyzes a multi-sample VCF file to determine if genotypes are consistent across all samples for each variant. It identifies variants where samples show concordance (agreement) or discordance (disagreement) in their genotype calls.</p>"},{"location":"VCFX_cross_sample_concordance/#usage","title":"Usage","text":"<pre><code>VCFX_cross_sample_concordance [OPTIONS] &lt; input.vcf &gt; concordance_results.tsv\n</code></pre>"},{"location":"VCFX_cross_sample_concordance/#options","title":"Options","text":"Option Description <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-s</code>, <code>--samples</code> Comma-separated list of samples to check"},{"location":"VCFX_cross_sample_concordance/#description","title":"Description","text":"<p><code>VCFX_cross_sample_concordance</code> examines each variant in a multi-sample VCF file and determines if all samples with valid genotypes have the same normalized genotype. The tool:</p> <ol> <li>Normalizes genotypes across samples by:</li> <li>Converting phased genotypes (<code>|</code>) to unphased (<code>/</code>)</li> <li>Handling multi-allelic variants properly</li> <li>Sorting alleles numerically for consistent comparison (e.g., <code>1/0</code> becomes <code>0/1</code>)</li> <li>Compares the normalized genotypes across all samples for each variant</li> <li>Classifies each variant as:</li> <li><code>CONCORDANT</code>: All samples with valid genotypes have the same normalized genotype</li> <li><code>DISCORDANT</code>: Samples have different normalized genotypes</li> <li><code>NO_GENOTYPES</code>: No samples have valid genotypes for this variant</li> <li>Outputs detailed per-variant results to standard output</li> <li>Provides a summary of concordance statistics to standard error</li> </ol> <p>This tool is particularly useful for: - Quality control of multi-sample VCF files - Identifying potential sample mix-ups or contamination - Validating genotype calling consistency across technical replicates - Assessing reliability of variant calls across different sequencing or analysis methods</p>"},{"location":"VCFX_cross_sample_concordance/#output-format","title":"Output Format","text":"<p>The tool produces a tab-separated values (TSV) file with the following columns:</p> Column Description CHROM Chromosome of the variant POS Position of the variant ID Variant identifier REF Reference allele ALT Alternate allele(s) Num_Samples Number of samples with valid genotypes Unique_Normalized_Genotypes Number of distinct normalized genotypes observed Concordance_Status Status: <code>CONCORDANT</code>, <code>DISCORDANT</code>, or <code>NO_GENOTYPES</code> <p>Additionally, a summary of statistics is printed to standard error, including: - Total number of variants processed - Number of concordant variants - Number of discordant variants - Number of variants with no valid genotypes</p>"},{"location":"VCFX_cross_sample_concordance/#examples","title":"Examples","text":""},{"location":"VCFX_cross_sample_concordance/#basic-usage","title":"Basic Usage","text":"<p>Check concordance in a multi-sample VCF file: <pre><code>VCFX_cross_sample_concordance &lt; input.vcf &gt; concordance_results.tsv\n</code></pre></p> <p>Specify a subset of samples:</p> <pre><code>VCFX_cross_sample_concordance --samples SampleA,SampleB &lt; input.vcf &gt; concordance_subset.tsv\n</code></pre>"},{"location":"VCFX_cross_sample_concordance/#filtering-for-discordant-variants","title":"Filtering for Discordant Variants","text":"<p>Identify only variants with discordant genotypes: <pre><code>VCFX_cross_sample_concordance &lt; input.vcf | grep \"DISCORDANT\" &gt; discordant_variants.tsv\n</code></pre></p>"},{"location":"VCFX_cross_sample_concordance/#concordance-analysis-in-a-pipeline","title":"Concordance Analysis in a Pipeline","text":"<p>Use as part of a larger analysis pipeline: <pre><code>cat input.vcf | VCFX_cross_sample_concordance | awk -F'\\t' '{if($8==\"CONCORDANT\") print $0}' &gt; consistent_variants.tsv\n</code></pre></p>"},{"location":"VCFX_cross_sample_concordance/#saving-both-results-and-summary","title":"Saving Both Results and Summary","text":"<p>Capture both the detailed results and summary statistics: <pre><code>VCFX_cross_sample_concordance &lt; input.vcf &gt; concordance_results.tsv 2&gt; concordance_summary.txt\n</code></pre></p>"},{"location":"VCFX_cross_sample_concordance/#genotype-normalization","title":"Genotype Normalization","text":""},{"location":"VCFX_cross_sample_concordance/#process","title":"Process","text":"<p>For each sample's genotype, the tool performs the following normalization steps: 1. Extracts the genotype field (first field in the FORMAT column) 2. Converts all phase separators (<code>|</code>) to unphased separators (<code>/</code>) 3. Splits the genotype into individual allele indices 4. Validates each allele (skips if missing or invalid) 5. Sorts allele indices in ascending order (e.g., <code>1/0</code> \u2192 <code>0/1</code>) 6. Rejoins the allele indices with <code>/</code> separators</p>"},{"location":"VCFX_cross_sample_concordance/#example-normalizations","title":"Example Normalizations","text":"<ul> <li><code>0|1</code> \u2192 <code>0/1</code></li> <li><code>1/0</code> \u2192 <code>0/1</code></li> <li><code>1|2</code> \u2192 <code>1/2</code></li> <li><code>2/1</code> \u2192 <code>1/2</code></li> <li><code>./1</code> \u2192 (skipped as invalid)</li> <li><code>0/0</code> \u2192 <code>0/0</code> (unchanged)</li> </ul>"},{"location":"VCFX_cross_sample_concordance/#handling-special-cases","title":"Handling Special Cases","text":""},{"location":"VCFX_cross_sample_concordance/#missing-genotypes","title":"Missing Genotypes","text":"<ul> <li>Genotypes with missing values (<code>./.</code>, <code>.</code>) are excluded from concordance calculation</li> <li>If no samples have valid genotypes for a variant, it is classified as <code>NO_GENOTYPES</code></li> </ul>"},{"location":"VCFX_cross_sample_concordance/#multi-allelic-variants","title":"Multi-allelic Variants","text":"<ul> <li>Alt alleles are parsed from the ALT column (comma-separated)</li> <li>Genotype allele indices are validated against the number of alt alleles</li> <li>Invalid indices (exceeding the number of alt alleles) are treated as missing</li> </ul>"},{"location":"VCFX_cross_sample_concordance/#phased-genotypes","title":"Phased Genotypes","text":"<ul> <li>Phasing information is ignored for concordance calculation</li> <li>Genotypes that differ only in phasing are considered concordant</li> </ul>"},{"location":"VCFX_cross_sample_concordance/#malformed-vcf-lines","title":"Malformed VCF Lines","text":"<ul> <li>Lines with insufficient columns are skipped</li> <li>Lines encountered before the #CHROM header are skipped with a warning</li> <li>Genotypes that cannot be parsed are treated as missing</li> </ul>"},{"location":"VCFX_cross_sample_concordance/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Processes the VCF file line by line, requiring minimal memory</li> <li>Time complexity scales linearly with file size and number of samples</li> <li>Efficient handling of large multi-sample VCF files with normalized genotype comparisons</li> <li>No file indexing or preprocessing required</li> </ul>"},{"location":"VCFX_cross_sample_concordance/#limitations","title":"Limitations","text":"<ul> <li>Only handles diploid genotypes (e.g., <code>0/1</code>, not haploid <code>0</code> or polyploid genotypes)</li> <li>Ignores genotype phasing information in concordance assessment</li> <li>Does not consider genotype quality or other FORMAT fields in the assessment</li> <li>No option to adjust concordance thresholds (e.g., requiring 90% sample agreement)</li> <li>Cannot output detailed per-sample information for discordant variants </li> </ul>"},{"location":"VCFX_custom_annotator/","title":"VCFX_custom_annotator","text":""},{"location":"VCFX_custom_annotator/#overview","title":"Overview","text":"<p>VCFX_custom_annotator adds custom annotations to VCF files by matching variants from a user-provided annotation file and inserting them into the INFO field. This tool is particularly useful for incorporating external annotations, functional predictions, or custom labels into your VCF files.</p>"},{"location":"VCFX_custom_annotator/#usage","title":"Usage","text":"<pre><code>VCFX_custom_annotator --add-annotation &lt;annotations.txt&gt; [OPTIONS] &lt; input.vcf &gt; annotated.vcf\n</code></pre>"},{"location":"VCFX_custom_annotator/#options","title":"Options","text":"Option Description <code>-a</code>, <code>--add-annotation &lt;file&gt;</code> Required. Path to the annotation file containing the custom annotations <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_custom_annotator/#description","title":"Description","text":"<p>VCFX_custom_annotator is designed to enhance VCF files with custom annotations from an external source. The tool:</p> <ol> <li>Reads an annotation file where each line contains: <code>CHROM POS REF ALT annotation_value</code></li> <li>Creates a lookup map using the variant coordinates and alleles as keys</li> <li>Processes the input VCF file line by line</li> <li>For each variant, generates a key from its coordinates and alleles</li> <li>Looks up any matching annotations</li> <li>Adds the annotation to the INFO field as <code>CustomAnnotation=value</code></li> <li>For multi-allelic variants, handles each alternate allele separately</li> <li>Outputs the annotated VCF to standard output</li> </ol> <p>This streamlined process allows for efficient annotation of VCF files with minimal computational overhead.</p>"},{"location":"VCFX_custom_annotator/#annotation-file-format","title":"Annotation File Format","text":"<p>The annotation file should contain tab-separated fields with the following columns:</p> <pre><code>CHROM POS REF ALT annotation_value\n</code></pre> <p>Example: <pre><code>1  100  A  G  HighImpact\n1  200  T  C  ModerateImpact\n2  300  G  A  LowImpact\n</code></pre></p> <ul> <li>CHROM: Chromosome name (must match the VCF)</li> <li>POS: Position (1-based, must match the VCF)</li> <li>REF: Reference allele (must match the VCF)</li> <li>ALT: Alternate allele</li> <li>annotation_value: The annotation text to add (can include spaces after the first 4 fields)</li> </ul>"},{"location":"VCFX_custom_annotator/#output-format","title":"Output Format","text":"<p>The output is a valid VCF file that includes:</p> <ol> <li>All original header lines</li> <li>A new INFO field definition: <code>##INFO=&lt;ID=CustomAnnotation,Number=.,Type=String,Description=\"Custom annotations added by VCFX_custom_annotator (multi-allelic)\"&gt;</code></li> <li>All original variant lines with the added <code>CustomAnnotation=value</code> in the INFO column</li> <li>For multi-allelic variants, comma-separated annotation values corresponding to each ALT allele</li> </ol> <p>For variants without a matching annotation, the value \"NA\" is used.</p>"},{"location":"VCFX_custom_annotator/#examples","title":"Examples","text":""},{"location":"VCFX_custom_annotator/#basic-usage","title":"Basic Usage","text":"<pre><code># Annotate a VCF file with functional impact predictions\n./VCFX_custom_annotator --add-annotation impact_predictions.txt &lt; input.vcf &gt; annotated.vcf\n</code></pre>"},{"location":"VCFX_custom_annotator/#viewing-annotated-results","title":"Viewing Annotated Results","text":"<pre><code># Annotate and view the first few variants\n./VCFX_custom_annotator --add-annotation annotations.txt &lt; input.vcf | head -n 20\n</code></pre>"},{"location":"VCFX_custom_annotator/#filtering-based-on-annotations","title":"Filtering Based on Annotations","text":"<pre><code># Annotate variants and filter to keep only those with \"HighImpact\"\n./VCFX_custom_annotator --add-annotation annotations.txt &lt; input.vcf | grep \"CustomAnnotation=HighImpact\" &gt; high_impact_variants.vcf\n</code></pre>"},{"location":"VCFX_custom_annotator/#multi-allelic-variant-handling","title":"Multi-allelic Variant Handling","text":"<p>VCFX_custom_annotator properly handles multi-allelic variants by:</p> <ol> <li>Parsing and splitting the ALT field in the VCF on commas</li> <li>Looking up annotations for each REF\u2192ALT pair separately</li> <li>Combining the annotations into a comma-separated list in the same order as the ALT alleles</li> <li>Using \"NA\" as a placeholder when no annotation is found for a specific allele</li> </ol> <p>For example, if a variant has <code>ALT=G,C,T</code> and annotations exist for the G and T alleles but not C, the result will be <code>CustomAnnotation=annotation_G,NA,annotation_T</code>.</p>"},{"location":"VCFX_custom_annotator/#handling-special-cases","title":"Handling Special Cases","text":"<p>The tool implements several strategies for handling edge cases:</p> <ol> <li>Missing annotations: Uses \"NA\" when no annotation is found for a variant</li> <li>Empty annotation file: Results in \"NA\" for all variants</li> <li>Malformed annotation lines: Invalid lines in the annotation file are skipped with a warning</li> <li>Missing annotation file: Reports an error if the annotation file cannot be opened</li> <li>Empty INFO field: If the original INFO field is \".\" (missing), it's replaced with the new annotation</li> <li>Existing INFO content: If the INFO field has existing content, annotations are appended</li> <li>Multi-allelic variants: Each allele is handled separately with proper ordering</li> </ol>"},{"location":"VCFX_custom_annotator/#performance","title":"Performance","text":"<p>VCFX_custom_annotator is designed for efficiency:</p> <ol> <li>Annotation file is loaded into memory as a hash map for O(1) lookups</li> <li>VCF file is processed in a streaming fashion, with minimal memory overhead</li> <li>Line-by-line processing allows handling of arbitrarily large VCF files</li> <li>String operations are optimized to minimize unnecessary copies</li> <li>Capable of processing thousands of variants per second on typical hardware</li> </ol>"},{"location":"VCFX_custom_annotator/#limitations","title":"Limitations","text":"<ol> <li>Requires exact matching of CHROM, POS, REF, and ALT fields</li> <li>Cannot perform fuzzy matching or coordinate-based lookups</li> <li>All annotations are stored in memory, which may be a limitation for extremely large annotation files</li> <li>Limited to a single annotation per variant (although annotations can contain multiple pieces of information)</li> <li>No built-in option to modify the name of the added INFO field from the default \"CustomAnnotation\"</li> <li>No support for annotating based on overlapping regions rather than exact positions</li> <li>Annotations with internal commas may cause parsing issues in multi-allelic contexts </li> </ol>"},{"location":"VCFX_diff_tool/","title":"VCFX_diff_tool","text":""},{"location":"VCFX_diff_tool/#overview","title":"Overview","text":"<p>VCFX_diff_tool compares two VCF files and identifies variants that are unique to each file, providing a simple way to detect differences between variant sets.</p>"},{"location":"VCFX_diff_tool/#usage","title":"Usage","text":"<pre><code>VCFX_diff_tool --file1 &lt;file1.vcf&gt; --file2 &lt;file2.vcf&gt;\n</code></pre>"},{"location":"VCFX_diff_tool/#options","title":"Options","text":"Option Description <code>-a</code>, <code>--file1 &lt;FILE&gt;</code> Required. Path to the first VCF file <code>-b</code>, <code>--file2 &lt;FILE&gt;</code> Required. Path to the second VCF file <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_diff_tool/#description","title":"Description","text":"<p>VCFX_diff_tool analyzes two VCF files, compares their variant content, and identifies differences between them. The tool:</p> <ol> <li>Loads variants from both VCF files, ignoring header lines</li> <li>Creates a normalized key for each variant based on chromosome, position, reference allele, and sorted alternate alleles</li> <li>Identifies variants that are unique to each file by comparing these keys</li> <li>Reports the differences in a readable format</li> </ol> <p>This tool is particularly useful for: - Validating VCF file transformations - Checking tool outputs against expected results - Comparing variant calls between different callers or pipelines - Verifying that VCF manipulations haven't inadvertently altered variant content</p>"},{"location":"VCFX_diff_tool/#output-format","title":"Output Format","text":"<p>The output consists of two sections:</p> <pre><code>Variants unique to file1.vcf:\nchrom:pos:ref:alt\nchrom:pos:ref:alt\n...\n\nVariants unique to file2.vcf:\nchrom:pos:ref:alt\nchrom:pos:ref:alt\n...\n</code></pre> <p>Where each variant is represented as a colon-separated string with chromosome, position, reference allele, and sorted alternate alleles.</p>"},{"location":"VCFX_diff_tool/#examples","title":"Examples","text":""},{"location":"VCFX_diff_tool/#basic-usage","title":"Basic Usage","text":"<pre><code>./VCFX_diff_tool --file1 original.vcf --file2 modified.vcf\n</code></pre>"},{"location":"VCFX_diff_tool/#comparing-variant-caller-outputs","title":"Comparing Variant Caller Outputs","text":"<pre><code>./VCFX_diff_tool --file1 caller1_output.vcf --file2 caller2_output.vcf &gt; caller_differences.txt\n</code></pre>"},{"location":"VCFX_diff_tool/#validate-processing-results","title":"Validate Processing Results","text":"<pre><code># Check that filtering didn't remove variants it shouldn't have\n./VCFX_diff_tool --file1 expected_filtered.vcf --file2 actual_filtered.vcf\n</code></pre>"},{"location":"VCFX_diff_tool/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Multi-allelic variants: Alternate alleles are sorted alphabetically to ensure consistent comparison even if the order differs between files (e.g., \"A,G\" and \"G,A\" are treated as identical)</li> <li>Header differences: Header lines (starting with #) are ignored, so differences in metadata don't affect the comparison</li> <li>Malformed VCF lines: Invalid lines are skipped with a warning</li> <li>Empty files: Properly handled; will show all variants from the non-empty file as unique</li> <li>Missing files: Reports an error if either file cannot be opened</li> <li>Large files: Efficiently processes files with thousands of variants using hash-based comparison</li> </ul>"},{"location":"VCFX_diff_tool/#performance","title":"Performance","text":"<p>The tool is optimized for efficiency: - Uses hash sets for O(1) lookups when comparing variants - Single-pass processing of each input file - Memory usage scales with the number of unique variants in both files - Can handle large VCF files with minimal overhead</p>"},{"location":"VCFX_diff_tool/#limitations","title":"Limitations","text":"<ul> <li>Compares only chromosome, position, reference, and alternate alleles; ignores other fields like quality, filter, and INFO</li> <li>Cannot detect differences in sample genotypes</li> <li>No support for partial matches or fuzzy comparisons (e.g., variants that differ only in quality)</li> <li>Not designed to handle VCF files with extremely large numbers of variants (hundreds of millions)</li> <li>Doesn't consider changes in INFO or FORMAT fields as differences</li> <li>Cannot compare complex structural variants represented in different ways </li> </ul>"},{"location":"VCFX_distance_calculator/","title":"VCFX_distance_calculator","text":""},{"location":"VCFX_distance_calculator/#overview","title":"Overview","text":"<p>VCFX_distance_calculator analyzes a VCF file and calculates the distance (in base pairs) between consecutive variants along each chromosome, providing insights into variant density and spacing across the genome.</p>"},{"location":"VCFX_distance_calculator/#usage","title":"Usage","text":"<pre><code>VCFX_distance_calculator [OPTIONS] &lt; input.vcf &gt; variant_distances.tsv\n</code></pre>"},{"location":"VCFX_distance_calculator/#options","title":"Options","text":"Option Description <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_distance_calculator/#description","title":"Description","text":"<p>VCFX_distance_calculator processes a VCF file to measure the distance between variants on the same chromosome. The tool:</p> <ol> <li>Reads a VCF file line-by-line</li> <li>Extracts chromosome (CHROM) and position (POS) information from each valid variant</li> <li>For each chromosome, tracks the position of the previous variant</li> <li>Calculates the distance from the previous variant to the current one</li> <li>Outputs a tab-delimited file with the results</li> <li>Provides summary statistics to stderr, including minimum, maximum, and average distances per chromosome</li> </ol> <p>This tool is useful for: - Analyzing variant density across the genome - Identifying regions with unusually sparse or dense variant coverage - Quality control to detect potential issues with variant calling - Understanding the distribution of variants in targeted sequencing</p>"},{"location":"VCFX_distance_calculator/#output-format","title":"Output Format","text":"<p>The output is a tab-delimited text file with the following columns:</p> <pre><code>CHROM  POS  PREV_POS  DISTANCE\n</code></pre> <p>Where: - CHROM: The chromosome name - POS: The position of the current variant - PREV_POS: The position of the previous variant on the same chromosome (or \"NA\" for the first variant) - DISTANCE: The distance in base pairs between current and previous positions (or \"NA\" for the first variant)</p>"},{"location":"VCFX_distance_calculator/#examples","title":"Examples","text":""},{"location":"VCFX_distance_calculator/#basic-usage","title":"Basic Usage","text":"<pre><code>./VCFX_distance_calculator &lt; input.vcf &gt; variant_distances.tsv\n</code></pre>"},{"location":"VCFX_distance_calculator/#analyzing-specific-chromosomes","title":"Analyzing Specific Chromosomes","text":"<pre><code># Extract only chromosome 1 data\ngrep -P \"^chr1\\t|^CHROM\" variant_distances.tsv &gt; chr1_distances.tsv\n</code></pre>"},{"location":"VCFX_distance_calculator/#identifying-large-gaps","title":"Identifying Large Gaps","text":"<pre><code># Find regions with large gaps (&gt;100,000 bp)\n./VCFX_distance_calculator &lt; input.vcf | awk -F'\\t' '$4 &gt; 100000 {print}' &gt; large_gaps.tsv\n</code></pre>"},{"location":"VCFX_distance_calculator/#visualizing-distance-distribution","title":"Visualizing Distance Distribution","text":"<pre><code># Process output for visualization (e.g., with R or Python)\n./VCFX_distance_calculator &lt; input.vcf | \\\n  grep -v \"NA\" | cut -f1,4 &gt; distances_for_plotting.tsv\n</code></pre>"},{"location":"VCFX_distance_calculator/#summary-statistics","title":"Summary Statistics","text":"<p>In addition to the main output file, VCFX_distance_calculator prints summary statistics to stderr:</p> <pre><code>=== Summary Statistics ===\nChromosome: chr1\n  Variants compared: 501\n  Distances computed: 500\n  Total distance: 10000000\n  Min distance: 1\n  Max distance: 150000\n  Average distance: 20000\n</code></pre> <p>This provides a quick overview of variant distribution patterns for each chromosome.</p>"},{"location":"VCFX_distance_calculator/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>First variant on a chromosome: Marked with \"NA\" for PREV_POS and DISTANCE</li> <li>Unsorted VCF files: Processes variants in the order they appear, which may result in negative distances</li> <li>Duplicate positions: Correctly calculates a distance of 0 between variants at the same position</li> <li>Malformed lines: Warns about and skips lines that don't follow VCF format</li> <li>Missing header: Requires a proper VCF header (#CHROM line) before processing variant records</li> <li>Invalid chromosome names: Skips variants with obviously invalid chromosome names</li> <li>Non-numeric positions: Skips variants where the position cannot be parsed as an integer</li> </ul>"},{"location":"VCFX_distance_calculator/#performance","title":"Performance","text":"<p>The tool is optimized for efficiency: - Processes VCF files line-by-line with minimal memory overhead - Uses hash maps for O(1) lookups of previous positions - Can handle very large VCF files (tested with millions of variants) - Memory usage scales with the number of distinct chromosomes, not with file size</p>"},{"location":"VCFX_distance_calculator/#limitations","title":"Limitations","text":"<ul> <li>Does not account for chromosome lengths (cannot detect missing regions)</li> <li>Does not distinguish between different types of variants</li> <li>Assumes variants are properly formatted according to VCF specifications</li> <li>No built-in filtering for quality or other variant attributes</li> <li>Distances are calculated based on the reference genome coordinates, not actual sequence lengths</li> <li>Does not handle structural variants in any special way (uses only the position field) </li> </ul>"},{"location":"VCFX_dosage_calculator/","title":"VCFX_dosage_calculator","text":""},{"location":"VCFX_dosage_calculator/#overview","title":"Overview","text":"<p>VCFX_dosage_calculator computes the genetic dosage (count of alternate alleles) for each sample at each variant position in a VCF file, outputting a tab-delimited summary in a convenient format for downstream analysis.</p>"},{"location":"VCFX_dosage_calculator/#usage","title":"Usage","text":"<pre><code>VCFX_dosage_calculator [OPTIONS] &lt; input.vcf &gt; dosage_output.txt\n</code></pre>"},{"location":"VCFX_dosage_calculator/#options","title":"Options","text":"Option Description <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_dosage_calculator/#description","title":"Description","text":"<p>VCFX_dosage_calculator reads a VCF file from standard input and calculates the genetic dosage for each sample at each variant position. Dosage is defined as the number of alternate alleles in a genotype, regardless of the specific alternate allele identifier.</p> <p>The dosage calculation follows these rules: - Reference allele (0): Counts as 0 - Any alternate allele (1, 2, 3, etc.): Counts as 1 - Missing or invalid alleles: Reported as \"NA\"</p> <p>For diploid genotypes, this results in: - 0/0 \u2192 dosage 0 (no alternate alleles) - 0/1 \u2192 dosage 1 (one alternate allele) - 1/1 \u2192 dosage 2 (two alternate alleles) - 1/2 \u2192 dosage 2 (two alternate alleles, even though they're different alternates) - ./. \u2192 dosage NA (missing genotype)</p> <p>The tool is useful for: - Preparing genetic data for association tests - Quantifying genetic burden - Converting genotypes to a simple numeric format for statistical analyses - Creating matrix-like representations of genetic data</p>"},{"location":"VCFX_dosage_calculator/#output-format","title":"Output Format","text":"<p>The output is a tab-delimited text file with the following columns:</p> <pre><code>CHROM  POS  ID  REF  ALT  Dosages\n</code></pre> <p>Where <code>Dosages</code> is a comma-separated list of dosage values for each sample, in the same order as they appear in the VCF. Values can be 0, 1, 2 (for diploid organisms), or NA for missing/invalid data.</p>"},{"location":"VCFX_dosage_calculator/#examples","title":"Examples","text":""},{"location":"VCFX_dosage_calculator/#basic-usage","title":"Basic Usage","text":"<pre><code>./VCFX_dosage_calculator &lt; input.vcf &gt; dosage_results.txt\n</code></pre>"},{"location":"VCFX_dosage_calculator/#viewing-results","title":"Viewing Results","text":"<pre><code># Show the first few lines of results with column headers\nhead -n 5 dosage_results.txt | column -t\n</code></pre>"},{"location":"VCFX_dosage_calculator/#integration-with-other-tools","title":"Integration with Other Tools","text":"<pre><code># Calculate dosage and use for statistical analysis\n./VCFX_dosage_calculator &lt; input.vcf | \\\n  awk -F'\\t' '{split($6,d,\",\"); sum=0; count=0; for(i in d) if(d[i]!=\"NA\") {sum+=d[i]; count++} if(count&gt;0) print $1,$2,$3,sum/count}' &gt; avg_dosage.txt\n</code></pre>"},{"location":"VCFX_dosage_calculator/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Phased genotypes: Phasing information is ignored; \"0|1\" and \"0/1\" both result in dosage 1</li> <li>Missing genotypes: Genotypes represented as \"./.\", \".|.\", or \".\" are reported as NA</li> <li>Multi-allelic variants: All non-reference alleles count equally:</li> <li>1/2 \u2192 dosage 2 </li> <li>0/3 \u2192 dosage 1</li> <li>2/3 \u2192 dosage 2</li> <li>Malformed genotypes: Any genotype that doesn't follow the expected format (e.g., \"0/X\", \"ABC\") is reported as NA</li> <li>Non-diploid organisms: The tool assumes diploid genotypes; other ploidy levels may produce unexpected results</li> <li>No GT field: If the FORMAT column doesn't include GT, a warning is issued and NA is reported for all samples</li> <li>Missing header: If the #CHROM header line isn't found, processing stops with an error</li> </ul>"},{"location":"VCFX_dosage_calculator/#performance","title":"Performance","text":"<p>The tool processes VCF files line by line with minimal memory requirements. Performance is primarily dependent on the number of samples in the VCF file, as each sample's genotype must be processed for every variant.</p>"},{"location":"VCFX_dosage_calculator/#limitations","title":"Limitations","text":"<ul> <li>Designed primarily for diploid organisms; may not be suitable for polyploid data</li> <li>Cannot handle probabilities or fractional dosages (e.g., from imputed data)</li> <li>Treats all alternate alleles equally; cannot distinguish between different alternate alleles</li> <li>No special handling for sex chromosomes (X, Y) which may have different ploidy in males and females</li> <li>No filtering options within the tool (use other VCFX tools for pre-filtering) </li> </ul>"},{"location":"VCFX_duplicate_remover/","title":"VCFX_duplicate_remover","text":""},{"location":"VCFX_duplicate_remover/#overview","title":"Overview","text":"<p>VCFX_duplicate_remover identifies and removes duplicate variant records from a VCF file based on their essential coordinates (chromosome, position, reference allele, and alternate allele), ensuring that each unique variant is represented only once in the output.</p>"},{"location":"VCFX_duplicate_remover/#usage","title":"Usage","text":"<pre><code>VCFX_duplicate_remover [OPTIONS] &lt; input.vcf &gt; deduplicated.vcf\n</code></pre>"},{"location":"VCFX_duplicate_remover/#options","title":"Options","text":"Option Description <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_duplicate_remover/#description","title":"Description","text":"<p>VCFX_duplicate_remover processes a VCF file to detect and remove duplicate variant records. The tool:</p> <ol> <li>Reads a VCF file from standard input line by line</li> <li>Passes header lines (beginning with '#') through unchanged</li> <li>For each data line, creates a normalized variant key consisting of:</li> <li>Chromosome name (CHROM)</li> <li>Position (POS)</li> <li>Reference allele (REF)</li> <li>Normalized alternate alleles (ALT)</li> <li>Normalizes multi-allelic variants by sorting the comma-separated ALT alleles alphabetically</li> <li>Tracks seen variants using a hash-based data structure</li> <li>Outputs only the first occurrence of each unique variant, discarding subsequent duplicates</li> <li>Writes the deduplicated VCF to standard output</li> </ol> <p>This tool is particularly useful for: - Merging VCF files that may contain overlapping variants - Cleaning up datasets that have inadvertently duplicated records - Ensuring downstream analysis tools don't process the same variant multiple times</p>"},{"location":"VCFX_duplicate_remover/#output-format","title":"Output Format","text":"<p>The output is a valid VCF file with the same format as the input, but with duplicate variant records removed. The first occurrence of each unique variant is preserved, maintaining all original fields (ID, QUAL, FILTER, INFO, FORMAT, samples).</p>"},{"location":"VCFX_duplicate_remover/#examples","title":"Examples","text":""},{"location":"VCFX_duplicate_remover/#basic-usage","title":"Basic Usage","text":"<pre><code># Remove duplicate variants from a VCF file\n./VCFX_duplicate_remover &lt; input.vcf &gt; deduplicated.vcf\n</code></pre>"},{"location":"VCFX_duplicate_remover/#in-a-pipeline","title":"In a Pipeline","text":"<pre><code># Filter a VCF file and then remove duplicates\n./VCFX_record_filter --quality \"&gt;20\" &lt; input.vcf | \\\n./VCFX_duplicate_remover &gt; filtered_unique.vcf\n</code></pre>"},{"location":"VCFX_duplicate_remover/#checking-results","title":"Checking Results","text":"<pre><code># Count variants before and after deduplication\necho \"Before: $(grep -v '^#' input.vcf | wc -l) variants\"\necho \"After: $(grep -v '^#' deduplicated.vcf | wc -l) variants\"\n</code></pre>"},{"location":"VCFX_duplicate_remover/#duplicate-detection","title":"Duplicate Detection","text":"<p>The tool determines uniqueness based on four key attributes:</p> <ol> <li>Chromosome (CHROM): Exact string match of chromosome name</li> <li>Position (POS): Numerical position on the chromosome</li> <li>Reference Allele (REF): The reference sequence at that position</li> <li>Alternate Alleles (ALT): The alternate alleles, normalized by sorting</li> </ol> <p>For multi-allelic variants, the ALT field is normalized by: - Splitting the comma-separated list of alternate alleles - Sorting the alleles alphabetically - Re-joining them with commas</p> <p>This normalization ensures that variants with the same alleles but in different order are correctly identified as duplicates. For example, \"A,G,T\" and \"T,A,G\" are treated as the same variant after normalization.</p>"},{"location":"VCFX_duplicate_remover/#handling-special-cases","title":"Handling Special Cases","text":"<p>The tool implements several strategies for handling edge cases:</p> <ol> <li>Multi-allelic variants: Normalizes ALT fields by sorting to handle different orderings</li> <li>Empty lines: Skipped without affecting output</li> <li>Malformed lines: Lines that can't be parsed are skipped with a warning</li> <li>Position parsing errors: If a POS field can't be parsed as an integer, it's set to 0</li> <li>Header lines: All header lines are preserved in the output</li> <li>Empty files: Properly handles empty input files, producing empty output</li> <li>Files with only headers: Header lines are passed through correctly</li> <li>Sample columns: Maintains all sample genotype data in the output</li> </ol>"},{"location":"VCFX_duplicate_remover/#performance","title":"Performance","text":"<p>VCFX_duplicate_remover is designed for efficiency:</p> <ol> <li>Single-pass processing with O(n) time complexity where n is the number of variants</li> <li>Uses an optimized hash-based data structure for fast variant lookups</li> <li>Minimal memory overhead, proportional to the number of unique variants</li> <li>Handles large VCF files with millions of variants efficiently</li> <li>String processing optimized for performance with minimal copying</li> </ol>"},{"location":"VCFX_duplicate_remover/#limitations","title":"Limitations","text":"<ol> <li>Retains the first occurrence of duplicate variants; quality or information in subsequent duplicates is discarded</li> <li>No option to select which duplicate to keep (e.g., the one with highest quality)</li> <li>No facility to annotate output variants with duplicate counts</li> <li>Limited to exact matching; doesn't detect overlapping variants that might represent the same event</li> <li>Doesn't consider INFO fields in uniqueness determination</li> <li>Cannot handle duplicates based on sample-specific criteria</li> <li>No option to only report duplicate variants without removing them </li> </ol>"},{"location":"VCFX_fasta_converter/","title":"VCFX_fasta_converter","text":""},{"location":"VCFX_fasta_converter/#overview","title":"Overview","text":"<p>VCFX_fasta_converter transforms VCF files into FASTA format, converting variant information into a multiple sequence alignment where each sample's sequence represents its genotypes across all variants.</p>"},{"location":"VCFX_fasta_converter/#usage","title":"Usage","text":"<pre><code>VCFX_fasta_converter [OPTIONS] &lt; input.vcf &gt; output.fasta\n</code></pre>"},{"location":"VCFX_fasta_converter/#options","title":"Options","text":"Option Description <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_fasta_converter/#description","title":"Description","text":"<p>VCFX_fasta_converter converts variant information from VCF format into a multiple sequence alignment in FASTA format. The tool:</p> <ol> <li>Reads a VCF file with variant data and sample genotypes</li> <li>Creates one FASTA entry for each sample in the VCF</li> <li>Generates one position in the alignment for each variant in the VCF</li> <li>Represents each genotype as a single character:</li> <li>Homozygous genotypes (0/0, 1/1, etc.) are represented by the corresponding base</li> <li>Heterozygous genotypes (0/1, 1/2, etc.) are represented by IUPAC ambiguity codes when possible</li> <li>Complex genotypes (indels, multi-base variants) are represented as 'N'</li> <li>Outputs a FASTA file with one sequence per sample, where each position corresponds to a variant in the VCF</li> </ol> <p>This tool is useful for: - Creating alignments for phylogenetic analysis - Visualizing genetic variation across samples - Converting VCF data for use with tools that require FASTA format - Simplifying the representation of genetic variation</p>"},{"location":"VCFX_fasta_converter/#output-format","title":"Output Format","text":"<p>The output is a standard FASTA file with one entry per sample:</p> <pre><code>&gt;SAMPLE1\nAGCTYRMKSW\n&gt;SAMPLE2\nATCGYRMNNA\n&gt;SAMPLE3\nGACTYRSWNN\n</code></pre> <p>Each position in the sequence corresponds to a variant in the input VCF, with genotypes encoded as follows: - Homozygous reference (0/0): The reference base (e.g., 'A') - Homozygous alternate (1/1): The alternate base (e.g., 'G') - Heterozygous (0/1): IUPAC ambiguity code (e.g., 'R' for A/G) - Missing genotypes (./.): 'N' - Complex or unrepresentable genotypes: 'N'</p>"},{"location":"VCFX_fasta_converter/#examples","title":"Examples","text":""},{"location":"VCFX_fasta_converter/#basic-usage","title":"Basic Usage","text":"<pre><code>./VCFX_fasta_converter &lt; variants.vcf &gt; alignment.fasta\n</code></pre>"},{"location":"VCFX_fasta_converter/#viewing-the-alignment","title":"Viewing the Alignment","text":"<pre><code># Convert to FASTA and view with alignment viewer\n./VCFX_fasta_converter &lt; variants.vcf &gt; alignment.fasta\naliview alignment.fasta\n</code></pre>"},{"location":"VCFX_fasta_converter/#building-a-phylogenetic-tree","title":"Building a Phylogenetic Tree","text":"<pre><code># Create a FASTA alignment from VCF and build a tree\n./VCFX_fasta_converter &lt; variants.vcf &gt; alignment.fasta\niqtree -s alignment.fasta\n</code></pre>"},{"location":"VCFX_fasta_converter/#iupac-ambiguity-codes","title":"IUPAC Ambiguity Codes","text":"<p>The tool uses standard IUPAC nucleotide ambiguity codes to represent heterozygous genotypes:</p> Code Bases Meaning R A/G puRine Y C/T pYrimidine M A/C aMino K G/T Keto S C/G Strong (3 H-bonds) W A/T Weak (2 H-bonds) N Any aNy base or missing data"},{"location":"VCFX_fasta_converter/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Indels and multi-base variants: Represented as 'N' since they can't be unambiguously encoded as a single nucleotide</li> <li>Multi-allelic sites: Processed using the appropriate IUPAC codes when possible</li> <li>Phased vs. unphased genotypes: Treated identically (e.g., \"0|1\" and \"0/1\" both map to the same IUPAC code)</li> <li>Missing genotypes: Represented as 'N' in the output sequence</li> <li>Missing GT field: Variants without a genotype field are skipped</li> <li>Malformed VCF lines: Skipped with a warning</li> <li>Invalid nucleotide combinations: Represented as 'N' when no IUPAC code exists</li> </ul>"},{"location":"VCFX_fasta_converter/#performance","title":"Performance","text":"<p>The converter is optimized for efficiency: - Single-pass processing of the VCF file - Efficient string handling for sequence construction - Scales linearly with the number of variants and samples - Maintains a small memory footprint proportional to the number of samples</p>"},{"location":"VCFX_fasta_converter/#limitations","title":"Limitations","text":"<ul> <li>Cannot represent structural variants, indels, or multi-base substitutions</li> <li>Loss of information (quality scores, filters, etc.) from the original VCF</li> <li>No support for non-diploid genotypes</li> <li>Limited to the standard IUPAC ambiguity codes for representing heterozygosity</li> <li>Not suitable for variants with complex ALT alleles</li> <li>No option to include position information in the output</li> <li>Cannot handle extremely large VCF files due to memory constraints (sequence storage) </li> </ul>"},{"location":"VCFX_field_extractor/","title":"VCFX_field_extractor","text":""},{"location":"VCFX_field_extractor/#overview","title":"Overview","text":"<p><code>VCFX_field_extractor</code> is a tool designed to extract and format specific fields from VCF (Variant Call Format) files. It allows users to select and output particular fields from VCF records, including standard fields, INFO subfields, and sample-specific genotype fields in a tabular format.</p>"},{"location":"VCFX_field_extractor/#usage","title":"Usage","text":"<pre><code>VCFX_field_extractor --fields \"FIELD1,FIELD2,...\" [OPTIONS] &lt; input.vcf &gt; output.tsv\n</code></pre>"},{"location":"VCFX_field_extractor/#options","title":"Options","text":"Option Description <code>-f</code>, <code>--fields</code> Required. Comma-separated list of fields to extract (no spaces between fields) <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_field_extractor/#description","title":"Description","text":"<p><code>VCFX_field_extractor</code> processes a VCF file and extracts only the specified fields for each variant. The tool:</p> <ol> <li>Reads a VCF file from standard input</li> <li>Identifies and parses the VCF header</li> <li>For each variant line, extracts the requested fields</li> <li>Outputs the extracted fields in a tab-separated format</li> </ol> <p>The tool can extract three types of fields: - Standard VCF fields: <code>CHROM</code>, <code>POS</code>, <code>ID</code>, <code>REF</code>, <code>ALT</code>, <code>QUAL</code>, <code>FILTER</code>, <code>INFO</code> - INFO subfields: Any key that appears in the INFO column (e.g., <code>DP</code>, <code>AF</code>, <code>TYPE</code>) - Sample-specific fields: Fields from the genotype columns, specified as either:   - <code>SampleName:Subfield</code> (e.g., <code>SAMPLE1:GT</code> for the genotype of SAMPLE1)   - <code>S&lt;number&gt;:Subfield</code> (e.g., <code>S1:DP</code> for the depth of the first sample)</p>"},{"location":"VCFX_field_extractor/#field-types","title":"Field Types","text":""},{"location":"VCFX_field_extractor/#standard-vcf-fields","title":"Standard VCF Fields","text":"<p>These are the eight fixed columns in the VCF format: - <code>CHROM</code>: Chromosome - <code>POS</code>: Position - <code>ID</code>: Variant identifier - <code>REF</code>: Reference allele - <code>ALT</code>: Alternate allele(s) - <code>QUAL</code>: Quality score - <code>FILTER</code>: Filter status - <code>INFO</code>: Additional information</p>"},{"location":"VCFX_field_extractor/#info-subfields","title":"INFO Subfields","text":"<p>Any key found in the INFO column can be extracted directly by name. For example: - <code>DP</code>: Read depth - <code>AF</code>: Allele frequency - <code>TYPE</code>: Variant type</p>"},{"location":"VCFX_field_extractor/#sample-fields","title":"Sample Fields","text":"<p>Sample fields are specified using one of these formats: - <code>SampleName:Subfield</code> where <code>SampleName</code> is the exact sample name from the VCF header - <code>S&lt;number&gt;:Subfield</code> where <code>&lt;number&gt;</code> is the 1-based index of the sample column</p> <p>Common sample subfields include: - <code>GT</code>: Genotype - <code>DP</code>: Read depth - <code>GQ</code>: Genotype quality - Other format fields defined in the VCF</p>"},{"location":"VCFX_field_extractor/#output-format","title":"Output Format","text":"<p>The tool produces a tab-separated values (TSV) file with: - A header row containing the requested field names - One row per variant, with each requested field value - Missing or invalid fields represented as <code>.</code></p>"},{"location":"VCFX_field_extractor/#examples","title":"Examples","text":""},{"location":"VCFX_field_extractor/#basic-standard-fields","title":"Basic Standard Fields","text":"<p>Extract chromosome, position, ID, reference, and alternate alleles: <pre><code>VCFX_field_extractor --fields \"CHROM,POS,ID,REF,ALT\" &lt; input.vcf &gt; basic_fields.tsv\n</code></pre></p>"},{"location":"VCFX_field_extractor/#info-fields","title":"INFO Fields","text":"<p>Extract depth and allele frequency: <pre><code>VCFX_field_extractor --fields \"CHROM,POS,DP,AF\" &lt; input.vcf &gt; info_fields.tsv\n</code></pre></p>"},{"location":"VCFX_field_extractor/#sample-genotype-fields","title":"Sample Genotype Fields","text":"<p>Extract genotypes for specific samples: <pre><code>VCFX_field_extractor --fields \"CHROM,POS,SAMPLE1:GT,SAMPLE2:GT\" &lt; input.vcf &gt; genotypes.tsv\n</code></pre></p>"},{"location":"VCFX_field_extractor/#sample-fields-by-index","title":"Sample Fields by Index","text":"<p>Extract genotypes using sample indices: <pre><code>VCFX_field_extractor --fields \"CHROM,POS,S1:GT,S2:GT\" &lt; input.vcf &gt; genotypes_by_index.tsv\n</code></pre></p>"},{"location":"VCFX_field_extractor/#mixed-field-types","title":"Mixed Field Types","text":"<p>Combine different field types: <pre><code>VCFX_field_extractor --fields \"CHROM,POS,DP,AF,SAMPLE1:GT,SAMPLE1:DP\" &lt; input.vcf &gt; mixed_fields.tsv\n</code></pre></p>"},{"location":"VCFX_field_extractor/#handling-special-cases","title":"Handling Special Cases","text":""},{"location":"VCFX_field_extractor/#missing-fields","title":"Missing Fields","text":"<ul> <li>If a requested field is not found in the VCF record, a <code>.</code> is output</li> <li>This applies to missing INFO fields, invalid sample names, or non-existent format fields</li> </ul>"},{"location":"VCFX_field_extractor/#malformed-records","title":"Malformed Records","text":"<ul> <li>The tool attempts to handle malformed VCF lines gracefully</li> <li>For lines with too few columns, missing fields are filled with <code>.</code></li> <li>Invalid data types in numeric fields are preserved as they appear in the input</li> </ul>"},{"location":"VCFX_field_extractor/#header-only-files","title":"Header-only Files","text":"<ul> <li>If a VCF file contains only headers and no variant records, the tool outputs just the header row</li> </ul>"},{"location":"VCFX_field_extractor/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>The tool processes VCF files line-by-line, with minimal memory overhead</li> <li>Extraction scales linearly with input size and number of requested fields</li> <li>For large VCF files, consider extracting only the necessary fields to improve performance</li> </ul>"},{"location":"VCFX_field_extractor/#limitations","title":"Limitations","text":"<ul> <li>Cannot filter records (only extracts fields from all records)</li> <li>Cannot perform operations or calculations on the extracted fields</li> <li>Does not support complex expressions or conditionals</li> <li>Limited to tab-separated output format</li> <li>Cannot output field descriptions or metadata from the VCF header</li> <li>No direct support for multi-allelic splitting or normalization </li> </ul>"},{"location":"VCFX_file_splitter/","title":"VCFX_file_splitter","text":""},{"location":"VCFX_file_splitter/#overview","title":"Overview","text":"<p>VCFX_file_splitter divides a VCF file into multiple smaller files based on chromosome, creating separate output files for each chromosome present in the input.</p>"},{"location":"VCFX_file_splitter/#usage","title":"Usage","text":"<pre><code>VCFX_file_splitter [OPTIONS] &lt; input.vcf\n</code></pre>"},{"location":"VCFX_file_splitter/#options","title":"Options","text":"Option Description <code>-p</code>, <code>--prefix &lt;PREFIX&gt;</code> Output file prefix (default: \"split\") <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_file_splitter/#description","title":"Description","text":"<p>VCFX_file_splitter reads a VCF file and separates its contents into multiple files, with one file per chromosome. The tool:</p> <ol> <li>Reads a VCF file from standard input</li> <li>Extracts the chromosome (CHROM) information from each variant line</li> <li>Creates a separate output file for each unique chromosome encountered</li> <li>Writes all header lines to each output file</li> <li>Distributes variant records to the appropriate chromosome file</li> <li>Produces output files named using the pattern <code>&lt;PREFIX&gt;_&lt;CHROM&gt;.vcf</code></li> </ol> <p>This tool is useful for: - Parallelizing variant processing by chromosome - Reducing memory requirements when handling large VCF files - Organizing variant data by chromosome for downstream analysis - Creating chromosome-specific VCF files for targeted analysis - Preparing data for tools that work on individual chromosomes</p>"},{"location":"VCFX_file_splitter/#output-format","title":"Output Format","text":"<p>The output consists of multiple VCF files, one for each chromosome in the input. Each file contains: - All original header lines from the input VCF - Only the variant records for the corresponding chromosome - The same format and structure as the original VCF</p> <p>Output files are named following the pattern: <pre><code>&lt;PREFIX&gt;_&lt;CHROM&gt;.vcf\n</code></pre></p> <p>For example, using the default prefix \"split\", the tool will generate files like: - <code>split_1.vcf</code> (chromosome 1) - <code>split_2.vcf</code> (chromosome 2) - <code>split_X.vcf</code> (chromosome X) - etc.</p>"},{"location":"VCFX_file_splitter/#examples","title":"Examples","text":""},{"location":"VCFX_file_splitter/#basic-usage","title":"Basic Usage","text":"<pre><code>./VCFX_file_splitter &lt; input.vcf\n</code></pre> <p>This will create files like <code>split_1.vcf</code>, <code>split_2.vcf</code>, etc.</p>"},{"location":"VCFX_file_splitter/#custom-prefix","title":"Custom Prefix","text":"<pre><code>./VCFX_file_splitter --prefix \"chr\" &lt; input.vcf\n</code></pre> <p>This will create files like <code>chr_1.vcf</code>, <code>chr_2.vcf</code>, etc.</p>"},{"location":"VCFX_file_splitter/#processing-multiple-files","title":"Processing Multiple Files","text":"<pre><code># Split multiple VCF files\nfor file in *.vcf; do\n  output_prefix=\"${file%.vcf}\"\n  ./VCFX_file_splitter --prefix \"$output_prefix\" &lt; \"$file\"\ndone\n</code></pre>"},{"location":"VCFX_file_splitter/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Header Lines: All header lines (starting with #) are included in each output file</li> <li>Additional Headers: If header lines appear after data lines in the input, they are replicated to all open chromosome files</li> <li>Empty Input: If the input file is empty or contains only headers, a warning message is displayed</li> <li>Chromosome Naming: Preserves chromosome names exactly as they appear in the input file, including any prefixes or special characters</li> <li>Malformed Lines: Lines that can't be parsed for chromosome information are skipped with a warning</li> <li>File Creation Failures: Reports an error if an output file cannot be created (due to permissions, disk space, etc.)</li> <li>Large Numbers of Chromosomes: Can handle arbitrarily many chromosomes, creating one file for each</li> </ul>"},{"location":"VCFX_file_splitter/#performance","title":"Performance","text":"<p>The splitter is optimized for efficiency: - Single-pass processing of the input file - Streams data directly to output files without storing records in memory - Uses smart pointers for automatic resource management - Efficiently handles very large VCF files with minimal memory overhead - Output files are written incrementally as the input is processed</p>"},{"location":"VCFX_file_splitter/#limitations","title":"Limitations","text":"<ul> <li>Requires sufficient disk space to store all output files</li> <li>No built-in compression of output files</li> <li>Cannot split by other criteria (e.g., position ranges, sample names)</li> <li>Does not check for duplicate variant entries in the input</li> <li>No option to merge small chromosomes into a single output file</li> <li>Cannot control the order of variants within output files (maintains the order from the input)</li> <li>Files with many chromosomes will generate many output files </li> </ul>"},{"location":"VCFX_format_converter/","title":"VCFX_format_converter","text":""},{"location":"VCFX_format_converter/#overview","title":"Overview","text":"<p><code>VCFX_format_converter</code> is a tool for converting VCF (Variant Call Format) files to other common file formats. It currently supports conversion to BED (Browser Extensible Data) and CSV (Comma-Separated Values) formats.</p>"},{"location":"VCFX_format_converter/#usage","title":"Usage","text":"<pre><code>VCFX_format_converter [OPTIONS] &lt; input.vcf &gt; output.file\n</code></pre>"},{"location":"VCFX_format_converter/#options","title":"Options","text":"Option Description <code>--to-bed</code> Convert the input VCF file to BED format <code>--to-csv</code> Convert the input VCF file to CSV format <code>--help</code>, <code>-h</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_format_converter/#description","title":"Description","text":"<p><code>VCFX_format_converter</code> reads a VCF file from standard input and converts it to the specified output format. The tool:</p> <ol> <li>Parses command-line arguments to determine the desired output format</li> <li>Reads the VCF file line by line</li> <li>Skips header lines (starting with #) in the output</li> <li>Converts each variant record according to the selected format</li> <li>Writes the converted data to standard output</li> </ol>"},{"location":"VCFX_format_converter/#conversion-details","title":"Conversion Details","text":""},{"location":"VCFX_format_converter/#vcf-to-bed-conversion","title":"VCF to BED Conversion","text":"<p>BED format requires at least 3 columns: 1. <code>chrom</code> - The chromosome name 2. <code>start</code> - 0-based start position (VCF positions are 1-based) 3. <code>end</code> - 0-based end position (exclusive)</p> <p>The converter implements the following mapping: - <code>chrom</code>: Direct copy from VCF's CHROM column - <code>start</code>: VCF POS - 1 (clamped to \u2265 0) - <code>end</code>: start + length of REF allele - <code>name</code>: Direct copy from VCF's ID column</p> <p>For example, a VCF record <code>chr1 10000 rs123 A G ...</code> becomes a BED record <code>chr1 9999 10000 rs123</code>.</p>"},{"location":"VCFX_format_converter/#vcf-to-csv-conversion","title":"VCF to CSV Conversion","text":"<p>The CSV conversion preserves all columns from the VCF file but changes the delimiter from tabs to commas. The tool:</p> <ol> <li>Includes a header row from the #CHROM line (after removing the # character)</li> <li>Properly escapes fields containing commas or quotes according to CSV standards:</li> <li>Fields containing commas or quotes are enclosed in double quotes</li> <li>Double quotes within fields are doubled (e.g., <code>\"</code> becomes <code>\"\"</code>)</li> <li>Preserves all columns and their order from the original VCF</li> </ol>"},{"location":"VCFX_format_converter/#examples","title":"Examples","text":""},{"location":"VCFX_format_converter/#converting-to-bed-format","title":"Converting to BED Format","text":"<pre><code>VCFX_format_converter --to-bed &lt; input.vcf &gt; output.bed\n</code></pre> <p>This command converts each variant record in <code>input.vcf</code> to BED format, writing the results to <code>output.bed</code>.</p>"},{"location":"VCFX_format_converter/#converting-to-csv-format","title":"Converting to CSV Format","text":"<pre><code>VCFX_format_converter --to-csv &lt; input.vcf &gt; output.csv\n</code></pre> <p>This command converts the tab-delimited <code>input.vcf</code> to comma-separated format in <code>output.csv</code>, preserving all columns.</p>"},{"location":"VCFX_format_converter/#handling-special-cases","title":"Handling Special Cases","text":""},{"location":"VCFX_format_converter/#multi-allelic-variants","title":"Multi-allelic Variants","text":"<ul> <li>In BED format, multi-allelic variants are represented by a single interval based on the REF allele length</li> <li>In CSV format, multi-allelic variants are preserved as in the original VCF, with commas in the ALT field properly escaped</li> </ul>"},{"location":"VCFX_format_converter/#structural-variants","title":"Structural Variants","text":"<ul> <li>For BED conversion, the REF allele length is used to calculate the end position</li> <li>If a structural variant includes an END tag in the INFO field, this is not currently used for BED conversion</li> </ul>"},{"location":"VCFX_format_converter/#special-characters-in-csv","title":"Special Characters in CSV","text":"<p>Fields containing special characters are handled according to CSV standards: - Commas: Field is enclosed in double quotes - Double quotes: Field is enclosed in double quotes and internal quotes are doubled - Newlines: Preserved within quoted fields - Fields with ID values containing commas are properly quoted</p>"},{"location":"VCFX_format_converter/#malformed-vcf-files","title":"Malformed VCF Files","text":"<p>The tool attempts to handle malformed input gracefully: - Lines with too few columns are skipped - Invalid position values are skipped - Non-numeric QUAL values are preserved as-is in CSV output and handled appropriately for BED</p>"},{"location":"VCFX_format_converter/#empty-files-or-headers-only-files","title":"Empty Files or Headers-Only Files","text":"<ul> <li>For files containing only headers (no variant records), the tool produces:</li> <li>An empty file for BED output</li> <li>A header row only for CSV output</li> </ul>"},{"location":"VCFX_format_converter/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>The tool processes VCF files line by line, with minimal memory requirements</li> <li>Performance scales linearly with input file size</li> <li>No indexing is performed, allowing efficient streaming processing</li> </ul>"},{"location":"VCFX_format_converter/#limitations","title":"Limitations","text":"<ul> <li>The BED conversion uses a simple interval representation based on REF allele length</li> <li>Structural variants with END tags are not specially handled for BED intervals</li> <li>No specific handling for insertions (which technically have zero length in reference coordinates)</li> <li>Does not create or use specialized indices</li> <li>Does not support other output formats such as GFF, TXT, or JSON</li> <li>Cannot perform filtering operations during conversion </li> </ul>"},{"location":"VCFX_genotype_query/","title":"VCFX_genotype_query","text":""},{"location":"VCFX_genotype_query/#overview","title":"Overview","text":"<p>VCFX_genotype_query filters VCF files to keep only those variant lines where at least one sample has a specified genotype. It's a powerful tool for extracting variants with specific genotypic patterns.</p>"},{"location":"VCFX_genotype_query/#usage","title":"Usage","text":"<pre><code>VCFX_genotype_query [OPTIONS] &lt; input.vcf &gt; filtered.vcf\n</code></pre>"},{"location":"VCFX_genotype_query/#options","title":"Options","text":"Option Description <code>--genotype-query</code>, <code>-g</code> \"GENOTYPE\" Specify the genotype to query (e.g., \"0/1\", \"1/1\") <code>--strict</code> Use strict string comparison (no phasing unification or allele sorting) <code>--help</code>, <code>-h</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_genotype_query/#description","title":"Description","text":"<p>VCFX_genotype_query reads a VCF file from standard input and outputs variants (plus all header lines) where at least one sample has a genotype matching the specified pattern in the 'GT' field.</p> <p>By default, the tool uses flexible matching: - Unifies phasing separators ('|' and '/' are treated the same) - Sorts alleles numerically (e.g., \"1/0\" is treated the same as \"0/1\")</p> <p>When the <code>--strict</code> option is used, the tool performs exact string matching on genotypes, maintaining phase status and allele order.</p>"},{"location":"VCFX_genotype_query/#output-format","title":"Output Format","text":"<p>The output is a standard VCF file containing: - All header lines from the input file (unchanged) - Only variant lines where at least one sample matches the specified genotype pattern</p>"},{"location":"VCFX_genotype_query/#examples","title":"Examples","text":""},{"location":"VCFX_genotype_query/#basic-usage-flexible-matching","title":"Basic Usage (Flexible Matching)","text":"<pre><code># Find all variants where any sample is heterozygous (0/1)\n./VCFX_genotype_query --genotype-query \"0/1\" &lt; input.vcf &gt; heterozygous.vcf\n</code></pre>"},{"location":"VCFX_genotype_query/#strict-matching","title":"Strict Matching","text":"<pre><code># Find variants where any sample has a specifically phased heterozygous genotype (0|1)\n./VCFX_genotype_query --genotype-query \"0|1\" --strict &lt; input.vcf &gt; phased_heterozygous.vcf\n</code></pre>"},{"location":"VCFX_genotype_query/#finding-homozygous-variants","title":"Finding Homozygous Variants","text":"<pre><code># Find variants where any sample is homozygous for the alternate allele\n./VCFX_genotype_query --genotype-query \"1/1\" &lt; input.vcf &gt; homozygous_alt.vcf\n</code></pre>"},{"location":"VCFX_genotype_query/#finding-multi-allelic-genotypes","title":"Finding Multi-allelic Genotypes","text":"<pre><code># Find variants where any sample has specific multi-allelic genotype\n./VCFX_genotype_query --genotype-query \"1/2\" &lt; input.vcf &gt; multi_allelic.vcf\n</code></pre>"},{"location":"VCFX_genotype_query/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Phased genotypes: By default, \"0|1\" and \"0/1\" are considered equivalent; use <code>--strict</code> to differentiate them</li> <li>Multi-allelic variants: Can be queried with appropriate genotypes (e.g., \"1/2\", \"0/2\")</li> <li>Missing genotypes: Can match against \"././\" or \".\"</li> <li>Non-diploid genotypes: Supported in both flexible and strict modes</li> <li>Malformed VCF lines: Lines with fewer than 10 columns are skipped with a warning</li> <li>Missing GT field: Lines without a GT field in the FORMAT column are skipped</li> </ul>"},{"location":"VCFX_genotype_query/#performance","title":"Performance","text":"<p>The tool processes VCF files line by line with minimal memory requirements, making it efficient for large files. Performance scales linearly with the number of samples in the VCF file.</p>"},{"location":"VCFX_genotype_query/#limitations","title":"Limitations","text":"<ul> <li>Only filters based on the presence of the target genotype in at least one sample</li> <li>Cannot filter based on multiple genotype patterns in a single run</li> <li>No support for complex queries (e.g., specific samples with specific genotypes)</li> <li>Skips variants where the GT field is not present in the FORMAT column </li> </ul>"},{"location":"VCFX_gl_filter/","title":"VCFX_gl_filter","text":""},{"location":"VCFX_gl_filter/#overview","title":"Overview","text":"<p><code>VCFX_gl_filter</code> filters VCF records based on numeric genotype-likelihood fields in the FORMAT column, such as genotype quality (GQ), read depth (DP), or phred-scaled likelihoods (PL). This tool helps focus analysis on variants with sufficient genotype quality or other sample-level metrics.</p>"},{"location":"VCFX_gl_filter/#usage","title":"Usage","text":"<pre><code>VCFX_gl_filter --filter \"&lt;CONDITION&gt;\" [--mode &lt;any|all&gt;] &lt; input.vcf &gt; filtered.vcf\n</code></pre>"},{"location":"VCFX_gl_filter/#options","title":"Options","text":"Option Description <code>-f</code>, <code>--filter &lt;CONDITION&gt;</code> Required. Filter condition (e.g., <code>GQ&gt;20</code>, <code>DP&gt;=10</code>, <code>PL&lt;50</code>) <code>-m</code>, <code>--mode &lt;any\\|all&gt;</code> Optional. Determines if all samples must pass the condition (<code>all</code>, default) or at least one sample must pass (<code>any</code>) <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_gl_filter/#description","title":"Description","text":"<p><code>VCFX_gl_filter</code> examines numeric fields in the FORMAT column of a VCF file and filters variant records based on whether the samples satisfy the specified condition. The tool:</p> <ol> <li>Parses the filter condition into field name, operator, and threshold value</li> <li>Locates the specified field in the FORMAT column</li> <li>For each variant record, evaluates sample values against the condition</li> <li>Applies the filtering logic based on the specified mode:</li> <li>In <code>all</code> mode (default): keeps variants where ALL samples pass the condition</li> <li>In <code>any</code> mode: keeps variants where AT LEAST ONE sample passes the condition</li> <li>Outputs passing records to standard output</li> </ol> <p>This tool is particularly useful for: - Removing variants with low genotype quality - Filtering based on read depth or coverage - Filtering on phred-scaled likelihoods or other numeric likelihood measures - Applying consistent quality thresholds across samples</p>"},{"location":"VCFX_gl_filter/#output-format","title":"Output Format","text":"<p>The output is a standard VCF file containing: - All original header lines from the input VCF - Only those variant records where samples satisfy the specified condition according to the mode - No modification to the content or format of the retained lines</p>"},{"location":"VCFX_gl_filter/#examples","title":"Examples","text":""},{"location":"VCFX_gl_filter/#basic-usage-with-default-mode","title":"Basic Usage with Default Mode","text":"<p>Filter variants where all samples have genotype quality (GQ) above 20: <pre><code>VCFX_gl_filter --filter \"GQ&gt;20\" &lt; input.vcf &gt; high_quality.vcf\n</code></pre></p>"},{"location":"VCFX_gl_filter/#using-any-mode","title":"Using 'Any' Mode","text":"<p>Filter variants where at least one sample has read depth (DP) of 30 or higher: <pre><code>VCFX_gl_filter --filter \"DP&gt;=30\" --mode any &lt; input.vcf &gt; high_depth.vcf\n</code></pre></p>"},{"location":"VCFX_gl_filter/#exact-value-matching","title":"Exact Value Matching","text":"<p>Filter variants where all samples have an exact phred-scaled likelihood value: <pre><code>VCFX_gl_filter --filter \"PL==50\" &lt; input.vcf &gt; specific_pl.vcf\n</code></pre></p>"},{"location":"VCFX_gl_filter/#negative-filtering-with-not-equal","title":"Negative Filtering with Not Equal","text":"<p>Filter variants where all samples have a non-zero genotype quality: <pre><code>VCFX_gl_filter --filter \"GQ!=0\" &lt; input.vcf &gt; non_zero_gq.vcf\n</code></pre></p>"},{"location":"VCFX_gl_filter/#in-a-pipeline","title":"In a Pipeline","text":"<p>Use with other VCFX tools in a pipeline: <pre><code>cat input.vcf | VCFX_gl_filter --filter \"GQ&gt;30\" | VCFX_record_filter --filter \"QUAL&gt;40\" &gt; high_quality_variants.vcf\n</code></pre></p>"},{"location":"VCFX_gl_filter/#filter-condition-syntax","title":"Filter Condition Syntax","text":""},{"location":"VCFX_gl_filter/#format","title":"Format","text":"<p>The filter condition must follow this syntax: <pre><code>FIELD OPERATOR VALUE\n</code></pre> Where: - <code>FIELD</code>: Any numeric field from the FORMAT column (e.g., GQ, DP, PL) - <code>OPERATOR</code>: One of <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code> - <code>VALUE</code>: A numeric threshold (integer or decimal)</p> <p>Examples of valid conditions: - <code>GQ&gt;20</code>: Genotype quality greater than 20 - <code>DP&gt;=10.5</code>: Read depth greater than or equal to 10.5 - <code>PL&lt;30</code>: Phred-scaled likelihood less than 30 - <code>GL!=0</code>: Genotype likelihood not equal to 0</p>"},{"location":"VCFX_gl_filter/#comparison-operators","title":"Comparison Operators","text":"<p>The tool supports the following comparison operators: - <code>&gt;</code>: Greater than - <code>&lt;</code>: Less than - <code>&gt;=</code>: Greater than or equal to - <code>&lt;=</code>: Less than or equal to - <code>==</code>: Equal to - <code>!=</code>: Not equal to</p>"},{"location":"VCFX_gl_filter/#handling-special-cases","title":"Handling Special Cases","text":""},{"location":"VCFX_gl_filter/#missing-fields","title":"Missing Fields","text":"<p>If the specified field is not found in the FORMAT column: - In <code>all</code> mode: The variant is filtered out - In <code>any</code> mode: The variant is filtered out</p>"},{"location":"VCFX_gl_filter/#missing-values","title":"Missing Values","text":"<p>If a sample has a missing value (<code>.</code>) for the specified field: - In <code>all</code> mode: The variant is filtered out - In <code>any</code> mode: The sample is treated as not passing, but the variant may be kept if other samples pass</p>"},{"location":"VCFX_gl_filter/#empty-values","title":"Empty Values","text":"<p>Empty values are treated similarly to missing values: - In <code>all</code> mode: The variant is filtered out - In <code>any</code> mode: The sample is treated as not passing</p>"},{"location":"VCFX_gl_filter/#non-numeric-values","title":"Non-Numeric Values","text":"<p>If a field value cannot be converted to a number: - In <code>all</code> mode: The variant is filtered out - In <code>any</code> mode: The sample is treated as not passing</p>"},{"location":"VCFX_gl_filter/#malformed-vcf","title":"Malformed VCF","text":"<ul> <li>For lines with insufficient fields (less than the standard VCF format requires), the tool produces a warning and skips the line</li> <li>For data lines before the header (#CHROM) line, the tool produces a warning and skips the line</li> </ul>"},{"location":"VCFX_gl_filter/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>The tool processes VCF files line by line, requiring minimal memory</li> <li>Regex pattern matching is used for efficient parsing of filter conditions</li> <li>No preprocessing or indexing of the VCF file is required</li> <li>Linear time complexity with respect to file size</li> </ul>"},{"location":"VCFX_gl_filter/#limitations","title":"Limitations","text":"<ul> <li>Only works with numeric fields in the FORMAT column</li> <li>No support for filtering on string-valued FORMAT fields</li> <li>Cannot apply different conditions to different samples</li> <li>Cannot combine multiple conditions in a single filter</li> <li>No special handling for multi-allelic sites with multiple values per field</li> <li>Only evaluates the first value when a field contains multiple values </li> </ul>"},{"location":"VCFX_haplotype_extractor/","title":"VCFX_haplotype_extractor","text":""},{"location":"VCFX_haplotype_extractor/#overview","title":"Overview","text":"<p>VCFX_haplotype_extractor reconstructs phased haplotype blocks from genotype data in a VCF file. It identifies stretches of phased variants on the same chromosome and outputs them as continuous haplotype blocks for each sample.</p>"},{"location":"VCFX_haplotype_extractor/#usage","title":"Usage","text":"<pre><code>VCFX_haplotype_extractor [OPTIONS] &lt; input.vcf &gt; haplotypes.tsv\n</code></pre>"},{"location":"VCFX_haplotype_extractor/#options","title":"Options","text":"Option Description <code>--block-size &lt;SIZE&gt;</code> Maximum distance in base pairs between consecutive variants to be included in the same block (default: 100,000) <code>--check-phase-consistency</code> Enable checks for phase consistency between adjacent variants in a block <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_haplotype_extractor/#description","title":"Description","text":"<p>VCFX_haplotype_extractor analyzes phased genotype data in a VCF file to reconstruct continuous haplotype blocks. The tool:</p> <ol> <li>Reads a VCF file from standard input</li> <li>Extracts phased genotype (GT) fields for each sample at each variant position</li> <li>Groups consecutive phased variants into blocks based on:</li> <li>Chromosome continuity (variants must be on the same chromosome)</li> <li>Maximum distance threshold (default 100kb between adjacent variants)</li> <li>Optional phase consistency checks across variants</li> <li>Constructs haplotype strings representing the sequence of alleles on each chromosome</li> <li>Outputs blocks of phased haplotypes in a tab-delimited format</li> </ol> <p>This tool is valuable for: - Identifying regions of continuous phasing in VCF files - Preparing haplotype data for downstream analyses - Reconstructing parental chromosomes from phased variant data - Quality control of phasing algorithms</p>"},{"location":"VCFX_haplotype_extractor/#output-format","title":"Output Format","text":"<p>The output is a tab-delimited text file with columns:</p> <pre><code>CHROM  START  END  SAMPLE_1_HAPLOTYPES  SAMPLE_2_HAPLOTYPES  ...\n</code></pre> <p>Where: - CHROM: Chromosome name - START: Start position of the haplotype block - END: End position of the haplotype block - SAMPLE_X_HAPLOTYPES: A pipe-delimited string representing the phased genotypes for that sample</p> <p>Each sample's haplotype column contains a string of pipe-separated genotypes where each genotype is itself pipe-separated (e.g., \"0|1|1|0|0|1\"). This represents the sequence of alleles in the phased block.</p>"},{"location":"VCFX_haplotype_extractor/#examples","title":"Examples","text":""},{"location":"VCFX_haplotype_extractor/#basic-usage","title":"Basic Usage","text":"<pre><code>./VCFX_haplotype_extractor &lt; phased.vcf &gt; haplotype_blocks.tsv\n</code></pre>"},{"location":"VCFX_haplotype_extractor/#custom-block-size","title":"Custom Block Size","text":"<pre><code># Use a smaller maximum distance (50kb) to generate more, smaller blocks\n./VCFX_haplotype_extractor --block-size 50000 &lt; phased.vcf &gt; small_blocks.tsv\n</code></pre>"},{"location":"VCFX_haplotype_extractor/#with-phase-consistency-checking","title":"With Phase Consistency Checking","text":"<pre><code># Enable checks for phase consistency between variants\n./VCFX_haplotype_extractor --check-phase-consistency &lt; phased.vcf &gt; consistent_blocks.tsv\n</code></pre>"},{"location":"VCFX_haplotype_extractor/#filtering-for-large-blocks","title":"Filtering for Large Blocks","text":"<pre><code># Extract only blocks spanning at least 10 variants\n./VCFX_haplotype_extractor &lt; phased.vcf | awk -F'|' '{if (NF &gt;= 10) print}' &gt; large_blocks.tsv\n</code></pre>"},{"location":"VCFX_haplotype_extractor/#phase-consistency","title":"Phase Consistency","text":"<p>When the <code>--check-phase-consistency</code> option is enabled, the tool performs a basic check to detect potential phase inconsistencies:</p> <ol> <li>For each new variant, the tool examines its phased alleles for each sample</li> <li>It compares these with the last variant added to the current block</li> <li>If it detects a phase \"flip\" (e.g., changing from \"0|1\" to \"1|0\"), it may start a new block</li> <li>This helps identify regions where phasing may be inconsistent</li> </ol> <p>This basic consistency checking is useful for identifying phase switches that might indicate errors in the phasing process or real recombination events.</p>"},{"location":"VCFX_haplotype_extractor/#handling-special-cases","title":"Handling Special Cases","text":"<p>The tool implements several strategies for handling edge cases:</p> <ol> <li>Unphased genotypes: Any variant with unphased genotypes (\"/\" delimiter) is skipped and will not be included in haplotype blocks</li> <li>Missing genotypes: Variants with missing genotypes (\".\") are handled, but may affect block formation</li> <li>Multiallelic sites: Properly processed with the actual allele codes in the haplotype strings</li> <li>Chromosome changes: Automatically starts a new block when the chromosome changes</li> <li>Large distances: Starts a new block when the distance between consecutive variants exceeds the threshold</li> <li>Empty input: Produces no output blocks but exits cleanly</li> <li>Malformed VCF: Attempts to skip malformed lines with warnings</li> </ol>"},{"location":"VCFX_haplotype_extractor/#performance","title":"Performance","text":"<p>VCFX_haplotype_extractor is designed for efficiency:</p> <ol> <li>Single-pass processing with O(n) time complexity where n is the number of variants</li> <li>Memory usage scales primarily with the number of samples and the size of the largest haplotype block</li> <li>Streaming architecture allows processing large files without loading them entirely into memory</li> <li>Block-based approach prevents excessive memory usage for very long chromosomes</li> </ol>"},{"location":"VCFX_haplotype_extractor/#limitations","title":"Limitations","text":"<ol> <li>Requires phased genotypes - variants with unphased genotypes are skipped</li> <li>Cannot join blocks across different chromosomes</li> <li>Simple distance-based blocking may not align with biological recombination patterns</li> <li>Basic phase consistency checking may not detect all inconsistencies</li> <li>No ability to export or visualize the relationship between blocks</li> <li>Does not account for potential errors in the original phasing</li> <li>No special handling for reference gaps or known problematic regions </li> </ol>"},{"location":"VCFX_haplotype_phaser/","title":"VCFX_haplotype_phaser","text":""},{"location":"VCFX_haplotype_phaser/#overview","title":"Overview","text":"<p>VCFX_haplotype_phaser analyzes genotype data to identify variants in linkage disequilibrium (LD) and groups them into haplotype blocks based on an LD threshold. This tool is useful for identifying sets of genetic variants that tend to be inherited together.</p>"},{"location":"VCFX_haplotype_phaser/#usage","title":"Usage","text":"<pre><code>VCFX_haplotype_phaser [OPTIONS] &lt; input.vcf &gt; blocks.txt\n</code></pre>"},{"location":"VCFX_haplotype_phaser/#options","title":"Options","text":"Option Description <code>-l</code>, <code>--ld-threshold &lt;VALUE&gt;</code> r\u00b2 threshold for LD-based grouping (0.0-1.0, default: 0.8) <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_haplotype_phaser/#description","title":"Description","text":"<p>VCFX_haplotype_phaser identifies haplotype blocks by grouping variants that exhibit high linkage disequilibrium (LD). The tool:</p> <ol> <li>Reads a VCF file from standard input</li> <li>Extracts genotype information for each variant across all samples</li> <li>Calculates pairwise LD (specifically r\u00b2) between consecutive variants</li> <li>Groups variants into blocks when they exceed the specified LD threshold</li> <li>Outputs block information showing which variants belong to the same haplotype block</li> </ol> <p>This is valuable for: - Identifying haplotypes without requiring family data - Understanding the correlation structure of variants in a genomic region - Reducing the dimensionality of genetic data for association testing - Planning genotyping strategies by selecting tag SNPs from different blocks</p>"},{"location":"VCFX_haplotype_phaser/#output-format","title":"Output Format","text":"<p>The output preserves the original VCF header, appends the haplotype block information, and then includes the original VCF data. The haplotype block section is formatted as follows:</p> <pre><code>#HAPLOTYPE_BLOCKS_START\nBlock 1: 0:(chr1:1000), 1:(chr1:1050), 2:(chr1:1100)\nBlock 2: 3:(chr1:2000), 4:(chr1:2050)\nBlock 3: 5:(chr2:1000), 6:(chr2:1050)\n#HAPLOTYPE_BLOCKS_END\n</code></pre> <p>Each block line contains: - Block number (1-indexed) - List of grouped variants with their 0-indexed position in the VCF file - Chromosome and position of each variant in parentheses</p>"},{"location":"VCFX_haplotype_phaser/#examples","title":"Examples","text":""},{"location":"VCFX_haplotype_phaser/#basic-usage","title":"Basic Usage","text":"<pre><code>./VCFX_haplotype_phaser &lt; input.vcf &gt; haplotype_blocks.txt\n</code></pre>"},{"location":"VCFX_haplotype_phaser/#custom-ld-threshold","title":"Custom LD Threshold","text":"<pre><code># Use a higher LD threshold for more stringent block definition\n./VCFX_haplotype_phaser --ld-threshold 0.95 &lt; input.vcf &gt; strict_blocks.txt\n</code></pre>"},{"location":"VCFX_haplotype_phaser/#extract-top-blocks","title":"Extract Top Blocks","text":"<pre><code># Extract just the first 10 blocks\n./VCFX_haplotype_phaser &lt; input.vcf | grep -A 10 \"#HAPLOTYPE_BLOCKS_START\" | grep \"Block\" &gt; top_blocks.txt\n</code></pre>"},{"location":"VCFX_haplotype_phaser/#count-number-of-blocks","title":"Count Number of Blocks","text":"<pre><code># Count the number of blocks identified\n./VCFX_haplotype_phaser &lt; input.vcf | grep \"Block\" | wc -l\n</code></pre>"},{"location":"VCFX_haplotype_phaser/#ld-calculation","title":"LD Calculation","text":"<p>The tool calculates LD between variants using the r\u00b2 statistic:</p> <ol> <li>For each pair of variants, it computes:</li> <li>Genotype correlation coefficient (r) across samples</li> <li>Squared correlation coefficient (r\u00b2)</li> <li>The r\u00b2 value ranges from 0 (no LD) to 1 (perfect LD)</li> <li>Variants are grouped into the same block if they have r\u00b2 \u2265 threshold with the last variant in the block</li> </ol> <p>For chromosome 1 specifically, the tool also requires the correlation coefficient (r) to be positive, ensuring that the variants are in positive LD (alleles tend to be inherited together rather than showing repulsion).</p>"},{"location":"VCFX_haplotype_phaser/#handling-special-cases","title":"Handling Special Cases","text":"<p>The tool implements several strategies for handling edge cases:</p> <ol> <li>Chromosome boundaries: New blocks always start when the chromosome changes</li> <li>Missing genotypes: Genotypes coded as \"./.\" or with any missing allele are excluded from LD calculations</li> <li>Low LD variants: Start a new block when LD falls below the threshold</li> <li>No variant data: Reports an error if no variants are found</li> <li>Invalid positions: Skips variants with non-numeric positions</li> <li>Malformed genotypes: Handles and skips variants with improperly formatted genotypes</li> <li>Empty VCF: Reports an error and exits cleanly</li> </ol>"},{"location":"VCFX_haplotype_phaser/#performance","title":"Performance","text":"<p>VCFX_haplotype_phaser is designed for efficiency:</p> <ol> <li>Single-pass processing of variants with minimal memory usage</li> <li>Optimized LD calculation that handles missing data appropriately</li> <li>Scales efficiently with the number of samples and variants</li> <li>Processes large VCF files with thousands of variants in reasonable time</li> <li>Minimal computational overhead by using simplified LD calculations</li> </ol>"},{"location":"VCFX_haplotype_phaser/#limitations","title":"Limitations","text":"<ol> <li>Uses a naive approach to LD calculation that may not account for population structure</li> <li>Genotypes are treated as simple sums (0/0=0, 0/1=1, 1/1=2) without considering phase</li> <li>Cannot merge blocks that are separated by a single low-LD variant</li> <li>No sliding window approach for finding blocks across non-adjacent variants</li> <li>Does not handle multi-allelic variants specially (treats them as bi-allelic)</li> <li>Does not incorporate physical distance in the blocking algorithm</li> <li>No output option for visualizing blocks graphically </li> </ol>"},{"location":"VCFX_header_parser/","title":"VCFX_header_parser","text":""},{"location":"VCFX_header_parser/#overview","title":"Overview","text":"<p>VCFX_header_parser is a simple utility that extracts and displays all header lines from a VCF file. This tool makes it easy to examine metadata and structural information without processing the variant data.</p>"},{"location":"VCFX_header_parser/#usage","title":"Usage","text":"<pre><code>VCFX_header_parser [OPTIONS] &lt; input.vcf &gt; header.txt\n</code></pre>"},{"location":"VCFX_header_parser/#options","title":"Options","text":"Option Description <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_header_parser/#description","title":"Description","text":"<p>VCFX_header_parser reads a VCF file from standard input and outputs only the header lines (lines starting with \"#\"). The tool:</p> <ol> <li>Reads the VCF file line by line</li> <li>Extracts all lines beginning with \"#\", which include:</li> <li>VCF version information (<code>##fileformat=VCFv4.2</code>)</li> <li>Reference genome information (<code>##reference=file:///path/to/reference.fa</code>)</li> <li>Contig definitions (<code>##contig=&lt;ID=chr1,length=248956422&gt;</code>)</li> <li>INFO field definitions (<code>##INFO=&lt;ID=AF,Number=A,Type=Float,Description=\"Allele Frequency\"&gt;</code>)</li> <li>FILTER definitions (<code>##FILTER=&lt;ID=PASS,Description=\"All filters passed\"&gt;</code>)</li> <li>FORMAT definitions (<code>##FORMAT=&lt;ID=GT,Number=1,Type=String,Description=\"Genotype\"&gt;</code>)</li> <li>Sample column header line (<code>#CHROM  POS  ID  REF  ALT  QUAL  FILTER  INFO  FORMAT  SAMPLE1  SAMPLE2</code>)</li> <li>Stops reading when it encounters the first non-header line (any line not starting with \"#\")</li> <li>Outputs all collected header lines to standard output</li> </ol> <p>This tool is useful for: - Examining metadata without processing large variant datasets - Extracting sample names from a VCF file - Checking VCF file structure and compliance with specifications - Creating header templates for new VCF files - Documenting file provenance and contents</p>"},{"location":"VCFX_header_parser/#output-format","title":"Output Format","text":"<p>The output consists of all header lines from the input VCF file, in the same order they appeared in the original file:</p> <pre><code>##fileformat=VCFv4.2\n##source=VCFX\n##FILTER=&lt;ID=PASS,Description=\"All filters passed\"&gt;\n##contig=&lt;ID=chr1,length=248956422&gt;\n#CHROM  POS  ID  REF  ALT  QUAL  FILTER  INFO  FORMAT  SAMPLE1  SAMPLE2\n</code></pre>"},{"location":"VCFX_header_parser/#examples","title":"Examples","text":""},{"location":"VCFX_header_parser/#basic-usage","title":"Basic Usage","text":"<pre><code>./VCFX_header_parser &lt; input.vcf &gt; header.txt\n</code></pre>"},{"location":"VCFX_header_parser/#extracting-sample-names","title":"Extracting Sample Names","text":"<pre><code># Extract the sample names (all columns after FORMAT in the #CHROM line)\n./VCFX_header_parser &lt; input.vcf | grep \"^#CHROM\" | cut -f10- &gt; sample_names.txt\n</code></pre>"},{"location":"VCFX_header_parser/#counting-contigs","title":"Counting Contigs","text":"<pre><code># Count the number of contigs defined in the header\n./VCFX_header_parser &lt; input.vcf | grep \"##contig\" | wc -l\n</code></pre>"},{"location":"VCFX_header_parser/#verifying-vcf-version","title":"Verifying VCF Version","text":"<pre><code># Check the VCF file format version\n./VCFX_header_parser &lt; input.vcf | grep \"##fileformat\" | cut -d= -f2\n</code></pre>"},{"location":"VCFX_header_parser/#handling-special-cases","title":"Handling Special Cases","text":"<p>The tool implements simple strategies for handling edge cases:</p> <ol> <li>Empty files: If the input file is empty, no output is produced</li> <li>Files without headers: If the file has no header lines, no output is produced</li> <li>Malformed headers: All lines starting with \"#\" are considered header lines, even if they don't follow VCF specifications</li> <li>Line endings: LF and CRLF line endings are handled correctly</li> <li>Partial headers: If the file ends in the middle of the header section, all header lines up to that point are output</li> </ol>"},{"location":"VCFX_header_parser/#performance","title":"Performance","text":"<p>VCFX_header_parser is designed for simplicity and efficiency:</p> <ol> <li>Processes input line-by-line without loading the entire file into memory</li> <li>Stops processing as soon as it encounters the first non-header line</li> <li>Highly efficient for large VCF files where headers constitute a small portion of the total file size</li> <li>Minimal memory footprint since only the current line being processed is stored in memory</li> </ol>"},{"location":"VCFX_header_parser/#limitations","title":"Limitations","text":"<ol> <li>No validation of header syntax or compliance with VCF specifications</li> <li>Cannot modify or filter specific header lines</li> <li>No ability to sort or organize header lines</li> <li>No special handling for duplicate header entries</li> <li>Cannot add or merge headers from multiple files </li> </ol>"},{"location":"VCFX_hwe_tester/","title":"VCFX_hwe_tester","text":""},{"location":"VCFX_hwe_tester/#overview","title":"Overview","text":"<p>VCFX_hwe_tester performs Hardy-Weinberg Equilibrium (HWE) testing on biallelic variants in a VCF file, calculating and reporting exact p-values that measure the degree of deviation from expected genotype frequencies.</p>"},{"location":"VCFX_hwe_tester/#usage","title":"Usage","text":"<pre><code>VCFX_hwe_tester [OPTIONS] &lt; input.vcf &gt; hwe_results.txt\n</code></pre>"},{"location":"VCFX_hwe_tester/#options","title":"Options","text":"Option Description <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_hwe_tester/#description","title":"Description","text":"<p>VCFX_hwe_tester analyzes each biallelic variant in a VCF file to determine whether its genotype frequencies conform to Hardy-Weinberg Equilibrium expectations. The tool:</p> <ol> <li>Reads the VCF file line by line</li> <li>Filters for biallelic variants (skips sites with multiple ALT alleles)</li> <li>Counts homozygous reference (0/0), heterozygous (0/1), and homozygous alternate (1/1) genotypes</li> <li>Calculates an exact p-value for Hardy-Weinberg Equilibrium</li> <li>Reports results in a simple tab-delimited format</li> </ol> <p>The exact test uses a full enumeration of the probability distribution to obtain an accurate p-value, rather than relying on chi-square approximations. A low p-value indicates significant deviation from Hardy-Weinberg Equilibrium, which might suggest: - Population stratification - Selection pressure - Non-random mating - Genotyping errors</p>"},{"location":"VCFX_hwe_tester/#output-format","title":"Output Format","text":"<p>The output is a tab-delimited text file with the following columns:</p> <pre><code>CHROM  POS  ID  REF  ALT  HWE_pvalue\n</code></pre> <p>Where: - CHROM, POS, ID, REF, ALT are copied from the input VCF - HWE_pvalue is the calculated p-value for Hardy-Weinberg Equilibrium</p>"},{"location":"VCFX_hwe_tester/#examples","title":"Examples","text":""},{"location":"VCFX_hwe_tester/#basic-usage","title":"Basic Usage","text":"<pre><code>./VCFX_hwe_tester &lt; input.vcf &gt; hwe_results.txt\n</code></pre>"},{"location":"VCFX_hwe_tester/#filter-by-hwe-p-value","title":"Filter by HWE p-value","text":"<pre><code># Extract variants with significant HWE deviation (p &lt; 0.05)\n./VCFX_hwe_tester &lt; input.vcf | awk -F'\\t' '{if(NR==1 || ($6!=\"HWE_pvalue\" &amp;&amp; $6&lt;0.05)) print}' &gt; hwe_significant.txt\n</code></pre>"},{"location":"VCFX_hwe_tester/#check-for-genotyping-errors","title":"Check for Genotyping Errors","text":"<pre><code># Find potential genotyping errors (extremely low HWE p-values)\n./VCFX_hwe_tester &lt; input.vcf | awk -F'\\t' '{if(NR==1 || ($6!=\"HWE_pvalue\" &amp;&amp; $6&lt;0.0001)) print}' &gt; potential_errors.txt\n</code></pre>"},{"location":"VCFX_hwe_tester/#mathematical-details","title":"Mathematical Details","text":"<p>The tool uses an exact test based on the multinomial distribution of genotypes. For each variant:</p> <ol> <li>The observed counts of genotypes (homRef, het, homAlt) are calculated</li> <li>The expected frequencies under HWE are computed as:</li> <li>Expected homRef = p\u00b2 \u00d7 N</li> <li>Expected het = 2pq \u00d7 N</li> <li>Expected homAlt = q\u00b2 \u00d7 N</li> </ol> <p>where p = (2\u00d7homRef + het)/(2\u00d7N), q = 1-p, and N = total number of individuals</p> <ol> <li>The p-value is calculated by summing the probabilities of all possible genotype configurations that are equally or less likely than the observed configuration</li> </ol> <p>This approach provides accurate p-values even for low minor allele frequencies or small sample sizes.</p>"},{"location":"VCFX_hwe_tester/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Multi-allelic variants: Skipped entirely (only biallelic variants are considered)</li> <li>Missing genotypes: Excluded from counts when calculating HWE</li> <li>Phased genotypes: Phase information is ignored; \"0|1\" is treated the same as \"0/1\"</li> <li>Non-standard genotypes: Any genotype other than 0/0, 0/1, or 1/1 is excluded</li> <li>No valid genotypes: If no valid genotypes are found, the p-value is reported as 1.0</li> <li>Perfect equilibrium: For variants with genotype frequencies perfectly matching HWE expectations, the p-value is 1.0</li> </ul>"},{"location":"VCFX_hwe_tester/#performance","title":"Performance","text":"<p>The tool is optimized for efficiency: - Processes one variant at a time, keeping memory usage low - Caches logarithmic factorial values to speed up calculations - Uses numerical optimizations to handle large sample sizes - Scales linearly with the number of variants in the VCF file</p>"},{"location":"VCFX_hwe_tester/#limitations","title":"Limitations","text":"<ul> <li>Only works with biallelic variants</li> <li>Assumes diploid genotypes</li> <li>No stratification by population or other groupings</li> <li>No correction for multiple testing</li> <li>May be less accurate for extremely rare variants with very few non-reference genotypes</li> <li>No built-in filtering for variant quality or missing data threshold </li> </ul>"},{"location":"VCFX_impact_filter/","title":"VCFX_impact_filter","text":""},{"location":"VCFX_impact_filter/#overview","title":"Overview","text":"<p>VCFX_impact_filter filters VCF variants based on their predicted functional impact level (HIGH, MODERATE, LOW, or MODIFIER) found in the INFO field of VCF records.</p>"},{"location":"VCFX_impact_filter/#usage","title":"Usage","text":"<pre><code>VCFX_impact_filter --filter-impact &lt;LEVEL&gt; &lt; input.vcf &gt; filtered.vcf\n</code></pre>"},{"location":"VCFX_impact_filter/#options","title":"Options","text":"Option Description <code>-i</code>, <code>--filter-impact &lt;LEVEL&gt;</code> Required. Impact level threshold. Must be one of: HIGH, MODERATE, LOW, MODIFIER <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_impact_filter/#description","title":"Description","text":"<p>VCFX_impact_filter analyzes variant annotations in a VCF file and filters them based on a specified impact level threshold. The tool:</p> <ol> <li>Reads a VCF file line-by-line</li> <li>For each variant, extracts the impact level from the INFO field (looks for <code>IMPACT=...</code>)</li> <li>Classifies the impact into one of four levels: HIGH, MODERATE, LOW, or MODIFIER</li> <li>Keeps only variants with impact level greater than or equal to the specified threshold</li> <li>Adds an <code>EXTRACTED_IMPACT</code> field to the INFO column of retained variants</li> <li>Outputs the filtered VCF with the same format as the input</li> </ol> <p>The impact level hierarchy used for filtering is: HIGH &gt; MODERATE &gt; LOW &gt; MODIFIER &gt; UNKNOWN</p>"},{"location":"VCFX_impact_filter/#output-format","title":"Output Format","text":"<p>The output is a valid VCF file containing only variants that meet or exceed the specified impact threshold. Each retained variant will have an additional INFO field:</p> <pre><code>EXTRACTED_IMPACT=&lt;value&gt;\n</code></pre> <p>Where <code>&lt;value&gt;</code> is the original impact value extracted from the INFO field.</p>"},{"location":"VCFX_impact_filter/#examples","title":"Examples","text":""},{"location":"VCFX_impact_filter/#filter-for-high-impact-variants-only","title":"Filter for HIGH impact variants only","text":"<pre><code>./VCFX_impact_filter --filter-impact HIGH &lt; input.vcf &gt; high_impact_variants.vcf\n</code></pre>"},{"location":"VCFX_impact_filter/#filter-for-moderate-or-higher-impact-variants","title":"Filter for MODERATE or higher impact variants","text":"<pre><code>./VCFX_impact_filter --filter-impact MODERATE &lt; input.vcf &gt; functional_variants.vcf\n</code></pre>"},{"location":"VCFX_impact_filter/#combining-with-other-tools","title":"Combining with other tools","text":"<pre><code># Filter by impact then convert to another format\n./VCFX_impact_filter --filter-impact HIGH &lt; input.vcf | \\\n  ./VCFX_format_converter --format=bed &gt; high_impact.bed\n</code></pre>"},{"location":"VCFX_impact_filter/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Case insensitivity: Impact values are case insensitive (e.g., \"high\" and \"HIGH\" are treated the same)</li> <li>Extended impact values: Values like \"HIGH_MISSENSE\" are recognized by looking for the presence of standard impact keywords</li> <li>Missing IMPACT field: Variants without an IMPACT field in the INFO column are treated as \"UNKNOWN\" and filtered out by default</li> <li>Empty INFO field: Properly handled by adding the EXTRACTED_IMPACT field as the only INFO attribute</li> <li>Multiple impact annotations: If multiple IMPACT fields are present, only the first one is considered</li> <li>Invalid impact values: Any impact value not recognized as one of the four standard levels is classified as \"UNKNOWN\"</li> </ul>"},{"location":"VCFX_impact_filter/#performance","title":"Performance","text":"<p>The tool is optimized for efficiency: - Processes VCF files line-by-line with minimal memory overhead - Uses regular expressions for reliable pattern matching - Processes very large VCF files with linear time complexity</p>"},{"location":"VCFX_impact_filter/#limitations","title":"Limitations","text":"<ul> <li>Only extracts and analyzes the first IMPACT field found in the INFO column</li> <li>Cannot differentiate between more detailed impact subclassifications (relies on basic HIGH/MODERATE/LOW/MODIFIER keywords)</li> <li>Assumes that functional impact annotations follow standard convention with one of the four recognized impact levels</li> <li>Does not account for the specific variant type (SNP, indel, etc.) when filtering</li> <li>No built-in options to combine impact filtering with other criteria (e.g., allele frequency) </li> </ul>"},{"location":"VCFX_inbreeding_calculator/","title":"VCFX_inbreeding_calculator","text":""},{"location":"VCFX_inbreeding_calculator/#overview","title":"Overview","text":"<p>VCFX_inbreeding_calculator computes the inbreeding coefficient (F) for each sample in a VCF file, providing a measure of homozygosity relative to Hardy-Weinberg equilibrium expectations.</p>"},{"location":"VCFX_inbreeding_calculator/#usage","title":"Usage","text":"<pre><code>VCFX_inbreeding_calculator [OPTIONS] &lt; input.vcf &gt; output.txt\n</code></pre>"},{"location":"VCFX_inbreeding_calculator/#options","title":"Options","text":"Option Description <code>--freq-mode</code> MODE How to calculate allele frequencies: 'excludeSample' (default) or 'global' <code>--skip-boundary</code> Skip sites with boundary frequencies (p=0 or p=1) <code>--count-boundary-as-used</code> Count boundary sites in usedCount even when skipping them <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_inbreeding_calculator/#description","title":"Description","text":"<p>VCFX_inbreeding_calculator analyzes biallelic variants in a VCF file to calculate the inbreeding coefficient (F) for each sample. The inbreeding coefficient measures the reduction in heterozygosity compared to expectations under Hardy-Weinberg equilibrium.</p> <p>The tool: 1. Reads the VCF file in a single pass 2. Filters for biallelic variants (ignores sites with multiple ALT alleles) 3. Encodes genotypes as 0 (0/0), 1 (0/1), 2 (1/1), or -1 (missing/invalid) 4. Calculates allele frequencies using the specified method 5. Computes the inbreeding coefficient for each sample</p>"},{"location":"VCFX_inbreeding_calculator/#frequency-modes","title":"Frequency Modes","text":"<p>The tool offers two methods for calculating allele frequencies:</p> <ul> <li>excludeSample: Each sample's inbreeding coefficient is calculated using allele frequencies derived from all other samples (excluding itself)</li> <li>global: A single global allele frequency is calculated using all samples, and this same frequency is used for all samples</li> </ul>"},{"location":"VCFX_inbreeding_calculator/#boundary-handling","title":"Boundary Handling","text":"<p>For sites where the allele frequency (p) is 0 or 1, you have three options:</p> <ol> <li>Use these sites normally (default)</li> <li>Skip boundary sites completely (<code>--skip-boundary</code>)</li> <li>Skip boundary sites for calculations but count them as used sites (<code>--skip-boundary --count-boundary-as-used</code>)</li> </ol>"},{"location":"VCFX_inbreeding_calculator/#output-format","title":"Output Format","text":"<p>The output is a tab-delimited text file with the following columns:</p> <pre><code>Sample  InbreedingCoefficient\n</code></pre> <p>Where: - Sample is the sample name from the VCF file - InbreedingCoefficient is the calculated F value, or \"NA\" if no usable sites were found</p>"},{"location":"VCFX_inbreeding_calculator/#examples","title":"Examples","text":""},{"location":"VCFX_inbreeding_calculator/#basic-usage-default-settings","title":"Basic Usage (Default Settings)","text":"<pre><code>./VCFX_inbreeding_calculator &lt; input.vcf &gt; inbreeding_coefficients.txt\n</code></pre>"},{"location":"VCFX_inbreeding_calculator/#using-global-frequency-mode","title":"Using Global Frequency Mode","text":"<pre><code>./VCFX_inbreeding_calculator --freq-mode global &lt; input.vcf &gt; global_inbreeding.txt\n</code></pre>"},{"location":"VCFX_inbreeding_calculator/#skip-boundary-frequencies","title":"Skip Boundary Frequencies","text":"<pre><code>./VCFX_inbreeding_calculator --skip-boundary &lt; input.vcf &gt; non_boundary_inbreeding.txt\n</code></pre>"},{"location":"VCFX_inbreeding_calculator/#custom-boundary-handling","title":"Custom Boundary Handling","text":"<pre><code>./VCFX_inbreeding_calculator --skip-boundary --count-boundary-as-used &lt; input.vcf &gt; custom_boundary.txt\n</code></pre>"},{"location":"VCFX_inbreeding_calculator/#formula-and-calculation","title":"Formula and Calculation","text":"<p>The inbreeding coefficient is calculated as:</p> <p>F = (O - E) / (T - E)</p> <p>Where: - O = Observed homozygosity (count of 0/0 and 1/1 genotypes) - E = Expected homozygosity under HWE (\u2211(p\u00b2+q\u00b2) across sites) - T = Total number of sites (after filtering)</p> <p>In boundary cases: - If total sites used = 0, F = NA - If expected = observed, F = 0 - If expected = total, F = 1</p>"},{"location":"VCFX_inbreeding_calculator/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Single-sample VCFs: Always produces \"NA\" as inbreeding requires population context</li> <li>Multi-allelic sites: Skipped entirely (only biallelic variants are considered)</li> <li>Missing genotypes: Coded as -1 and excluded from calculations</li> <li>Non-diploid genotypes: Treated as missing and excluded</li> <li>Boundary frequencies: Special handling available via command-line options</li> <li>Zero usable sites: Returns \"NA\" for the sample</li> <li>Small sample sizes: May produce unreliable estimates</li> </ul>"},{"location":"VCFX_inbreeding_calculator/#performance","title":"Performance","text":"<p>The tool performs a single pass through the VCF file, giving it linear complexity with respect to file size. Memory usage scales with: - Number of samples in the VCF - Number of biallelic variants</p>"},{"location":"VCFX_inbreeding_calculator/#limitations","title":"Limitations","text":"<ul> <li>Only works with biallelic variants (multiallelic sites are skipped)</li> <li>Assumes diploid genotypes</li> <li>May produce unexpected results with very small sample sizes</li> <li>No built-in filtering for variant quality or other metrics</li> <li>No chromosome or region-specific analysis</li> <li>Cannot handle populations with substructure (assumes random mating) </li> </ul>"},{"location":"VCFX_indel_normalizer/","title":"VCFX_indel_normalizer","text":""},{"location":"VCFX_indel_normalizer/#overview","title":"Overview","text":"<p><code>VCFX_indel_normalizer</code> is a tool for normalizing indel variants in VCF files. It performs left-alignment of variants by removing common prefixes and suffixes between reference and alternate alleles, and splits multi-allelic variants into separate records. This normalization is done without requiring an external reference genome.</p>"},{"location":"VCFX_indel_normalizer/#usage","title":"Usage","text":"<pre><code>VCFX_indel_normalizer [OPTIONS] &lt; input.vcf &gt; normalized.vcf\n</code></pre>"},{"location":"VCFX_indel_normalizer/#options","title":"Options","text":"Option Description <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_indel_normalizer/#description","title":"Description","text":"<p><code>VCFX_indel_normalizer</code> processes a VCF file and normalizes indel variants by:</p> <ol> <li>Reading the VCF file from standard input</li> <li>Preserving all header lines without modification</li> <li>For variants with multiple alternate alleles (comma-separated ALT values):</li> <li>Splitting them into separate lines, one per alternate allele</li> <li>For each variant:</li> <li>Removing the longest common prefix from REF and ALT, keeping at least one base</li> <li>Removing the longest common suffix from REF and ALT, keeping at least one base</li> <li>Adjusting the position (POS) to account for removed leading bases</li> <li>Writing the normalized variants to standard output</li> </ol> <p>This normalization ensures that variants are represented in a consistent, minimal left-aligned form, which is important for variant comparison, annotation, and analysis.</p>"},{"location":"VCFX_indel_normalizer/#normalization-process","title":"Normalization Process","text":""},{"location":"VCFX_indel_normalizer/#left-alignment-algorithm","title":"Left Alignment Algorithm","text":"<p>The tool implements a simple but effective left-alignment approach:</p> <ol> <li>Prefix Removal:</li> <li>Identify the longest common prefix between REF and ALT</li> <li>Remove all but one base of this common prefix</li> <li> <p>Adjust the variant position to account for the removed bases</p> </li> <li> <p>Suffix Removal:</p> </li> <li>Identify the longest common suffix between REF and ALT</li> <li> <p>Remove all but one base of this common suffix</p> </li> <li> <p>Special Case Handling:</p> </li> <li>If after normalization REF or ALT is empty, the variant is considered invalid</li> <li>If after normalization REF and ALT are identical, the variant is considered invalid</li> </ol>"},{"location":"VCFX_indel_normalizer/#multi-allelic-variant-handling","title":"Multi-allelic Variant Handling","text":"<p>For variants with multiple alternate alleles: - Each alternate allele is processed separately - A new VCF line is generated for each alternate allele - Each new line undergoes the same normalization process</p>"},{"location":"VCFX_indel_normalizer/#examples","title":"Examples","text":""},{"location":"VCFX_indel_normalizer/#basic-usage","title":"Basic Usage","text":"<p>Normalize indels in a VCF file: <pre><code>VCFX_indel_normalizer &lt; input.vcf &gt; normalized.vcf\n</code></pre></p>"},{"location":"VCFX_indel_normalizer/#example-transformations","title":"Example Transformations","text":""},{"location":"VCFX_indel_normalizer/#prefix-removal","title":"Prefix Removal","text":"<pre><code>Before: chr1 100 . ACTG AC   (deletion of TG)\nAfter:  chr1 102 . TG   -    (adjusted position, simplified representation)\n</code></pre>"},{"location":"VCFX_indel_normalizer/#suffix-removal","title":"Suffix Removal","text":"<pre><code>Before: chr1 100 . ACTG ACCC (substitution of TG with CC)\nAfter:  chr1 100 . AC   ACC  (common suffix 'C' removed)\n</code></pre>"},{"location":"VCFX_indel_normalizer/#multi-allelic-splitting","title":"Multi-allelic Splitting","text":"<pre><code>Before: chr1 100 . A    C,G,T\nAfter:  chr1 100 . A    C\n        chr1 100 . A    G\n        chr1 100 . A    T\n</code></pre>"},{"location":"VCFX_indel_normalizer/#handling-special-cases","title":"Handling Special Cases","text":""},{"location":"VCFX_indel_normalizer/#invalid-variants","title":"Invalid Variants","text":"<ul> <li>If after normalization a variant would have an empty REF or ALT, the original line is preserved</li> <li>If after normalization REF equals ALT (no actual variant), the original line is preserved</li> </ul>"},{"location":"VCFX_indel_normalizer/#empty-lines","title":"Empty Lines","text":"<ul> <li>Empty lines in the input are preserved as empty lines in the output</li> </ul>"},{"location":"VCFX_indel_normalizer/#malformed-lines","title":"Malformed Lines","text":"<ul> <li>Lines with fewer than 10 columns (minimum for a VCF with samples) are output unchanged</li> <li>Lines with invalid position values are output unchanged</li> </ul>"},{"location":"VCFX_indel_normalizer/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>The tool processes VCF files line by line, with minimal memory requirements</li> <li>Performance scales linearly with input file size</li> <li>No external reference genome is required, making it lightweight and portable</li> </ul>"},{"location":"VCFX_indel_normalizer/#limitations","title":"Limitations","text":"<ul> <li>This tool performs simple left-alignment without checking for sequence repeats in a reference genome</li> <li>Full left-alignment of variants in repetitive regions requires a reference sequence</li> <li>Cannot handle complex structural variants beyond simple indels</li> <li>Limited to the information available in the VCF file itself</li> <li>No automatic breakup of complex variants (substitutions that could be represented as indels)</li> <li>No variant filtering capabilities </li> </ul>"},{"location":"VCFX_indexer/","title":"VCFX_indexer","text":""},{"location":"VCFX_indexer/#overview","title":"Overview","text":"<p><code>VCFX_indexer</code> is a utility tool for creating a byte-offset index of a VCF file. It generates a simple tab-delimited index file that maps chromosome and position to the exact byte offset in the original file, enabling efficient random access to variants without scanning the entire file. The index uses 64-bit integers for both the position and the byte offset so very large coordinates are fully supported.</p>"},{"location":"VCFX_indexer/#usage","title":"Usage","text":"<pre><code>VCFX_indexer [OPTIONS] &lt; input.vcf &gt; index.tsv\n</code></pre>"},{"location":"VCFX_indexer/#options","title":"Options","text":"Option Description <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_indexer/#description","title":"Description","text":"<p><code>VCFX_indexer</code> processes a VCF file to create a position-based index by:</p> <ol> <li>Reading the VCF file from standard input as a raw byte stream</li> <li>Locating the #CHROM header line to determine the start of data lines</li> <li>For each variant line:</li> <li>Extracting the chromosome (CHROM) and position (POS) values</li> <li>Calculating the precise byte offset from the start of the file</li> <li>Writing a three-column index to standard output with:<ul> <li>CHROM: The chromosome identifier from the VCF</li> <li>POS: The position value from the VCF (stored as a 64-bit integer)</li> <li>FILE_OFFSET: The byte offset to the start of the line in the source file (also 64-bit)</li> </ul> </li> </ol> <p>This index enables efficient random access to specific variants in large VCF files by allowing tools to seek directly to a byte offset rather than scanning the entire file. It's particularly useful for building tools that need to query specific regions of a VCF file.</p>"},{"location":"VCFX_indexer/#output-format","title":"Output Format","text":"<p>The index file is a tab-delimited text file with the following format:</p> <pre><code>CHROM   POS    FILE_OFFSET\n1       100    542\n1       200    621\n1       300    702\n</code></pre> <p>Where:</p> <ul> <li><code>CHROM</code> is the chromosome identifier from the VCF</li> <li><code>POS</code> is the genomic position from the VCF (64-bit integer)</li> <li><code>FILE_OFFSET</code> is the byte offset from the start of the VCF file (64-bit integer)</li> </ul>"},{"location":"VCFX_indexer/#examples","title":"Examples","text":""},{"location":"VCFX_indexer/#basic-usage","title":"Basic Usage","text":"<p>Create an index for a VCF file: <pre><code>VCFX_indexer &lt; input.vcf &gt; input.vcf.idx\n</code></pre></p>"},{"location":"VCFX_indexer/#using-with-other-tools","title":"Using with Other Tools","text":"<p>Use the index to quickly extract a specific variant:</p> <pre><code># Find the offset for position 1:12345\ngrep -P \"^1\\t12345\\t\" input.vcf.idx\n\n# Use the offset (e.g., 23456) to seek directly to that variant\ntail -c +23456 input.vcf | head -1\n</code></pre>"},{"location":"VCFX_indexer/#special-case-handling","title":"Special Case Handling","text":""},{"location":"VCFX_indexer/#file-format-detection","title":"File Format Detection","text":"<ul> <li>The tool automatically handles LF and CRLF line endings</li> <li>Byte offsets are calculated correctly regardless of the line ending style</li> </ul>"},{"location":"VCFX_indexer/#malformed-vcf-files","title":"Malformed VCF Files","text":"<ul> <li>Lines with unparseable position values are skipped</li> <li>If the #CHROM header is missing, an error is reported and no index entries are generated</li> <li>The tool requires variants to be tab-delimited; space-delimited files are not properly indexed</li> </ul>"},{"location":"VCFX_indexer/#stream-processing","title":"Stream Processing","text":"<ul> <li>The tool can process files from pipes as well as regular files</li> <li>For piped input, offsets are calculated relative to the beginning of the piped stream</li> </ul>"},{"location":"VCFX_indexer/#empty-lines-and-comments","title":"Empty Lines and Comments","text":"<ul> <li>Empty lines and comment lines (starting with #) are properly handled and do not generate index entries</li> </ul>"},{"location":"VCFX_indexer/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>The tool processes the VCF file in a single pass</li> <li>Memory usage is minimal as the file is processed line-by-line</li> <li>Large files can be indexed efficiently as the tool uses a buffered reading approach</li> <li>For very large files, the index itself will be much smaller than the original VCF</li> <li>The index file size scales with the number of variants, not the file size</li> </ul>"},{"location":"VCFX_indexer/#limitations","title":"Limitations","text":"<ul> <li>No support for indexing other fields besides CHROM and POS</li> <li>Does not validate the VCF format beyond basic column checking</li> <li>No built-in compression of the index file</li> <li>Cannot add new entries to an existing index (must regenerate the full index)</li> <li>Does not directly support query operations (must be used with other tools)</li> <li>Cannot handle compressed (gzipped) VCF files directly </li> </ul>"},{"location":"VCFX_info_aggregator/","title":"VCFX_info_aggregator","text":""},{"location":"VCFX_info_aggregator/#overview","title":"Overview","text":"<p><code>VCFX_info_aggregator</code> is a tool that reads a VCF file from standard input, outputs it unmodified, and appends a summary section containing aggregated statistics (sum and average) for specified numeric INFO fields. The summary section is formatted as VCF header-like comments to maintain compatibility with VCF parsers.</p>"},{"location":"VCFX_info_aggregator/#usage","title":"Usage","text":"<pre><code>VCFX_info_aggregator [OPTIONS] &lt; input.vcf &gt; output.vcf\n</code></pre>"},{"location":"VCFX_info_aggregator/#options","title":"Options","text":"<ul> <li><code>-a</code>, <code>--aggregate-info &lt;fields&gt;</code>: Comma-separated list of INFO fields to aggregate (required).</li> <li><code>-h</code>, <code>--help</code>: Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) | <code>-v</code>, <code>--version</code> | Show program version and exit (handled by <code>vcfx::handle_common_flags</code>) |</li> </ul>"},{"location":"VCFX_info_aggregator/#description","title":"Description","text":"<p><code>VCFX_info_aggregator</code> processes a VCF file line by line, performing the following operations:</p> <ol> <li>Parse command-line arguments to determine which INFO fields to aggregate.</li> <li>Read each line from standard input.</li> <li>Output each line unmodified to standard output.</li> <li>For data lines (non-header lines):</li> <li>Parse the INFO column (8th column).</li> <li>Extract specified INFO fields if they exist and contain numeric values.</li> <li>Accumulate these numeric values for later calculation.</li> <li>After processing all lines, append a summary section that includes:</li> <li>A line starting with <code>#AGGREGATION_SUMMARY</code>.</li> <li>For each specified INFO field, a line reporting the sum and average of all valid numeric values found.</li> </ol> <p>The tool is particularly useful for calculating summary statistics across an entire VCF file, such as average depth of coverage (DP) or average allele frequency (AF).</p>"},{"location":"VCFX_info_aggregator/#output-format","title":"Output Format","text":"<p>The output is identical to the input VCF file, with additional summary lines appended at the end:</p> <pre><code>... original VCF content ...\n#AGGREGATION_SUMMARY\nFIELD1: Sum=&lt;total&gt;, Average=&lt;mean&gt;\nFIELD2: Sum=&lt;total&gt;, Average=&lt;mean&gt;\n</code></pre> <p>The summary lines start with <code>#</code> to ensure they are treated as comments by standard VCF parsers, maintaining compatibility.</p>"},{"location":"VCFX_info_aggregator/#examples","title":"Examples","text":""},{"location":"VCFX_info_aggregator/#basic-usage","title":"Basic Usage","text":"<p>Calculate summary statistics for the depth (DP) field:</p> <pre><code>VCFX_info_aggregator --aggregate-info \"DP\" &lt; input.vcf &gt; output.vcf\n</code></pre>"},{"location":"VCFX_info_aggregator/#multiple-fields","title":"Multiple Fields","text":"<p>Calculate statistics for both depth (DP) and allele frequency (AF):</p> <pre><code>VCFX_info_aggregator --aggregate-info \"DP,AF\" &lt; input.vcf &gt; output.vcf\n</code></pre>"},{"location":"VCFX_info_aggregator/#combining-with-other-tools","title":"Combining with Other Tools","text":"<p>Used in a pipeline to analyze filtered variants:</p> <pre><code>VCFX_record_filter --quality \"&gt;30\" &lt; input.vcf | VCFX_info_aggregator --aggregate-info \"DP,AF,MQ\" &gt; filtered_with_stats.vcf\n</code></pre>"},{"location":"VCFX_info_aggregator/#handling-special-cases","title":"Handling Special Cases","text":"<p>The tool implements several strategies for handling edge cases:</p> <ol> <li>Non-numeric values: If a field cannot be parsed as a numeric value (e.g., \"DP=abc\"), it is skipped and not included in the aggregation.</li> <li>Missing fields: If a specified INFO field is not present in a particular variant, it is simply skipped for that variant.</li> <li>Empty input: The tool will process empty files correctly, reporting zeros for sums and averages.</li> <li>Malformed VCF: If a data line is encountered before the <code>#CHROM</code> header, an error is reported.</li> <li>Line endings: The tool correctly handles LF and CRLF line endings.</li> <li>Partial final line: The tool properly processes files that do not end with a newline character.</li> </ol>"},{"location":"VCFX_info_aggregator/#performance","title":"Performance","text":"<p><code>VCFX_info_aggregator</code> is designed to be memory-efficient and performant:</p> <ol> <li>It processes the VCF file in a single pass, with O(1) memory usage relative to the file size.</li> <li>Only the specified INFO fields are parsed and accumulated, minimizing unnecessary processing.</li> <li>The tool streams data directly from input to output, without storing the entire file in memory.</li> </ol>"},{"location":"VCFX_info_aggregator/#limitations","title":"Limitations","text":"<ol> <li>The tool only processes numeric values in INFO fields. String, flag, or complex values are not aggregated.</li> <li>For multi-allelic variants, INFO fields like AF that may contain multiple values (comma-separated) are processed as a single value.</li> <li>The tool does not modify or annotate the original variants; it only appends summary statistics at the end of the file.</li> <li>The summary section, while formatted as VCF comments, may not be recognized by all downstream tools that expect a strictly-conforming VCF file.</li> <li>There is no option to calculate additional statistics beyond sum and average (e.g., median, standard deviation). </li> </ol>"},{"location":"VCFX_info_parser/","title":"VCFX_info_parser","text":""},{"location":"VCFX_info_parser/#overview","title":"Overview","text":"<p>VCFX_info_parser extracts and formats specific INFO fields from a VCF file into a tabular format for easier analysis. The tool processes a VCF file line by line, parses the INFO column, and outputs only the requested fields in a clean TSV format.</p>"},{"location":"VCFX_info_parser/#usage","title":"Usage","text":"<pre><code>VCFX_info_parser --info \"FIELD1,FIELD2,...\" &lt; input.vcf &gt; extracted_info.tsv\n</code></pre>"},{"location":"VCFX_info_parser/#options","title":"Options","text":"Option Description <code>-i</code>, <code>--info &lt;FIELDS&gt;</code> Required. Comma-separated list of INFO fields to extract (e.g., \"DP,AF,SOMATIC\") <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_info_parser/#description","title":"Description","text":"<p>VCFX_info_parser simplifies the process of extracting specific information from VCF files by:</p> <ol> <li>Reading VCF data from standard input</li> <li>Parsing the INFO column to extract user-specified fields</li> <li>Producing a clean, tabular output with standardized headers</li> <li>Properly handling flags, missing values, and malformed entries</li> </ol> <p>This tool is particularly useful for: - Extracting numeric values like depth (DP) or allele frequency (AF) for statistical analysis - Converting complex VCF INFO fields into a format suitable for spreadsheet applications - Creating simplified datasets focused on specific annotations - Preparing data for visualization or report generation</p>"},{"location":"VCFX_info_parser/#output-format","title":"Output Format","text":"<p>The output is a tab-separated file with the following columns:</p> <pre><code>CHROM  POS  ID  REF  ALT  FIELD1  FIELD2  ...\n</code></pre> <p>Where: - The first five columns are standard VCF fields (chromosome, position, ID, reference allele, alternate allele) - Each subsequent column contains the value of a requested INFO field - Missing values are represented by a dot (.) - Flag fields (INFO fields with no value) are also represented by a dot (.)</p>"},{"location":"VCFX_info_parser/#examples","title":"Examples","text":""},{"location":"VCFX_info_parser/#basic-usage-extract-depth-information","title":"Basic Usage - Extract Depth Information","text":"<pre><code>./VCFX_info_parser --info \"DP\" &lt; input.vcf &gt; depth_data.tsv\n</code></pre>"},{"location":"VCFX_info_parser/#extract-multiple-fields","title":"Extract Multiple Fields","text":"<pre><code>./VCFX_info_parser --info \"DP,AF,MQ\" &lt; input.vcf &gt; key_metrics.tsv\n</code></pre>"},{"location":"VCFX_info_parser/#working-with-annotation-data","title":"Working with Annotation Data","text":"<pre><code>./VCFX_info_parser --info \"Gene,IMPACT,Consequence\" &lt; annotated.vcf &gt; gene_impacts.tsv\n</code></pre>"},{"location":"VCFX_info_parser/#pipeline-example","title":"Pipeline Example","text":"<pre><code># Filter a VCF file and extract specific INFO fields\ncat input.vcf | grep \"PASS\" | ./VCFX_info_parser --info \"DP,AF,SOMATIC\" &gt; filtered_annotations.tsv\n</code></pre>"},{"location":"VCFX_info_parser/#handling-special-cases","title":"Handling Special Cases","text":"<p>The tool implements several strategies for handling edge cases:</p> <ol> <li>Flag fields: INFO fields without values (flags like 'SOMATIC') are represented by a dot in the output</li> <li>Missing fields: If a requested INFO field is not present in a specific variant, a dot is printed</li> <li>Malformed lines: Lines that don't conform to VCF format are skipped with a warning message</li> <li>Empty input: The tool correctly handles empty input files</li> <li>Header lines: VCF header lines (starting with #) are skipped</li> <li>Line endings: LF and CRLF line endings are supported</li> <li>Partial final line: Files without a final newline character are processed correctly</li> </ol>"},{"location":"VCFX_info_parser/#performance","title":"Performance","text":"<p>VCFX_info_parser is designed for efficiency:</p> <ol> <li>Single-pass processing with line-by-line reading, allowing for streaming of very large files</li> <li>Minimal memory footprint regardless of input file size</li> <li>Efficient string parsing with no complex regular expressions</li> <li>Fast lookup of INFO fields using hash maps</li> </ol>"},{"location":"VCFX_info_parser/#limitations","title":"Limitations","text":"<ol> <li>Cannot handle multi-allelic variants specially (each row is processed independently)</li> <li>No built-in filtering capabilities (use in conjunction with other filtering tools)</li> <li>Cannot split INFO fields with multiple values (e.g., CSQ fields from VEP)</li> <li>Doesn't preserve VCF headers in the output</li> <li>No option to include additional VCF columns (QUAL, FILTER) in the output</li> <li>Cannot extract FORMAT fields or sample-specific information </li> </ol>"},{"location":"VCFX_info_summarizer/","title":"VCFX_info_summarizer","text":""},{"location":"VCFX_info_summarizer/#overview","title":"Overview","text":"<p>VCFX_info_summarizer analyzes numeric fields in the INFO column of a VCF file and calculates summary statistics (mean, median, and mode) for each specified field. This tool enables researchers to quickly understand the distribution and central tendencies of key metrics across variants.</p>"},{"location":"VCFX_info_summarizer/#usage","title":"Usage","text":"<pre><code>VCFX_info_summarizer --info \"FIELD1,FIELD2,...\" &lt; input.vcf &gt; summary_stats.tsv\n</code></pre>"},{"location":"VCFX_info_summarizer/#options","title":"Options","text":"Option Description <code>-i</code>, <code>--info &lt;FIELDS&gt;</code> Required. Comma-separated list of INFO fields to analyze (e.g., \"DP,AF,MQ\") <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_info_summarizer/#description","title":"Description","text":"<p>VCFX_info_summarizer processes a VCF file to generate statistical summaries of specified numeric INFO fields. The tool:</p> <ol> <li>Reads a VCF file from standard input</li> <li>Parses the INFO column from each variant record</li> <li>Extracts numeric values for the specified INFO fields</li> <li>Calculates three key statistics for each field:</li> <li>Mean (average value)</li> <li>Median (middle value)</li> <li>Mode (most frequently occurring value)</li> <li>Outputs the results in a clean, tabular format</li> </ol> <p>This tool is valuable for: - Quality control assessment of sequencing data - Understanding the distribution of metrics like depth, allele frequency, or mapping quality - Identifying potential biases or anomalies in variant calling - Summarizing large VCF files for reports or visualizations</p>"},{"location":"VCFX_info_summarizer/#output-format","title":"Output Format","text":"<p>The output is a tab-separated file with the following columns:</p> <pre><code>INFO_Field  Mean  Median  Mode\n</code></pre> <p>Where: - INFO_Field: The name of the INFO field being summarized - Mean: The arithmetic mean of all numeric values for that field - Median: The middle value when all values are sorted - Mode: The most frequently occurring value - \"NA\" is displayed if no valid numeric values were found for a field</p> <p>All numeric values are formatted with four decimal places of precision.</p>"},{"location":"VCFX_info_summarizer/#examples","title":"Examples","text":""},{"location":"VCFX_info_summarizer/#basic-usage-analyze-depth-statistics","title":"Basic Usage - Analyze Depth Statistics","text":"<pre><code>./VCFX_info_summarizer --info \"DP\" &lt; input.vcf &gt; depth_stats.tsv\n</code></pre>"},{"location":"VCFX_info_summarizer/#analyze-multiple-fields","title":"Analyze Multiple Fields","text":"<pre><code>./VCFX_info_summarizer --info \"DP,AF,MQ\" &lt; input.vcf &gt; variant_stats.tsv\n</code></pre>"},{"location":"VCFX_info_summarizer/#analyze-complex-input-with-filtering","title":"Analyze Complex Input with Filtering","text":"<pre><code># Get summary stats for only PASS variants\ngrep -e \"^#\" -e \"PASS\" input.vcf | ./VCFX_info_summarizer --info \"DP,QD,FS\" &gt; pass_variant_stats.tsv\n</code></pre>"},{"location":"VCFX_info_summarizer/#filter-and-compare-multiple-vcf-files","title":"Filter and Compare Multiple VCF Files","text":"<pre><code># Create a summary comparison script for multiple files\nfor vcf in sample1.vcf sample2.vcf sample3.vcf; do\n  echo \"=== $vcf ===\" &gt;&gt; summary.txt\n  ./VCFX_info_summarizer --info \"DP,AF\" &lt; $vcf &gt;&gt; summary.txt\n  echo \"\" &gt;&gt; summary.txt\ndone\n</code></pre>"},{"location":"VCFX_info_summarizer/#handling-special-cases","title":"Handling Special Cases","text":"<p>The tool implements several strategies for handling edge cases:</p> <ol> <li>Non-numeric values: Skipped with a warning to stderr, without affecting the calculations for other values</li> <li>Missing fields: If a specified field is not present in a variant's INFO column, it's simply skipped</li> <li>Multi-value fields: Each comma-separated value is processed individually (e.g., AF=0.1,0.2,0.3)</li> <li>Empty input: Outputs \"NA\" for all statistics if no valid values are found</li> <li>Malformed VCF: Lines that don't conform to VCF format are skipped with a warning</li> <li>Header validation: Checks for the presence of a proper #CHROM header line before processing records</li> <li>Flag fields: INFO flags without values are treated as having a value of \"1\" for statistical calculations</li> </ol>"},{"location":"VCFX_info_summarizer/#performance","title":"Performance","text":"<p>VCFX_info_summarizer is designed for efficiency with large VCF files:</p> <ol> <li>Single-pass processing with O(n) time complexity where n is the number of variants</li> <li>O(m) memory usage where m is the number of numeric values for the specified fields</li> <li>Efficient string parsing using streams</li> <li>Fast statistical calculations with minimal sorting operations</li> </ol>"},{"location":"VCFX_info_summarizer/#limitations","title":"Limitations","text":"<ol> <li>Cannot process non-numeric INFO fields (strings, flags, etc.) except for converting flags to \"1\"</li> <li>No ability to filter variants based on their values (must be combined with other tools for filtering)</li> <li>Limited to basic statistics (mean, median, mode); no advanced statistics like standard deviation, quartiles, etc.</li> <li>Does not support weighted statistics for multi-allelic variants</li> <li>Cannot process FORMAT fields or perform sample-specific statistical summaries</li> <li>No support for histograms or graphical representations of the data distribution </li> </ol>"},{"location":"VCFX_ld_calculator/","title":"VCFX_ld_calculator","text":""},{"location":"VCFX_ld_calculator/#overview","title":"Overview","text":"<p><code>VCFX_ld_calculator</code> calculates pairwise linkage disequilibrium (LD) statistics between genetic variants in a VCF file, expressed as r\u00b2 values. It can analyze variants across an entire file or within a specified genomic region.</p>"},{"location":"VCFX_ld_calculator/#usage","title":"Usage","text":"<pre><code>VCFX_ld_calculator [OPTIONS] &lt; input.vcf &gt; ld_matrix.txt\n</code></pre>"},{"location":"VCFX_ld_calculator/#options","title":"Options","text":"Option Description <code>--region &lt;chr:start-end&gt;</code> Only compute LD for variants in the specified region <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_ld_calculator/#description","title":"Description","text":"<p><code>VCFX_ld_calculator</code> reads a VCF file and computes the pairwise linkage disequilibrium (r\u00b2) between genetic variants. Linkage disequilibrium is a measure of the non-random association between alleles at different loci, which is important for understanding genetic structure, identifying haplotype blocks, and designing association studies.</p> <p>The tool operates as follows:</p> <ol> <li>It reads the VCF file from standard input</li> <li>It collects diploid genotypes for each variant, encoding them as:</li> <li>0: Homozygous reference (0/0)</li> <li>1: Heterozygous (0/1 or 1/0)</li> <li>2: Homozygous alternate (1/1)</li> <li>-1: Missing data or other scenarios (including multi-allelic variants)</li> <li>For each pair of variants within the specified region (or the entire file if no region is specified), it computes pairwise r\u00b2 values, ignoring samples with missing genotypes</li> <li>It outputs a matrix of r\u00b2 values along with variant identifiers</li> </ol> <p>The r\u00b2 calculation uses the standard formula: - Let X and Y be the genotype arrays for two variants - Calculate means of X and Y (meanX, meanY) - Calculate covariance: cov = average(XY) - meanX * meanY - Calculate variances: varX = average(X\u00b2) - meanX\u00b2, varY similarly - r = cov / sqrt(varX * varY) - r\u00b2 = r * r</p>"},{"location":"VCFX_ld_calculator/#output-format","title":"Output Format","text":"<p>The output is a tab-delimited matrix of r\u00b2 values with a header identifying the variants:</p> <pre><code>#LD_MATRIX_START\n         chr1:100 chr1:200 chr1:300\nchr1:100      1.0     0.4     0.2\nchr1:200     0.4      1.0     0.6\nchr1:300     0.2     0.6      1.0\n</code></pre> <p>If only one or no variants are found in the region, the tool outputs a message indicating that no pairwise LD could be calculated.</p>"},{"location":"VCFX_ld_calculator/#examples","title":"Examples","text":""},{"location":"VCFX_ld_calculator/#basic-usage","title":"Basic Usage","text":"<p>Calculate LD for all variants in a VCF file:</p> <pre><code>VCFX_ld_calculator &lt; input.vcf &gt; ld_matrix.txt\n</code></pre>"},{"location":"VCFX_ld_calculator/#region-specific-ld","title":"Region-Specific LD","text":"<p>Calculate LD only for variants in a specific genomic region:</p> <pre><code>VCFX_ld_calculator --region chr1:10000-20000 &lt; input.vcf &gt; ld_matrix.txt\n</code></pre>"},{"location":"VCFX_ld_calculator/#integration-with-other-tools","title":"Integration with Other Tools","text":"<p>Filter for common variants first, then calculate LD:</p> <pre><code>cat input.vcf | VCFX_af_subsetter --af-filter '0.05-1.0' | VCFX_ld_calculator &gt; common_variants_ld.txt\n</code></pre>"},{"location":"VCFX_ld_calculator/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Missing Genotypes: Samples with missing genotypes (./.  or .|.) are skipped when calculating LD between variant pairs</li> <li>Multi-allelic Variants: Genotypes involving alleles beyond the reference and first alternate (e.g., 1/2, 2/2) are treated as missing data</li> <li>Single Variant: If only one variant is found in the region, the tool outputs a message stating that no pairwise LD can be calculated</li> <li>Empty Region: If no variants are found in the specified region, the tool outputs a message stating that no pairwise LD can be calculated</li> <li>Invalid Region Format: If the region format is invalid, the tool will display an error message</li> </ul>"},{"location":"VCFX_ld_calculator/#performance","title":"Performance","text":"<ul> <li>Time complexity is O(n\u00b2m) where n is the number of variants and m is the number of samples</li> <li>Memory usage scales linearly with the number of variants and samples</li> <li>For large datasets with many variants, consider using the <code>--region</code> option to limit the analysis to specific genomic regions</li> <li>The tool processes the VCF file line by line, so it can handle large files without loading the entire file into memory</li> </ul>"},{"location":"VCFX_ld_calculator/#limitations","title":"Limitations","text":"<ul> <li>Only supports biallelic variants; multi-allelic variants are treated as missing data</li> <li>Requires diploid genotypes; haploid genotypes will be treated as missing data</li> <li>Assumes standard VCF format with GT field in the FORMAT column</li> <li>Does not support phased vs. unphased distinction; both \"/\" and \"|\" separators are treated the same</li> <li>No built-in visualization of LD patterns; additional tools would be needed for heatmap creation </li> </ul>"},{"location":"VCFX_merger/","title":"VCFX_merger","text":""},{"location":"VCFX_merger/#overview","title":"Overview","text":"<p><code>VCFX_merger</code> is a tool for merging multiple VCF files by variant position. It combines multiple VCF files while maintaining proper sorting by chromosome and position, and preserves the VCF header information from the first input file.</p>"},{"location":"VCFX_merger/#usage","title":"Usage","text":"<pre><code>VCFX_merger --merge file1.vcf,file2.vcf,... [options] &gt; merged.vcf\n</code></pre>"},{"location":"VCFX_merger/#options","title":"Options","text":"Option Description <code>-m, --merge</code> Comma-separated list of VCF files to merge <code>-h, --help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_merger/#description","title":"Description","text":"<p><code>VCFX_merger</code> reads multiple VCF files and combines them into a single output file while:</p> <ol> <li>Preserving the VCF header information from the first input file</li> <li>Sorting all variants by chromosome and position</li> <li>Maintaining the original VCF format and field structure</li> <li>Handling multiple input files efficiently</li> </ol> <p>The tool processes the input files sequentially and merges all variants while ensuring proper sorting. It is particularly useful when you need to combine multiple VCF files from different sources or samples into a single, properly sorted VCF file.</p>"},{"location":"VCFX_merger/#input-requirements","title":"Input Requirements","text":"<ul> <li>All input files must be in valid VCF format</li> <li>Files should have consistent header structures</li> <li>The first file's header information will be used in the output</li> <li>Files can contain any number of variants</li> </ul>"},{"location":"VCFX_merger/#output-format","title":"Output Format","text":"<p>The output is a standard VCF file with: - Header information from the first input file - All variants sorted by chromosome and position - Original VCF format preserved - Tab-delimited fields maintained</p>"},{"location":"VCFX_merger/#examples","title":"Examples","text":""},{"location":"VCFX_merger/#basic-usage","title":"Basic Usage","text":"<p>Merge two VCF files:</p> <pre><code>VCFX_merger --merge sample1.vcf,sample2.vcf &gt; merged.vcf\n</code></pre>"},{"location":"VCFX_merger/#multiple-files","title":"Multiple Files","text":"<p>Merge three or more VCF files:</p> <pre><code>VCFX_merger --merge file1.vcf,file2.vcf,file3.vcf &gt; combined.vcf\n</code></pre>"},{"location":"VCFX_merger/#integration-with-other-tools","title":"Integration with Other Tools","text":"<p>Merge files and then process the result:</p> <pre><code>VCFX_merger --merge sample1.vcf,sample2.vcf | VCFX_sorter | VCFX_validator &gt; final.vcf\n</code></pre>"},{"location":"VCFX_merger/#error-handling","title":"Error Handling","text":"<p>The tool handles various error conditions:</p> <ul> <li>Missing input files: Reports an error if any specified input file cannot be opened</li> <li>Invalid VCF format: Preserves the original format but does not validate it</li> <li>Empty files: Handles empty input files gracefully</li> <li>Missing --merge argument: Displays help message</li> </ul>"},{"location":"VCFX_merger/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Memory usage scales with the number of variants across all input files</li> <li>Processing time depends on the total number of variants and the number of input files</li> <li>Files are processed sequentially to minimize memory usage</li> <li>Sorting is performed in memory after all variants are collected</li> </ul>"},{"location":"VCFX_merger/#limitations","title":"Limitations","text":"<ul> <li>Only supports standard VCF format files</li> <li>Does not perform VCF validation (use VCFX_validator for validation)</li> <li>Preserves only the header information from the first input file</li> <li>Requires all input files to have consistent field structures</li> </ul>"},{"location":"VCFX_merger/#common-use-cases","title":"Common Use Cases","text":"<ol> <li>Combining multiple sample VCFs into a single file</li> <li>Merging region-specific VCF files</li> <li>Combining results from different variant callers</li> <li>Creating a unified VCF file from multiple analysis runs</li> </ol>"},{"location":"VCFX_merger/#best-practices","title":"Best Practices","text":"<ol> <li>Validate input files before merging</li> <li>Use consistent VCF versions across input files</li> <li>Consider file sizes and available memory when merging many files</li> <li>Verify the output with VCFX_validator after merging</li> <li>Use VCFX_sorter if additional sorting is needed </li> </ol>"},{"location":"VCFX_metadata_summarizer/","title":"VCFX_metadata_summarizer","text":""},{"location":"VCFX_metadata_summarizer/#overview","title":"Overview","text":"<p><code>VCFX_metadata_summarizer</code> is a tool that analyzes and summarizes key metadata from a VCF file. It provides a comprehensive overview of the file's structure, including counts of contigs, INFO fields, FILTER fields, FORMAT fields, samples, and variants.</p>"},{"location":"VCFX_metadata_summarizer/#usage","title":"Usage","text":"<pre><code>VCFX_metadata_summarizer [options] &lt; input.vcf\n</code></pre>"},{"location":"VCFX_metadata_summarizer/#options","title":"Options","text":"Option Description <code>-h, --help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_metadata_summarizer/#description","title":"Description","text":"<p><code>VCFX_metadata_summarizer</code> reads a VCF file and generates a summary of its key structural elements:</p> <ol> <li>Counts unique contigs defined in the header</li> <li>Counts unique INFO fields</li> <li>Counts unique FILTER fields</li> <li>Counts unique FORMAT fields</li> <li>Counts the number of samples</li> <li>Counts the total number of variants</li> </ol> <p>The tool processes the VCF file line by line, parsing both header metadata and variant records to build a complete summary of the file's structure.</p>"},{"location":"VCFX_metadata_summarizer/#input-requirements","title":"Input Requirements","text":"<ul> <li>Input must be a valid VCF file</li> <li>File can be piped through stdin</li> <li>Supports both VCFv4.0 and VCFv4.2 formats</li> <li>Handles both single-sample and multi-sample VCFs</li> </ul>"},{"location":"VCFX_metadata_summarizer/#output-format","title":"Output Format","text":"<p>The output is a formatted text summary with the following structure:</p> <pre><code>VCF Metadata Summary:\n---------------------\nNumber of unique contigs: &lt;count&gt;\nNumber of unique INFO fields: &lt;count&gt;\nNumber of unique FILTER fields: &lt;count&gt;\nNumber of unique FORMAT fields: &lt;count&gt;\nNumber of samples: &lt;count&gt;\nNumber of variants: &lt;count&gt;\n</code></pre>"},{"location":"VCFX_metadata_summarizer/#examples","title":"Examples","text":""},{"location":"VCFX_metadata_summarizer/#basic-usage","title":"Basic Usage","text":"<p>Summarize metadata from a VCF file:</p> <pre><code>VCFX_metadata_summarizer &lt; input.vcf\n</code></pre>"},{"location":"VCFX_metadata_summarizer/#integration-with-other-tools","title":"Integration with Other Tools","text":"<p>Combine with other VCFX tools:</p> <pre><code>cat input.vcf | VCFX_validator | VCFX_metadata_summarizer\n</code></pre>"},{"location":"VCFX_metadata_summarizer/#example-output","title":"Example Output","text":"<p>For a minimal VCF file with one contig, one INFO field, and a single variant:</p> <pre><code>VCF Metadata Summary:\n---------------------\nNumber of unique contigs: 1\nNumber of unique INFO fields: 1\nNumber of unique FILTER fields: 0\nNumber of unique FORMAT fields: 0\nNumber of samples: 0\nNumber of variants: 1\n</code></pre>"},{"location":"VCFX_metadata_summarizer/#header-parsing","title":"Header Parsing","text":"<p>The tool parses the following types of header lines: - <code>##contig=&lt;ID=...&gt;</code> - Contig definitions - <code>##INFO=&lt;ID=...&gt;</code> - INFO field definitions - <code>##FILTER=&lt;ID=...&gt;</code> - FILTER field definitions - <code>##FORMAT=&lt;ID=...&gt;</code> - FORMAT field definitions - <code>#CHROM...</code> - Column header line (for sample counting)</p>"},{"location":"VCFX_metadata_summarizer/#error-handling","title":"Error Handling","text":"<p>The tool handles various input scenarios: - Empty files - Files with no header - Files with no variants - Files with missing metadata fields - Files with inconsistent header structures</p>"},{"location":"VCFX_metadata_summarizer/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Processes input streamingly</li> <li>Memory usage scales with the number of unique metadata fields</li> <li>Efficient for both small and large VCF files</li> <li>No need to load entire file into memory</li> </ul>"},{"location":"VCFX_metadata_summarizer/#limitations","title":"Limitations","text":"<ul> <li>Only counts presence of fields, not their values</li> <li>Does not validate field definitions</li> <li>Does not check for field consistency across variants</li> <li>Does not analyze variant content beyond counting</li> </ul>"},{"location":"VCFX_metadata_summarizer/#common-use-cases","title":"Common Use Cases","text":"<ol> <li>Quick assessment of VCF file structure</li> <li>Quality control of VCF file completeness</li> <li>Verification of expected metadata presence</li> <li>Sample count verification</li> <li>Variant count verification</li> </ol>"},{"location":"VCFX_metadata_summarizer/#best-practices","title":"Best Practices","text":"<ol> <li>Run on VCF files before processing</li> <li>Use in combination with VCFX_validator</li> <li>Check for expected field counts</li> <li>Verify sample counts match expectations</li> <li>Use as part of quality control pipelines </li> </ol>"},{"location":"VCFX_missing_data_handler/","title":"VCFX_missing_data_handler","text":""},{"location":"VCFX_missing_data_handler/#overview","title":"Overview","text":"<p>VCFX_missing_data_handler identifies and processes missing genotype data in VCF files. It can either flag missing genotypes (default behavior) or impute them with a specified default value, ensuring consistent data representation for downstream analysis.</p>"},{"location":"VCFX_missing_data_handler/#usage","title":"Usage","text":"<pre><code>VCFX_missing_data_handler [OPTIONS] [files...] &gt; processed.vcf\n</code></pre>"},{"location":"VCFX_missing_data_handler/#options","title":"Options","text":"Option Description <code>--fill-missing</code>, <code>-f</code> Impute missing genotypes with a default value <code>--default-genotype</code>, <code>-d</code> Specify the default genotype for imputation (default: \"./.\") <code>--help</code>, <code>-h</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_missing_data_handler/#description","title":"Description","text":"<p>VCFX_missing_data_handler processes VCF files to identify and handle missing genotype data. The tool:</p> <ol> <li>Reads one or more VCF files (or standard input if no files specified)</li> <li>Identifies missing genotypes in each variant (empty, \".\", \"./.\", or \".|.\")</li> <li>Either:</li> <li>Leaves missing genotypes unchanged (default behavior)</li> <li>Replaces missing genotypes with a user-specified value</li> <li>Outputs the processed VCF data to standard output</li> </ol> <p>This tool is particularly useful for: - Preparing VCF files for tools that don't handle missing genotypes well - Standardizing the representation of missing data - Imputing missing genotypes with reference (0/0) or other default values - Processing multiple VCF files with consistent handling of missing data</p>"},{"location":"VCFX_missing_data_handler/#output-format","title":"Output Format","text":"<p>The output is a valid VCF file with the same format as the input, but with missing genotypes either left as-is or replaced with the specified default value. All header lines are preserved.</p>"},{"location":"VCFX_missing_data_handler/#examples","title":"Examples","text":""},{"location":"VCFX_missing_data_handler/#basic-usage-flag-only","title":"Basic Usage (Flag Only)","text":"<pre><code># Process a single file, leaving missing genotypes as-is\nVCFX_missing_data_handler &lt; input.vcf &gt; flagged_output.vcf\n</code></pre>"},{"location":"VCFX_missing_data_handler/#impute-missing-data-with-default-value","title":"Impute Missing Data with Default Value","text":"<pre><code># Replace missing genotypes with the default value (./.):\nVCFX_missing_data_handler --fill-missing &lt; input.vcf &gt; imputed_output.vcf\n</code></pre>"},{"location":"VCFX_missing_data_handler/#impute-with-custom-genotype","title":"Impute with Custom Genotype","text":"<pre><code># Replace missing genotypes with homozygous reference (0/0):\nVCFX_missing_data_handler --fill-missing --default-genotype \"0/0\" &lt; input.vcf &gt; ref_imputed.vcf\n</code></pre>"},{"location":"VCFX_missing_data_handler/#process-multiple-files","title":"Process Multiple Files","text":"<pre><code># Process multiple files at once:\nVCFX_missing_data_handler --fill-missing file1.vcf file2.vcf &gt; combined_output.vcf\n</code></pre>"},{"location":"VCFX_missing_data_handler/#in-a-pipeline","title":"In a Pipeline","text":"<pre><code># Filter a VCF file and then handle missing data:\ngrep -v \"^#\" input.vcf | grep \"PASS\" | \\\nVCFX_missing_data_handler --fill-missing --default-genotype \"0/0\" &gt; filtered_imputed.vcf\n</code></pre>"},{"location":"VCFX_missing_data_handler/#missing-genotype-detection","title":"Missing Genotype Detection","text":"<p>The tool identifies the following representations of missing data:</p> <ol> <li>Empty genotype field</li> <li>Single dot: \".\"</li> <li>Pair of dots with slash: \"./.\"</li> <li>Pair of dots with pipe: \".|.\"</li> </ol>"},{"location":"VCFX_missing_data_handler/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>No GT field in FORMAT: If the FORMAT column does not include a GT field, the variant line is left unchanged</li> <li>Invalid variant lines: Lines with fewer than 9 columns are passed through unchanged</li> <li>Multiple input files: Processes each file in sequence, properly handling headers</li> <li>Sample columns structure: Carefully preserves the structure of sample columns, only modifying the GT field</li> <li>Empty lines: Preserved with a single newline</li> <li>Header lines: Passed through unchanged</li> <li>Data before header: Able to handle invalid VCF files where data appears before the header (with a warning)</li> </ul>"},{"location":"VCFX_missing_data_handler/#performance","title":"Performance","text":"<p>The tool is designed for efficiency:</p> <ol> <li>Line-by-line processing allows handling of arbitrarily large files</li> <li>No need to load the entire file into memory</li> <li>Efficient string splitting and joining operations</li> <li>Handles multiple files in a single run</li> </ol>"},{"location":"VCFX_missing_data_handler/#limitations","title":"Limitations","text":"<ol> <li>No option to specify which samples should have their missing data imputed</li> <li>Cannot handle phased vs. unphased genotype distinction in imputation</li> <li>No support for probabilistic imputation based on population frequencies</li> <li>No ability to flag sites with a high proportion of missing data</li> <li>Cannot process only specific regions of a VCF file</li> <li>Imputes with the same value regardless of context or neighboring genotypes</li> <li>No reporting of the number or percentage of imputed genotypes </li> </ol>"},{"location":"VCFX_missing_detector/","title":"VCFX_missing_detector","text":""},{"location":"VCFX_missing_detector/#overview","title":"Overview","text":"<p>VCFX_missing_detector identifies and flags variants in a VCF file that contain missing genotype data in any sample. This tool helps researchers identify potentially problematic variants or samples with incomplete data that may require special handling in downstream analyses.</p>"},{"location":"VCFX_missing_detector/#usage","title":"Usage","text":"<pre><code>VCFX_missing_detector [OPTIONS] &lt; input.vcf &gt; flagged.vcf\n</code></pre>"},{"location":"VCFX_missing_detector/#options","title":"Options","text":"Option Description <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_missing_detector/#description","title":"Description","text":"<p>VCFX_missing_detector analyzes a VCF file to identify variants with missing genotype data. The tool:</p> <ol> <li>Reads a VCF file from standard input line by line</li> <li>For each variant, examines the genotype (GT) field of all samples</li> <li>Identifies missing genotypes where:</li> <li>The entire genotype is missing (e.g., <code>./.</code>, <code>.|.</code>, or <code>.</code>)</li> <li>Either allele in a diploid genotype is missing (e.g., <code>./0</code>, <code>1/.</code>)</li> <li>Adds a flag <code>MISSING_GENOTYPES=1</code> to the INFO field of variants with any missing data</li> <li>Writes the processed VCF to standard output</li> </ol> <p>This simple annotation allows researchers to easily: - Filter variants based on missing data presence using standard VCF tools - Identify data completeness issues that might affect analysis results - Implement different handling strategies for variants with missing data</p>"},{"location":"VCFX_missing_detector/#output-format","title":"Output Format","text":"<p>The output is a valid VCF file with the same format as the input, but with an additional INFO field annotation for variants containing missing genotypes:</p> <pre><code>MISSING_GENOTYPES=1\n</code></pre> <p>This annotation is appended to the existing INFO field, or replaces the <code>.</code> placeholder if the INFO field is empty.</p>"},{"location":"VCFX_missing_detector/#examples","title":"Examples","text":""},{"location":"VCFX_missing_detector/#basic-usage","title":"Basic Usage","text":"<pre><code># Flag variants with missing genotypes\n./VCFX_missing_detector &lt; input.vcf &gt; flagged.vcf\n</code></pre>"},{"location":"VCFX_missing_detector/#in-a-pipeline-with-filtering","title":"In a Pipeline with Filtering","text":"<pre><code># Flag variants with missing genotypes, then filter to keep only complete variants\n./VCFX_missing_detector &lt; input.vcf | grep -v \"MISSING_GENOTYPES=1\" &gt; complete_variants.vcf\n</code></pre>"},{"location":"VCFX_missing_detector/#counting-missing-variants","title":"Counting Missing Variants","text":"<pre><code># Count variants with missing genotypes\n./VCFX_missing_detector &lt; input.vcf | grep \"MISSING_GENOTYPES=1\" | wc -l\n</code></pre>"},{"location":"VCFX_missing_detector/#counting-all-variants-before-summary","title":"Counting All Variants Before Summary","text":"<pre><code># Count total variants and those with missing data\n./VCFX_missing_detector &lt; input.vcf &gt; flagged.vcf\necho \"Total variants: $(grep -v \"^#\" flagged.vcf | wc -l)\"\necho \"Variants with missing data: $(grep \"MISSING_GENOTYPES=1\" flagged.vcf | wc -l)\"\n</code></pre>"},{"location":"VCFX_missing_detector/#missing-genotype-detection","title":"Missing Genotype Detection","text":"<p>The tool uses comprehensive logic to identify various forms of missing genotype data:</p> <ol> <li>Completely missing genotypes: Formats like <code>./.</code>, <code>.|.</code>, or just <code>.</code></li> <li>Partially missing diploid genotypes: When one allele is missing, like <code>./1</code> or <code>0/.</code></li> <li>Multi-field format handling: Properly extracts just the GT portion when other fields (like DP, GQ) are present</li> <li>Format field awareness: Correctly identifies the GT position in the FORMAT string</li> </ol> <p>The tool examines each sample column independently and flags a variant if any sample has missing data.</p>"},{"location":"VCFX_missing_detector/#handling-special-cases","title":"Handling Special Cases","text":"<p>The tool implements several strategies for handling edge cases:</p> <ol> <li>Missing FORMAT field: If GT is not included in the FORMAT column, the variant is passed through unchanged</li> <li>No sample columns: Variants with fewer than 9 columns are passed through unchanged</li> <li>Empty INFO field: If the original INFO is \".\" (missing), it's replaced with \"MISSING_GENOTYPES=1\"</li> <li>Non-empty INFO field: The missing flag is appended with a semicolon separator</li> <li>Empty lines: Preserved with a single newline</li> <li>Header lines: Passed through unchanged</li> <li>Non-diploid genotypes: The tool focuses on diploid genotypes with a single delimiter ('/' or '|')</li> </ol>"},{"location":"VCFX_missing_detector/#performance","title":"Performance","text":"<p>VCFX_missing_detector is designed for efficiency:</p> <ol> <li>Single-pass processing with O(n) time complexity where n is the number of variants</li> <li>Minimal memory usage, with no requirement to load the entire file</li> <li>String operations optimized for performance</li> <li>Line-by-line processing enabling streaming workflow</li> <li>Disk I/O limited only to reading input and writing output</li> </ol>"},{"location":"VCFX_missing_detector/#limitations","title":"Limitations","text":"<ol> <li>Primarily designed for diploid genotypes; may not correctly identify missing data in haploid or polyploid contexts</li> <li>Limited to checking the GT field; does not evaluate other potential indicators of missing data</li> <li>No built-in functionality to annotate the percentage or count of samples with missing data</li> <li>No option to customize the INFO field tag name from the default \"MISSING_GENOTYPES\"</li> <li>Cannot perform sample-specific missing data analysis, such as identifying which samples contribute most to missingness</li> <li>No threshold options (e.g., flag only if more than X% of samples have missing data)</li> <li>Limited to binary detection (missing/not missing) without quantifying the degree of missingness </li> </ol>"},{"location":"VCFX_multiallelic_splitter/","title":"VCFX_multiallelic_splitter","text":""},{"location":"VCFX_multiallelic_splitter/#overview","title":"Overview","text":"<p>VCFX_multiallelic_splitter takes a VCF file with multi-allelic variants (variants with multiple ALT alleles) and splits them into multiple bi-allelic variant lines, while properly handling genotypes and FORMAT/INFO fields with various number specifications.</p>"},{"location":"VCFX_multiallelic_splitter/#usage","title":"Usage","text":"<pre><code>VCFX_multiallelic_splitter [OPTIONS] &lt; input.vcf &gt; biallelic_output.vcf\n</code></pre>"},{"location":"VCFX_multiallelic_splitter/#options","title":"Options","text":"Option Description <code>--help</code>, <code>-h</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_multiallelic_splitter/#description","title":"Description","text":"<p>Multi-allelic variants in VCF files (where multiple alternate alleles are specified in a comma-separated list) can complicate analysis and be incompatible with tools that require bi-allelic variants. This tool converts multi-allelic variants into the equivalent set of bi-allelic variants.</p> <p>Key features: - Maintains original VCF header information - Correctly processes INFO fields tagged with different Number attributes (A, R, G) - Properly adjusts genotypes and FORMAT fields for each resulting bi-allelic variant - Preserves phasing information in genotypes - Handles complex symbolic variants (e.g., <code>&lt;DEL&gt;</code>, <code>&lt;INS&gt;</code>) - Correctly manages missing or malformed fields</p>"},{"location":"VCFX_multiallelic_splitter/#output-format","title":"Output Format","text":"<p>The output is a standard VCF file containing: - All header lines from the input file (unchanged) - Bi-allelic variants only, with each multi-allelic variant split into multiple lines - Each split variant maintains the same CHROM, POS, ID, REF, QUAL, and FILTER values - INFO and FORMAT fields properly adjusted for each alternate allele</p>"},{"location":"VCFX_multiallelic_splitter/#examples","title":"Examples","text":""},{"location":"VCFX_multiallelic_splitter/#basic-usage","title":"Basic Usage","text":"<pre><code>./VCFX_multiallelic_splitter &lt; multi_allelic.vcf &gt; biallelic.vcf\n</code></pre>"},{"location":"VCFX_multiallelic_splitter/#integration-with-other-tools","title":"Integration with Other Tools","text":"<pre><code># Split multi-allelic variants, then run analysis requiring bi-allelic variants\ncat input.vcf | \\\n  ./VCFX_multiallelic_splitter | \\\n  ./vcf_analysis_tool &gt; results.txt\n</code></pre>"},{"location":"VCFX_multiallelic_splitter/#validation","title":"Validation","text":"<pre><code># Validate that all variants in the output are indeed bi-allelic\n./VCFX_multiallelic_splitter &lt; input.vcf | \\\n  grep -v \"^#\" | awk -F'\\t' '{print $5}' | grep -c \",\"\n# Should output 0 if all variants are bi-allelic\n</code></pre>"},{"location":"VCFX_multiallelic_splitter/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>INFO fields: </li> <li>Number=A fields (one value per alternate allele): Each split variant gets the corresponding value</li> <li>Number=R fields (one value per allele including reference): Values are preserved properly</li> <li>Number=G fields (one value per genotype): Recalculated for bi-allelic case</li> <li> <p>Number=1 or other fixed numbers: These values are copied unchanged</p> </li> <li> <p>FORMAT fields: </p> </li> <li>AD (allelic depth): Properly subset for each resulting variant</li> <li>PL (genotype likelihoods): Recalculated for each bi-allelic output</li> <li> <p>GT (genotype): Adjusted to reflect the new allele indices (0/2 may become 0/1 in split variant)</p> </li> <li> <p>Genotype conversion: </p> </li> <li>For each variant, genotypes are only preserved if they involve the specific alt allele</li> <li>Genotypes not involving the current alternate allele are set to missing (./.)</li> <li> <p>Phased genotypes maintain their phase information</p> </li> <li> <p>Edge cases:</p> </li> <li>Missing data in FORMAT fields is properly handled</li> <li>Symbolic alternate alleles are processed correctly</li> <li>Star alleles (*) and non-ref symbolic alleles are supported</li> </ul>"},{"location":"VCFX_multiallelic_splitter/#performance","title":"Performance","text":"<p>The tool processes VCF files line by line with minimal memory requirements, with performance primarily dependent on: - Number of samples in the VCF - Number of multi-allelic sites - Complexity of INFO and FORMAT fields</p> <p>For very large VCF files with many samples, processing time scales linearly with file size.</p>"},{"location":"VCFX_multiallelic_splitter/#limitations","title":"Limitations","text":"<ul> <li>No command-line options to control the splitting behavior</li> <li>Cannot selectively split only certain multi-allelic variants</li> <li>May produce large output files when the input contains many multi-allelic variants with many samples</li> <li>Cannot reconstruct the original multi-allelic variants from the split output in all cases </li> </ul>"},{"location":"VCFX_nonref_filter/","title":"VCFX_nonref_filter","text":""},{"location":"VCFX_nonref_filter/#overview","title":"Overview","text":"<p>VCFX_nonref_filter removes variants from a VCF file where all samples are homozygous reference (0/0), retaining only variants where at least one sample has an alternate allele or a missing genotype.</p>"},{"location":"VCFX_nonref_filter/#usage","title":"Usage","text":"<pre><code>VCFX_nonref_filter [OPTIONS] &lt; input.vcf &gt; filtered.vcf\n</code></pre>"},{"location":"VCFX_nonref_filter/#options","title":"Options","text":"Option Description <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_nonref_filter/#description","title":"Description","text":"<p>VCFX_nonref_filter examines each variant in a VCF file and filters out those where all samples are homozygous reference (0/0). The tool:</p> <ol> <li>Processes a VCF file line by line</li> <li>For each variant, examines the genotype (GT) field of all samples</li> <li>Determines if every sample is definitively homozygous reference</li> <li>Retains variants where at least one sample has a non-reference allele or missing data</li> <li>Outputs a filtered VCF with only the retained variants</li> <li>Passes through all header lines unchanged</li> </ol> <p>This tool is particularly useful for: - Removing uninformative variants where no sample has an alternate allele - Reducing VCF file size by filtering out invariant sites - Focusing analysis on polymorphic sites - Preparing variant files for downstream analysis tools that expect polymorphic sites</p>"},{"location":"VCFX_nonref_filter/#output-format","title":"Output Format","text":"<p>The output is a standard VCF file with the same format as the input, but containing only variants where at least one sample has a non-reference allele or a missing genotype. All header lines are preserved.</p>"},{"location":"VCFX_nonref_filter/#examples","title":"Examples","text":""},{"location":"VCFX_nonref_filter/#basic-usage","title":"Basic Usage","text":"<pre><code># Filter out variants where all samples are homozygous reference\nVCFX_nonref_filter &lt; input.vcf &gt; filtered.vcf\n</code></pre>"},{"location":"VCFX_nonref_filter/#counting-filtered-variants","title":"Counting Filtered Variants","text":"<pre><code># Count how many variants were removed/retained\ninput_count=$(grep -v \"^#\" input.vcf | wc -l)\noutput_count=$(grep -v \"^#\" filtered.vcf | wc -l)\nremoved_count=$((input_count - output_count))\necho \"Removed $removed_count homozygous reference variants out of $input_count total variants\"\n</code></pre>"},{"location":"VCFX_nonref_filter/#in-a-pipeline","title":"In a Pipeline","text":"<pre><code># Filter VCF file first by quality, then by non-reference status\ngrep -v \"^#\" input.vcf | grep \"PASS\" | \\\nVCFX_nonref_filter &gt; high_quality_nonref.vcf\n</code></pre>"},{"location":"VCFX_nonref_filter/#combining-with-other-filters","title":"Combining with Other Filters","text":"<pre><code># Create a pipeline of filters\ncat input.vcf | \\\nVCFX_nonref_filter | \\\nVCFX_phred_filter --phred-filter 30 &gt; filtered.vcf\n</code></pre>"},{"location":"VCFX_nonref_filter/#homozygous-reference-detection","title":"Homozygous Reference Detection","text":"<p>The tool uses comprehensive logic to identify homozygous reference genotypes:</p> <ol> <li>If a genotype is missing (e.g., \"./.\", \".|.\", or \".\"), it's considered NOT homozygous reference, and the variant is retained</li> <li>For each specified allele in a genotype:</li> <li>The allele must be \"0\" for it to be considered reference</li> <li>Any non-\"0\" allele (including \"1\", \"2\", etc.) is considered alternate</li> </ol> <p>For example: - \"0/0\" \u2192 Homozygous reference (filtered if all samples have this) - \"0/1\" \u2192 Heterozygous (variant retained) - \"1/1\" \u2192 Homozygous alternate (variant retained) - \"./.\" \u2192 Missing genotype (variant retained) - \"0/.\" \u2192 Partially missing (variant retained) - \"0/0/0\" \u2192 Polyploid homozygous reference (filtered if all samples have reference)</p>"},{"location":"VCFX_nonref_filter/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Missing genotypes: Variants with samples having missing genotypes (\"./.\") are retained</li> <li>Partial missing: Genotypes with some missing alleles (e.g., \"0/.\") are considered not definitively homozygous reference, so the variant is retained</li> <li>No GT field: If the GT field is not present in the FORMAT column, the variant is retained</li> <li>Empty lines: Skipped in output</li> <li>Header lines: Preserved unchanged</li> <li>Malformed VCF lines: Lines with fewer than 10 columns (required for at least one sample) are passed through unchanged</li> <li>Data before header: Warning issued and lines passed through unchanged</li> </ul>"},{"location":"VCFX_nonref_filter/#performance","title":"Performance","text":"<p>The tool is designed for efficiency:</p> <ol> <li>Processes the VCF file line by line, with minimal memory requirements</li> <li>Fast determination of homozygous reference status using string parsing</li> <li>Early exit when a non-homozygous sample is found</li> <li>No requirements to load the entire file into memory</li> </ol>"},{"location":"VCFX_nonref_filter/#limitations","title":"Limitations","text":"<ol> <li>No option to filter based on a subset of samples</li> <li>Cannot retain specific homozygous reference variants based on other criteria</li> <li>No support for filtering by percentage of non-reference samples</li> <li>Missing data is always treated as \"not definitely homozygous reference\"</li> <li>No built-in option to keep variants where the reference allele might be incorrect</li> <li>Cannot incorporate quality values in the filtering decision</li> <li>No reporting on the number of variants removed or statistics about filtered variants </li> </ol>"},{"location":"VCFX_outlier_detector/","title":"VCFX_outlier_detector","text":""},{"location":"VCFX_outlier_detector/#overview","title":"Overview","text":"<p>VCFX_outlier_detector identifies outliers in VCF data based on numeric metrics, operating in two modes: variant mode to detect outlier variants exceeding a threshold for a specified INFO field, and sample mode to identify samples with average metrics above a threshold.</p>"},{"location":"VCFX_outlier_detector/#usage","title":"Usage","text":"<pre><code>VCFX_outlier_detector --metric &lt;KEY&gt; --threshold &lt;VAL&gt; [--variant|--sample] &lt; input.vcf &gt; outliers.txt\n</code></pre>"},{"location":"VCFX_outlier_detector/#options","title":"Options","text":"Option Description <code>--metric</code>, <code>-m</code> Name of the metric to use (e.g., AF, DP, GQ) <code>--threshold</code>, <code>-t</code> Numeric threshold value for outlier detection <code>--variant</code>, <code>-V</code> Variant mode: identify variants with INFO field metrics above threshold <code>--sample</code>, <code>-s</code> Sample mode: identify samples with average genotype metrics above threshold <code>--help</code>, <code>-h</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>) <p>Note: <code>-v</code> shows the version information. Use <code>--variant</code> or the short option <code>-V</code> to run in variant mode.</p>"},{"location":"VCFX_outlier_detector/#description","title":"Description","text":"<p>VCFX_outlier_detector analyzes VCF files to identify outliers based on numeric metrics. The tool operates in two distinct modes:</p> <ol> <li>Variant Mode (default): </li> <li>Examines each variant's specified INFO field metric</li> <li>Reports variants where the metric exceeds the specified threshold</li> <li> <p>Useful for finding variants with unusual characteristics (e.g., high allele frequency, depth)</p> </li> <li> <p>Sample Mode:</p> </li> <li>Calculates the average value of a specified genotype metric for each sample</li> <li>Reports samples where the average metric exceeds the specified threshold</li> <li>Useful for identifying samples with unusual quality characteristics</li> </ol> <p>The tool processes VCF files line by line, extracting the relevant metric from either the INFO field (variant mode) or the FORMAT/genotype fields (sample mode). For sample mode, it accumulates values across all variants to calculate the per-sample averages.</p>"},{"location":"VCFX_outlier_detector/#output-format","title":"Output Format","text":""},{"location":"VCFX_outlier_detector/#variant-mode","title":"Variant Mode","text":"<p>The output is a tab-delimited file with the following columns: <pre><code>#CHROM  POS  ID  METRIC\n</code></pre> Where: - CHROM, POS, ID: Standard VCF fields for variant identification - METRIC: The value of the specified metric for each outlier variant</p>"},{"location":"VCFX_outlier_detector/#sample-mode","title":"Sample Mode","text":"<p>The output is a tab-delimited file with the following columns: <pre><code>#Sample  Average_METRIC\n</code></pre> Where: - Sample: The sample name - Average_METRIC: The average value of the metric across all variants (or \"NA\" if below threshold)</p>"},{"location":"VCFX_outlier_detector/#examples","title":"Examples","text":""},{"location":"VCFX_outlier_detector/#identify-variants-with-high-allele-frequency","title":"Identify Variants with High Allele Frequency","text":"<pre><code># Find variants with allele frequency &gt; 0.05\nVCFX_outlier_detector --metric AF --threshold 0.05 --variant &lt; input.vcf &gt; high_af_variants.txt\n</code></pre>"},{"location":"VCFX_outlier_detector/#identify-low-quality-samples","title":"Identify Low-Quality Samples","text":"<pre><code># Find samples with average genotype quality &gt; 30\nVCFX_outlier_detector --metric GQ --threshold 30 --sample &lt; input.vcf &gt; high_quality_samples.txt\n</code></pre>"},{"location":"VCFX_outlier_detector/#detect-unusual-depth-variants","title":"Detect Unusual Depth Variants","text":"<pre><code># Find variants with unusually high depth\nVCFX_outlier_detector --metric DP --threshold 100 --variant &lt; input.vcf &gt; high_depth_variants.txt\n</code></pre>"},{"location":"VCFX_outlier_detector/#identify-samples-with-high-missing-rate","title":"Identify Samples with High Missing Rate","text":"<pre><code># Find samples with high average missing rate\nVCFX_outlier_detector --metric MISSING --threshold 0.2 --sample &lt; input.vcf &gt; high_missing_samples.txt\n</code></pre>"},{"location":"VCFX_outlier_detector/#metric-extraction","title":"Metric Extraction","text":"<p>The tool implements two strategies for extracting metrics:</p> <ol> <li>INFO field parsing (variant mode):</li> <li>Extracts fields with format <code>KEY=VALUE</code> from the INFO column</li> <li> <p>Converts the value to a numeric type for comparison</p> </li> <li> <p>Genotype field parsing (sample mode):</p> </li> <li>First checks if the metric is directly specified with <code>KEY=VALUE</code> in the genotype field</li> <li>Otherwise, locates the metric position in the FORMAT field and extracts the corresponding value for each sample</li> </ol>"},{"location":"VCFX_outlier_detector/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Missing values: In sample mode, metrics that can't be parsed or are missing are skipped in the average calculation</li> <li>Invalid numeric values: Non-numeric values are ignored with appropriate warnings</li> <li>Empty files: Properly handled, producing an appropriate output header</li> <li>Malformed VCF lines: Lines with too few columns are skipped</li> <li>Non-standard FORMAT fields: Both standard colon-delimited formats and custom KEY=VALUE formats are supported</li> <li>No matching metrics: If no instances of the metric are found, a warning is issued</li> </ul>"},{"location":"VCFX_outlier_detector/#performance","title":"Performance","text":"<p>VCFX_outlier_detector is designed for efficiency:</p> <ol> <li>Variant Mode: </li> <li>Single pass through the file with O(n) time complexity where n is the number of variants</li> <li> <p>Minimal memory usage, regardless of file size</p> </li> <li> <p>Sample Mode:</p> </li> <li>Requires a single pass but tracks running sums and counts for each sample</li> <li>Memory usage scales with the number of samples, not the number of variants</li> </ol>"},{"location":"VCFX_outlier_detector/#limitations","title":"Limitations","text":"<ol> <li>Only supports thresholding in one direction (greater than threshold)</li> <li>No support for statistical outlier detection (e.g., z-scores or percentile-based methods)</li> <li>Cannot filter based on multiple metrics in a single run</li> <li>Sample mode requires the entire file to be processed before producing output</li> <li>No built-in options for handling multi-allelic sites differently</li> <li>Cannot detect outliers based on metadata not present in the VCF file</li> <li>Only numeric metrics are supported; cannot detect categorical outliers </li> </ol>"},{"location":"VCFX_phase_checker/","title":"VCFX_phase_checker","text":""},{"location":"VCFX_phase_checker/#overview","title":"Overview","text":"<p>The VCFX_phase_checker tool filters a VCF file to retain only those variant lines where all sample genotypes are fully phased (using the pipe '|' phasing separator). This is particularly useful for downstream analyses that require complete phasing information.</p>"},{"location":"VCFX_phase_checker/#usage","title":"Usage","text":"<pre><code>VCFX_phase_checker [OPTIONS] &lt; input.vcf &gt; phased_output.vcf\n</code></pre>"},{"location":"VCFX_phase_checker/#options","title":"Options","text":"Option Description <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_phase_checker/#description","title":"Description","text":"<p>VCFX_phase_checker reads a VCF file from standard input and examines the GT (genotype) field for every sample in each variant line. It determines whether each genotype is fully phased using the following criteria:</p> <ul> <li>A genotype is considered fully phased only if:</li> <li>It uses the pipe character '|' as the separator between alleles (e.g., \"0|1\")</li> <li>It contains no missing alleles (no \".\")</li> <li>It contains no unphased separators (\"/\")</li> </ul> <p>The tool outputs only those variant lines where all sample genotypes meet these criteria. Lines that don't meet these criteria are skipped, and warnings are written to standard error.</p>"},{"location":"VCFX_phase_checker/#output","title":"Output","text":"<p>The output is a valid VCF file containing: - All header lines from the input file (unchanged) - Only the variant lines where all samples have fully phased genotypes - Warnings (to stderr) for each line that was skipped due to unphased genotypes</p>"},{"location":"VCFX_phase_checker/#examples","title":"Examples","text":""},{"location":"VCFX_phase_checker/#basic-usage","title":"Basic Usage","text":"<pre><code>./VCFX_phase_checker &lt; input.vcf &gt; phased_output.vcf\n</code></pre>"},{"location":"VCFX_phase_checker/#capturing-warnings","title":"Capturing Warnings","text":"<pre><code>./VCFX_phase_checker &lt; input.vcf &gt; phased_output.vcf 2&gt; unphased_warnings.log\n</code></pre>"},{"location":"VCFX_phase_checker/#counting-phased-vs-unphased-variants","title":"Counting Phased vs. Unphased Variants","text":"<pre><code># Count total variants\ntotal=$(grep -v \"^#\" input.vcf | wc -l)\n# Count phased variants\nphased=$(./VCFX_phase_checker &lt; input.vcf | grep -v \"^#\" | wc -l)\n# Calculate percentage\necho \"Phased variants: $phased / $total ($(echo \"scale=2; 100*$phased/$total\" | bc)%)\"\n</code></pre>"},{"location":"VCFX_phase_checker/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Haploid genotypes (e.g., \"0\" or \"1\"): These are not considered phased; the line will be skipped</li> <li>Missing genotypes (e.g., \"./.\" or \".|.\"): These are not considered phased; the line will be skipped</li> <li>Missing GT field: Lines without a GT field in the FORMAT column are skipped with a warning</li> <li>Multiallelic variants: These are treated the same as biallelic variants, as long as all alleles are phased</li> <li>Non-VCF-compliant genotype notation: Any genotype that doesn't follow standard VCF format is not considered phased</li> <li>Header lines: All header lines (starting with \"#\") are preserved in the output</li> <li>Samples with different ploidy levels: Each sample is checked independently; if all are phased, the line is kept</li> </ul>"},{"location":"VCFX_phase_checker/#performance","title":"Performance","text":"<p>The tool processes files line by line with minimal memory requirements, allowing it to handle very large VCF files efficiently.</p>"},{"location":"VCFX_phase_checker/#limitations","title":"Limitations","text":"<ul> <li>No option to make a best-effort phasing assumption</li> <li>Cannot output partially phased lines or filter specific samples</li> <li>Designed to be used as part of a pipeline, not as a standalone phasing tool </li> </ul>"},{"location":"VCFX_phase_quality_filter/","title":"VCFX_phase_quality_filter","text":""},{"location":"VCFX_phase_quality_filter/#overview","title":"Overview","text":"<p><code>VCFX_phase_quality_filter</code> is a tool for filtering variants based on their phasing quality (PQ) scores in the INFO field. It allows users to specify custom conditions for filtering variants based on their PQ values, supporting various comparison operators.</p>"},{"location":"VCFX_phase_quality_filter/#usage","title":"Usage","text":"<pre><code>VCFX_phase_quality_filter --filter-pq \"PQ&lt;OP&gt;&lt;THRESHOLD&gt;\" &lt; input.vcf &gt; output.vcf\n</code></pre>"},{"location":"VCFX_phase_quality_filter/#options","title":"Options","text":"Option Description <code>-h, --help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-f, --filter-pq</code> Condition like 'PQ&gt;30', 'PQ&gt;=20', 'PQ!=10', etc."},{"location":"VCFX_phase_quality_filter/#description","title":"Description","text":"<p><code>VCFX_phase_quality_filter</code> reads a VCF file and filters variants based on their phasing quality scores:</p> <ol> <li>Extracts the PQ value from the INFO field of each variant</li> <li>Applies the specified comparison condition to the PQ value</li> <li>Keeps variants that satisfy the condition</li> <li>Discards variants that don't meet the criteria</li> </ol> <p>The tool handles missing or invalid PQ values by treating them as 0.0, ensuring robust processing of incomplete data.</p>"},{"location":"VCFX_phase_quality_filter/#input-requirements","title":"Input Requirements","text":"<ul> <li>Input must be a valid VCF file</li> <li>File can be piped through stdin</li> <li>PQ values should be present in the INFO field (optional)</li> <li>Supports both VCFv4.0 and VCFv4.2 formats</li> </ul>"},{"location":"VCFX_phase_quality_filter/#output-format","title":"Output Format","text":"<p>The output is a VCF file containing only the variants that satisfy the specified PQ condition: - Preserves all header lines - Maintains original VCF format - Includes only passing variants - Preserves all fields and annotations</p>"},{"location":"VCFX_phase_quality_filter/#examples","title":"Examples","text":""},{"location":"VCFX_phase_quality_filter/#basic-usage","title":"Basic Usage","text":"<p>Filter variants with PQ &gt; 30:</p> <pre><code>VCFX_phase_quality_filter --filter-pq \"PQ&gt;30\" &lt; input.vcf &gt; high_pq.vcf\n</code></pre>"},{"location":"VCFX_phase_quality_filter/#different-operators","title":"Different Operators","text":"<p>Various comparison operators are supported:</p> <pre><code># Keep variants with PQ &gt;= 20\nVCFX_phase_quality_filter --filter-pq \"PQ&gt;=20\" &lt; input.vcf &gt; pq_ge_20.vcf\n\n# Keep variants with PQ &lt;= 15\nVCFX_phase_quality_filter --filter-pq \"PQ&lt;=15\" &lt; input.vcf &gt; pq_le_15.vcf\n\n# Keep variants with PQ != 10\nVCFX_phase_quality_filter --filter-pq \"PQ!=10\" &lt; input.vcf &gt; pq_ne_10.vcf\n</code></pre>"},{"location":"VCFX_phase_quality_filter/#integration-with-other-tools","title":"Integration with Other Tools","text":"<p>Combine with other VCFX tools:</p> <pre><code>cat input.vcf | \\\n  VCFX_validator | \\\n  VCFX_phase_quality_filter --filter-pq \"PQ&gt;30\" | \\\n  VCFX_metadata_summarizer\n</code></pre>"},{"location":"VCFX_phase_quality_filter/#supported-operators","title":"Supported Operators","text":"<p>The tool supports the following comparison operators: - <code>&gt;</code> - Greater than - <code>&gt;=</code> - Greater than or equal to - <code>&lt;</code> - Less than - <code>&lt;=</code> - Less than or equal to - <code>==</code> - Equal to - <code>!=</code> - Not equal to</p>"},{"location":"VCFX_phase_quality_filter/#pq-value-handling","title":"PQ Value Handling","text":"<p>The tool handles PQ values in the following ways: - Extracts PQ values from INFO field (e.g., \"PQ=30\") - Treats missing PQ values as 0.0 - Handles invalid PQ values gracefully - Supports decimal values</p>"},{"location":"VCFX_phase_quality_filter/#error-handling","title":"Error Handling","text":"<p>The tool handles various error conditions: - Missing --filter-pq argument - Invalid condition syntax - Malformed VCF lines - Missing or invalid PQ values - Invalid comparison operators</p>"},{"location":"VCFX_phase_quality_filter/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Processes input streamingly</li> <li>Minimal memory usage</li> <li>Efficient for both small and large VCF files</li> <li>No need to load entire file into memory</li> </ul>"},{"location":"VCFX_phase_quality_filter/#limitations","title":"Limitations","text":"<ul> <li>Only filters based on PQ values</li> <li>Does not modify PQ values</li> <li>Does not validate VCF format (use VCFX_validator for validation)</li> <li>Treats missing PQ values as 0.0</li> </ul>"},{"location":"VCFX_phase_quality_filter/#common-use-cases","title":"Common Use Cases","text":"<ol> <li>Filtering low-quality phasing results</li> <li>Quality control of phased variants</li> <li>Selecting high-confidence phased variants</li> <li>Removing poorly phased variants</li> <li>Quality-based subsetting of phased data</li> </ol>"},{"location":"VCFX_phase_quality_filter/#best-practices","title":"Best Practices","text":"<ol> <li>Validate input VCF before filtering</li> <li>Use appropriate PQ thresholds based on your data</li> <li>Consider missing PQ values in your analysis</li> <li>Combine with other quality filters</li> <li>Document your filtering criteria </li> </ol>"},{"location":"VCFX_phred_filter/","title":"VCFX_phred_filter","text":""},{"location":"VCFX_phred_filter/#overview","title":"Overview","text":"<p>VCFX_phred_filter filters a VCF file based on the PHRED quality scores (QUAL column), removing variants that fall below a specified quality threshold to focus analysis on higher confidence variant calls.</p>"},{"location":"VCFX_phred_filter/#usage","title":"Usage","text":"<pre><code>VCFX_phred_filter [OPTIONS] &lt; input.vcf &gt; filtered.vcf\n</code></pre>"},{"location":"VCFX_phred_filter/#options","title":"Options","text":"Option Description <code>-p</code>, <code>--phred-filter</code> Set PHRED quality score threshold (default: 30.0) <code>-k</code>, <code>--keep-missing-qual</code> Keep variants with missing quality values (represented as \".\") <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_phred_filter/#description","title":"Description","text":"<p>VCFX_phred_filter examines the QUAL column of each variant record in a VCF file and filters out variants with quality scores below a specified threshold. The tool:</p> <ol> <li>Processes a VCF file line by line</li> <li>Extracts the PHRED quality score from the QUAL column (position 6) of each variant</li> <li>Compares the quality score against the specified threshold</li> <li>Retains variants where the quality meets or exceeds the threshold</li> <li>Passes through all header lines unchanged</li> </ol> <p>This tool is particularly useful for: - Removing low-confidence variant calls for downstream analysis - Quality control of variant data - Reducing false positives in variant datasets - Applying consistent quality standards across multiple VCF files</p>"},{"location":"VCFX_phred_filter/#output-format","title":"Output Format","text":"<p>The output is a standard VCF file with the same format as the input, but containing only variants with PHRED quality scores at or above the specified threshold. All header lines are preserved.</p>"},{"location":"VCFX_phred_filter/#examples","title":"Examples","text":""},{"location":"VCFX_phred_filter/#basic-usage-with-default-threshold","title":"Basic Usage with Default Threshold","text":"<pre><code># Filter variants using the default quality threshold (30)\nVCFX_phred_filter &lt; input.vcf &gt; filtered.vcf\n</code></pre>"},{"location":"VCFX_phred_filter/#setting-a-custom-threshold","title":"Setting a Custom Threshold","text":"<pre><code># Keep only variants with quality scores of 20 or higher\nVCFX_phred_filter -p 20 &lt; input.vcf &gt; q20_filtered.vcf\n</code></pre>"},{"location":"VCFX_phred_filter/#keeping-variants-with-missing-quality","title":"Keeping Variants with Missing Quality","text":"<pre><code># Keep variants with quality \u2265 30 or missing quality values\nVCFX_phred_filter -p 30 -k &lt; input.vcf &gt; high_quality_with_missing.vcf\n</code></pre>"},{"location":"VCFX_phred_filter/#in-a-pipeline","title":"In a Pipeline","text":"<pre><code># Combine with other filters in a pipeline\ncat input.vcf | \\\nVCFX_phred_filter -p 40 | \\\ngrep \"PASS\" &gt; high_quality_pass.vcf\n</code></pre>"},{"location":"VCFX_phred_filter/#using-long-option-format","title":"Using Long Option Format","text":"<pre><code># Using long options for clarity\nVCFX_phred_filter --phred-filter 25 --keep-missing-qual &lt; input.vcf &gt; filtered.vcf\n</code></pre>"},{"location":"VCFX_phred_filter/#quality-score-handling","title":"Quality Score Handling","text":"<p>The tool processes quality scores as follows:</p> <ol> <li>Standard numeric values: Directly compared to the threshold</li> <li>Missing quality values (represented as \".\"): </li> <li>By default, treated as 0.0 (filtered out)</li> <li>With the <code>-k</code> option, treated as extremely high (effectively infinity) to ensure they pass</li> <li>Invalid quality values: Logged with a warning and treated as 0.0 (filtered out)</li> </ol>"},{"location":"VCFX_phred_filter/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Missing quality values: Can be retained with the <code>-k</code> option</li> <li>Invalid quality formats: Treated as 0.0 with a warning</li> <li>Empty lines: Preserved with a single newline</li> <li>Header lines: Preserved unchanged</li> <li>Malformed VCF lines: Lines with fewer than 6 columns are skipped with a warning</li> <li>Data before header: Skipped with a warning</li> </ul>"},{"location":"VCFX_phred_filter/#performance","title":"Performance","text":"<p>The tool is designed for efficiency:</p> <ol> <li>Processes VCF files line by line, with minimal memory requirements</li> <li>Simple numeric comparison for fast filtering decisions</li> <li>No requirement to load the entire file into memory</li> <li>Fast string parsing for quality values</li> </ol>"},{"location":"VCFX_phred_filter/#limitations","title":"Limitations","text":"<ol> <li>Focuses only on the QUAL column, not on per-sample or per-genotype quality metrics</li> <li>No support for filtering based on other quality-related fields (e.g., GQ in the genotype fields)</li> <li>Cannot apply different thresholds to different variant types</li> <li>No option to exclude variants based on upper quality bounds</li> <li>Doesn't provide statistics on filtered variants</li> <li>Cannot filter based on multiple quality metrics simultaneously</li> <li>Lacks region-specific filtering capabilities </li> </ol>"},{"location":"VCFX_population_filter/","title":"VCFX_population_filter","text":""},{"location":"VCFX_population_filter/#overview","title":"Overview","text":"<p><code>VCFX_population_filter</code> is a utility tool for subsetting VCF files to include only samples belonging to a specified population. It filters out samples that don't belong to the chosen population group while preserving the variant data and format information.</p>"},{"location":"VCFX_population_filter/#usage","title":"Usage","text":"<pre><code>VCFX_population_filter [OPTIONS] &lt; input.vcf &gt; output.vcf\n</code></pre>"},{"location":"VCFX_population_filter/#options","title":"Options","text":"Option Description <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-p</code>, <code>--population &lt;TAG&gt;</code> Required: Population tag to keep (e.g., 'EUR', 'AFR', 'EAS') <code>-m</code>, <code>--pop-map &lt;FILE&gt;</code> Required: Tab-delimited file mapping sample names to populations"},{"location":"VCFX_population_filter/#description","title":"Description","text":"<p><code>VCFX_population_filter</code> processes a VCF file to create a population-specific subset by:</p> <ol> <li>Reading a population map file that associates each sample with a population</li> <li>Identifying samples that belong to the specified population</li> <li>Reading the VCF file from standard input</li> <li>Preserving all meta-information lines (starting with '##') without modification</li> <li>Modifying the #CHROM header line to include only samples from the specified population</li> <li>For each data line:</li> <li>Keeping the first 9 mandatory columns (CHROM, POS, ID, REF, ALT, QUAL, FILTER, INFO, FORMAT)</li> <li>Including only genotype columns for samples from the specified population</li> <li>Writing the filtered VCF to standard output</li> </ol> <p>This tool is particularly useful for: - Creating population-specific VCF files for population genetics analysis - Reducing file size by excluding irrelevant samples - Focusing on specific ancestral groups for targeted studies - Preparing data for population-stratified association studies</p>"},{"location":"VCFX_population_filter/#population-map-format","title":"Population Map Format","text":"<p>The population map file should be a simple tab-delimited text file with: - Each line containing a sample name and its population designation - The first column containing the exact sample name as it appears in the VCF header - The second column containing the population identifier - No header row (just data rows)</p> <p>Example population map file: <pre><code>SAMPLE1  EUR\nSAMPLE2  EUR\nSAMPLE3  AFR\nSAMPLE4  AFR\nSAMPLE5  EAS\n</code></pre></p>"},{"location":"VCFX_population_filter/#examples","title":"Examples","text":""},{"location":"VCFX_population_filter/#basic-usage","title":"Basic Usage","text":"<p>Filter a VCF file to include only European (EUR) samples: <pre><code>VCFX_population_filter --population EUR --pop-map population_map.txt &lt; input.vcf &gt; eur_only.vcf\n</code></pre></p>"},{"location":"VCFX_population_filter/#different-populations","title":"Different Populations","text":"<p>Create separate files for different populations: <pre><code>VCFX_population_filter --population AFR --pop-map population_map.txt &lt; input.vcf &gt; afr_only.vcf\nVCFX_population_filter --population EAS --pop-map population_map.txt &lt; input.vcf &gt; eas_only.vcf\n</code></pre></p>"},{"location":"VCFX_population_filter/#example-transformations","title":"Example Transformations","text":""},{"location":"VCFX_population_filter/#input-vcf-with-multiple-populations","title":"Input VCF (with multiple populations)","text":"<pre><code>##fileformat=VCFv4.2\n#CHROM  POS  ID  REF  ALT  QUAL  FILTER  INFO  FORMAT  SAMPLE1_EUR  SAMPLE2_EUR  SAMPLE3_AFR  SAMPLE4_AFR  SAMPLE5_EAS\n1  100  rs123  A  T  50  PASS  AF=0.1  GT:DP  0|0:30  0|1:25  1|1:20  0|1:22  0|0:18\n</code></pre>"},{"location":"VCFX_population_filter/#output-vcf-filtered-for-eur","title":"Output VCF (filtered for EUR)","text":"<pre><code>##fileformat=VCFv4.2\n#CHROM  POS  ID  REF  ALT  QUAL  FILTER  INFO  FORMAT  SAMPLE1_EUR  SAMPLE2_EUR\n1  100  rs123  A  T  50  PASS  AF=0.1  GT:DP  0|0:30  0|1:25\n</code></pre>"},{"location":"VCFX_population_filter/#special-case-handling","title":"Special Case Handling","text":""},{"location":"VCFX_population_filter/#missing-samples","title":"Missing Samples","text":"<ul> <li>If no samples match the specified population, a warning is issued</li> <li>The output VCF will contain only the first 9 mandatory columns without any sample data</li> </ul>"},{"location":"VCFX_population_filter/#malformed-lines","title":"Malformed Lines","text":"<ul> <li>Lines with fewer than 9 columns are skipped with a warning</li> <li>Data lines encountered before the #CHROM header are skipped with a warning</li> </ul>"},{"location":"VCFX_population_filter/#missing-chrom-header","title":"Missing #CHROM Header","text":"<ul> <li>If no #CHROM header is found in the file, an error is reported</li> </ul>"},{"location":"VCFX_population_filter/#invalid-population-map","title":"Invalid Population Map","text":"<ul> <li>If the population map file cannot be opened, an error is reported</li> <li>Lines in the population map that don't follow the expected format are skipped with a warning</li> </ul>"},{"location":"VCFX_population_filter/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>The tool processes the VCF file line by line, with minimal memory requirements</li> <li>Memory usage is primarily determined by the number of samples in the VCF file</li> <li>Performance scales linearly with the size of the input file</li> <li>No external dependencies or reference files are required beyond the population map</li> </ul>"},{"location":"VCFX_population_filter/#limitations","title":"Limitations","text":"<ul> <li>Cannot filter variants based on population-specific criteria</li> <li>Does not update INFO fields like AC/AN to reflect the reduced sample set</li> <li>No support for more complex population filtering (e.g., including multiple populations)</li> <li>Cannot handle compressed (gzipped) VCF files directly</li> <li>Does not validate sample consistency between the VCF and the population map </li> </ul>"},{"location":"VCFX_position_subsetter/","title":"VCFX_position_subsetter","text":""},{"location":"VCFX_position_subsetter/#overview","title":"Overview","text":"<p><code>VCFX_position_subsetter</code> extracts variants from a VCF file that fall within a specified genomic region, allowing for targeted analysis of specific chromosomal segments.</p>"},{"location":"VCFX_position_subsetter/#usage","title":"Usage","text":"<pre><code>VCFX_position_subsetter --region \"CHR:START-END\" &lt; input.vcf &gt; filtered.vcf\n</code></pre>"},{"location":"VCFX_position_subsetter/#options","title":"Options","text":"Option Description <code>-r</code>, <code>--region &lt;CHR:START-END&gt;</code> Required. Genomic region to extract in the format \"chromosome:start-end\" <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_position_subsetter/#description","title":"Description","text":"<p><code>VCFX_position_subsetter</code> reads a VCF file from standard input and outputs only those variants that fall within the specified genomic region. The tool:</p> <ol> <li>Processes a VCF file line by line</li> <li>Extracts the chromosome and position from each variant</li> <li>Compares them to the user-specified region</li> <li>Retains variants where:</li> <li>The chromosome matches exactly with the specified chromosome</li> <li>The position falls within the specified start and end coordinates (inclusive)</li> <li>Outputs all header lines unchanged</li> <li>Outputs only variant lines that meet the criteria</li> </ol> <p>This tool is particularly useful for: - Focusing analysis on specific genomic regions of interest - Extracting variants in a gene or regulatory region - Reducing file size by narrowing down to relevant regions - Preparing data for local analysis or visualization</p>"},{"location":"VCFX_position_subsetter/#output-format","title":"Output Format","text":"<p>The output is a standard VCF file containing: - All original header lines from the input VCF - Only the variant records that fall within the specified region - The same format and structure as the original VCF</p>"},{"location":"VCFX_position_subsetter/#examples","title":"Examples","text":""},{"location":"VCFX_position_subsetter/#basic-usage","title":"Basic Usage","text":"<p>Extract variants on chromosome 1 between positions 1,000,000 and 2,000,000: <pre><code>VCFX_position_subsetter --region \"chr1:1000000-2000000\" &lt; input.vcf &gt; chr1_region.vcf\n</code></pre></p>"},{"location":"VCFX_position_subsetter/#small-region","title":"Small Region","text":"<p>Extract variants in a small region, such as a specific exon: <pre><code>VCFX_position_subsetter --region \"chr17:41245000-41245500\" &lt; input.vcf &gt; brca1_exon.vcf\n</code></pre></p>"},{"location":"VCFX_position_subsetter/#different-chromosome-format","title":"Different Chromosome Format","text":"<p>Extract variants using a different chromosome naming format (numeric): <pre><code>VCFX_position_subsetter --region \"2:150000-250000\" &lt; input.vcf &gt; chr2_region.vcf\n</code></pre></p>"},{"location":"VCFX_position_subsetter/#pipeline-integration","title":"Pipeline Integration","text":"<p>Use as part of a longer analysis pipeline: <pre><code>cat input.vcf | VCFX_position_subsetter --region \"chrX:5000000-6000000\" | another_tool &gt; final_output.vcf\n</code></pre></p>"},{"location":"VCFX_position_subsetter/#region-parsing","title":"Region Parsing","text":""},{"location":"VCFX_position_subsetter/#format-requirements","title":"Format Requirements","text":"<p>The region must be specified in the format \"CHR:START-END\" where: - CHR is the chromosome name, exactly as it appears in the VCF - START is the beginning position (inclusive) - END is the ending position (inclusive) - The colon and dash are required separators</p> <p>For example: <code>chr1:10000-20000</code>, <code>X:50000-100000</code>, <code>22:30500000-31000000</code></p>"},{"location":"VCFX_position_subsetter/#coordinate-system","title":"Coordinate System","text":"<p>The position coordinates use the same 1-based system as VCF files, where the first base of a chromosome is position 1.</p>"},{"location":"VCFX_position_subsetter/#handling-special-cases","title":"Handling Special Cases","text":""},{"location":"VCFX_position_subsetter/#empty-results","title":"Empty Results","text":"<p>If no variants in the input VCF fall within the specified region, the output will contain only the header lines.</p>"},{"location":"VCFX_position_subsetter/#non-existent-chromosome","title":"Non-Existent Chromosome","text":"<p>If the specified chromosome does not exist in the input VCF, the output will contain only header lines.</p>"},{"location":"VCFX_position_subsetter/#invalid-region-format","title":"Invalid Region Format","text":"<p>If the region is not properly formatted (missing colon, missing dash, or end smaller than start), an error is reported and no filtering is performed.</p>"},{"location":"VCFX_position_subsetter/#malformed-lines","title":"Malformed Lines","text":"<ul> <li>Lines with fewer than 2 columns are skipped with a warning</li> <li>Lines where the position cannot be parsed as an integer are skipped with a warning</li> <li>Data lines encountered before the #CHROM header are skipped with a warning</li> </ul>"},{"location":"VCFX_position_subsetter/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Processes the VCF file line by line, with minimal memory requirements</li> <li>No preprocessing or indexing is done</li> <li>Performance scales linearly with input file size</li> <li>More efficient for small regions in large files compared to manually parsing</li> </ul>"},{"location":"VCFX_position_subsetter/#limitations","title":"Limitations","text":"<ul> <li>Can only extract one continuous region at a time</li> <li>No support for multiple regions in a single run</li> <li>Cannot extract by gene name or other genomic features directly</li> <li>Requires exact chromosome name matching</li> <li>No special handling of complex structural variants that may span region boundaries </li> </ul>"},{"location":"VCFX_probability_filter/","title":"VCFX_probability_filter","text":""},{"location":"VCFX_probability_filter/#overview","title":"Overview","text":"<p><code>VCFX_probability_filter</code> filters a VCF file based on specified genotype probability values. It allows you to keep only variants where samples meet certain probability thresholds, using various comparison operators.</p>"},{"location":"VCFX_probability_filter/#usage","title":"Usage","text":"<pre><code>VCFX_probability_filter --filter-probability \"&lt;CONDITION&gt;\" &lt; input.vcf &gt; filtered.vcf\n</code></pre>"},{"location":"VCFX_probability_filter/#options","title":"Options","text":"Option Description <code>-f, --filter-probability &lt;condition&gt;</code> Specify the probability filter condition (e.g., <code>GP&gt;0.9</code>) <code>-h, --help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_probability_filter/#description","title":"Description","text":"<p><code>VCFX_probability_filter</code> analyzes the genotype probability fields in the FORMAT column of a VCF file and filters variants based on a user-defined condition. The tool:</p> <ol> <li>Reads the VCF file line by line from standard input</li> <li>Parses the specified condition (e.g., <code>GP&gt;0.9</code>)</li> <li>For each variant, examines the probability values in the specified field</li> <li>Keeps variants where all samples meet the condition</li> <li>Outputs the filtered variants to standard output</li> </ol> <p>The condition must be specified in the format <code>FIELD OPERATOR VALUE</code>, where: - <code>FIELD</code> is a valid field in the FORMAT column (e.g., <code>GP</code> for genotype probabilities) - <code>OPERATOR</code> is one of: <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code> - <code>VALUE</code> is a numeric threshold</p>"},{"location":"VCFX_probability_filter/#output-format","title":"Output Format","text":"<p>The output is a standard VCF file with the same format as the input, but containing only variants that meet the specified probability condition. All header lines are preserved.</p>"},{"location":"VCFX_probability_filter/#examples","title":"Examples","text":""},{"location":"VCFX_probability_filter/#basic-filtering","title":"Basic Filtering","text":"<p>Filter for variants where all samples have a GP (genotype probability) value greater than 0.9: <pre><code>VCFX_probability_filter --filter-probability \"GP&gt;0.9\" &lt; input.vcf &gt; filtered.vcf\n</code></pre></p>"},{"location":"VCFX_probability_filter/#using-different-operators","title":"Using Different Operators","text":"<p>Filter for variants where all samples have a GP value less than 0.1: <pre><code>VCFX_probability_filter --filter-probability \"GP&lt;0.1\" &lt; input.vcf &gt; filtered.vcf\n</code></pre></p>"},{"location":"VCFX_probability_filter/#exact-match","title":"Exact Match","text":"<p>Filter for variants where all samples have a GP value exactly equal to 0.9: <pre><code>VCFX_probability_filter --filter-probability \"GP==0.9\" &lt; input.vcf &gt; filtered.vcf\n</code></pre></p>"},{"location":"VCFX_probability_filter/#different-probability-fields","title":"Different Probability Fields","text":"<p>Filter using a different probability field (e.g., <code>PP</code> for posterior probability): <pre><code>VCFX_probability_filter --filter-probability \"PP&gt;=0.8\" &lt; input.vcf &gt; filtered.vcf\n</code></pre></p>"},{"location":"VCFX_probability_filter/#in-a-pipeline","title":"In a Pipeline","text":"<p>Use as part of a processing pipeline: <pre><code>cat input.vcf | VCFX_probability_filter --filter-probability \"GP&gt;0.95\" | other_vcf_tool &gt; output.vcf\n</code></pre></p>"},{"location":"VCFX_probability_filter/#probability-value-handling","title":"Probability Value Handling","text":""},{"location":"VCFX_probability_filter/#field-parsing","title":"Field Parsing","text":"<p>The tool locates the specified probability field (e.g., <code>GP</code>) in the FORMAT column of each variant and extracts the corresponding values for each sample.</p>"},{"location":"VCFX_probability_filter/#value-comparison","title":"Value Comparison","text":"<p>The extracted probability values are compared to the specified threshold using the given operator. A variant passes the filter only if all samples meet the condition.</p>"},{"location":"VCFX_probability_filter/#multiple-probability-values","title":"Multiple Probability Values","text":"<p>If a field contains multiple values (e.g., <code>GP</code> often contains three values for a biallelic variant), the filter is applied to the first value that can be successfully extracted and converted to a number.</p>"},{"location":"VCFX_probability_filter/#handling-special-cases","title":"Handling Special Cases","text":""},{"location":"VCFX_probability_filter/#missing-values","title":"Missing Values","text":"<p>If a sample has a missing value (<code>.</code>) for the specified probability field, the variant is filtered out.</p>"},{"location":"VCFX_probability_filter/#malformed-values","title":"Malformed Values","text":"<p>If a probability value cannot be converted to a number, the variant is filtered out with a warning message.</p>"},{"location":"VCFX_probability_filter/#missing-fields","title":"Missing Fields","text":"<p>If the specified field is not found in the FORMAT column, the tool reports an error and exits.</p>"},{"location":"VCFX_probability_filter/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>The tool processes the VCF file line by line, requiring minimal memory.</li> <li>No sorting or indexing is performed, preserving the original order of variants.</li> <li>Time complexity is linear with respect to the size of the input file.</li> </ul>"},{"location":"VCFX_probability_filter/#limitations","title":"Limitations","text":"<ul> <li>The tool requires that the specified field exists in the FORMAT column of the VCF file.</li> <li>It only supports standard comparison operators and cannot handle complex conditions or multiple conditions.</li> <li>The tool does not handle cases where different samples might need different thresholds.</li> <li>Missing or malformed values cause the variant to be filtered out, which might not be desired in all cases. </li> </ul>"},{"location":"VCFX_quality_adjuster/","title":"VCFX_quality_adjuster","text":""},{"location":"VCFX_quality_adjuster/#overview","title":"Overview","text":"<p><code>VCFX_quality_adjuster</code> transforms the QUAL field values in a VCF file by applying mathematical functions such as logarithm, square root, or square. This tool is useful for scaling quality scores to make them more interpretable or to prepare them for downstream analysis.</p>"},{"location":"VCFX_quality_adjuster/#usage","title":"Usage","text":"<pre><code>VCFX_quality_adjuster [OPTIONS] &lt; input.vcf &gt; output.vcf\n</code></pre>"},{"location":"VCFX_quality_adjuster/#options","title":"Options","text":"Option Description <code>-a</code>, <code>--adjust-qual &lt;FUNC&gt;</code> Required. The transformation function to apply. Must be one of: <code>log</code>, <code>sqrt</code>, <code>square</code>, or <code>identity</code>. <code>-n</code>, <code>--no-clamp</code> Do not clamp negative or extremely large values resulting from transformations. <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_quality_adjuster/#description","title":"Description","text":"<p><code>VCFX_quality_adjuster</code> processes a VCF file line by line, applying a specified mathematical transformation to the QUAL field (6th column) of each variant record. The tool:</p> <ol> <li>Reads the VCF file from standard input.</li> <li>Identifies header lines (beginning with #) and passes them through unchanged.</li> <li>For data lines, extracts the QUAL value and applies the specified transformation.</li> <li>By default, clamps negative values to 0 and extremely large values to 10^12.</li> <li>Writes the modified VCF to standard output.</li> </ol>"},{"location":"VCFX_quality_adjuster/#supported-transformations","title":"Supported Transformations","text":"<ul> <li>log: Applies natural logarithm (ln) to the quality score. Small constant (10^-10) is added to prevent log(0).</li> <li>sqrt: Applies square root to the quality score. Negative values are treated as 0.</li> <li>square: Multiplies the quality score by itself.</li> <li>identity: No transformation, passes the quality score unchanged.</li> </ul>"},{"location":"VCFX_quality_adjuster/#output-format","title":"Output Format","text":"<p>The output is a VCF file with the same format as the input, but with transformed QUAL values. All other fields remain unchanged, maintaining full compatibility with standard VCF parsers and tools.</p>"},{"location":"VCFX_quality_adjuster/#examples","title":"Examples","text":""},{"location":"VCFX_quality_adjuster/#logarithmic-transformation","title":"Logarithmic Transformation","text":"<pre><code># Transform quality scores using natural logarithm\nVCFX_quality_adjuster --adjust-qual log &lt; input.vcf &gt; log_transformed.vcf\n</code></pre>"},{"location":"VCFX_quality_adjuster/#square-root-transformation","title":"Square Root Transformation","text":"<pre><code># Apply square root to quality scores\nVCFX_quality_adjuster --adjust-qual sqrt &lt; input.vcf &gt; sqrt_transformed.vcf\n</code></pre>"},{"location":"VCFX_quality_adjuster/#square-transformation-without-clamping","title":"Square Transformation without Clamping","text":"<pre><code># Square quality scores without clamping large values\nVCFX_quality_adjuster --adjust-qual square --no-clamp &lt; input.vcf &gt; squared_unclamped.vcf\n</code></pre>"},{"location":"VCFX_quality_adjuster/#in-a-pipeline","title":"In a Pipeline","text":"<pre><code># Filter variants and then transform quality scores\nVCFX_record_filter --quality \"&gt;20\" &lt; input.vcf | VCFX_quality_adjuster --adjust-qual log &gt; filtered_log_transformed.vcf\n</code></pre>"},{"location":"VCFX_quality_adjuster/#handling-special-cases","title":"Handling Special Cases","text":"<p>The tool implements several strategies for handling edge cases:</p> <ol> <li>Missing QUAL values: Fields marked with <code>.</code> or empty fields are treated as 0.</li> <li>Non-numeric QUAL values: Lines with non-numeric QUAL values generate a warning and are skipped.</li> <li>Negative results: By default, negative values resulting from transformations (e.g., log of a value &lt; 1) are clamped to 0. This behavior can be disabled with <code>--no-clamp</code>.</li> <li>Very large values: Values above 10^12 are clamped to prevent numerical issues. This behavior can be disabled with <code>--no-clamp</code>.</li> <li>Malformed lines: Lines with fewer than 8 fields generate a warning and are skipped.</li> <li>Empty lines: Empty lines are preserved in the output.</li> </ol>"},{"location":"VCFX_quality_adjuster/#performance","title":"Performance","text":"<p><code>VCFX_quality_adjuster</code> is designed to be efficient:</p> <ol> <li>It processes the VCF file in a single pass, requiring minimal memory footprint.</li> <li>All transformations are simple mathematical functions with constant-time complexity.</li> <li>The tool streams data directly from input to output without storing the entire file in memory.</li> </ol>"},{"location":"VCFX_quality_adjuster/#limitations","title":"Limitations","text":"<ol> <li>Only the QUAL field is transformed; other numeric fields (like INFO fields) remain unchanged.</li> <li>No facility to define custom transformation functions beyond the four built-in options.</li> <li>Cannot apply different transformations to different variants or regions in a single run.</li> <li>Lack of options for formatting the transformed values (e.g., number of decimal places).</li> <li>No built-in option to back-transform values to their original scale. </li> </ol>"},{"location":"VCFX_record_filter/","title":"VCFX_record_filter","text":""},{"location":"VCFX_record_filter/#overview","title":"Overview","text":"<p><code>VCFX_record_filter</code> filters VCF files based on flexible criteria applied to standard fields (POS, QUAL, FILTER) and INFO fields. It allows for complex filtering with multiple conditions using AND/OR logic.</p>"},{"location":"VCFX_record_filter/#usage","title":"Usage","text":"<pre><code>VCFX_record_filter --filter \"CRITERIA\" [OPTIONS] &lt; input.vcf &gt; filtered.vcf\n</code></pre>"},{"location":"VCFX_record_filter/#options","title":"Options","text":"Option Description <code>-f</code>, <code>--filter &lt;CRITERIA&gt;</code> Required. One or more filtering criteria separated by semicolons (e.g., <code>\"POS&gt;10000;QUAL&gt;=30;AF&lt;0.05\"</code>) <code>-l</code>, <code>--logic &lt;and\\|or&gt;</code> Logic for combining multiple criteria: <code>and</code> (default) requires all criteria to pass, <code>or</code> requires any criterion to pass <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_record_filter/#description","title":"Description","text":"<p><code>VCFX_record_filter</code> evaluates each variant in a VCF file against specified criteria and outputs only variants that satisfy these criteria. The tool:</p> <ol> <li>Reads a VCF file line by line from standard input</li> <li>Passes all header lines (starting with <code>#</code>) unchanged to the output</li> <li>For each data line, evaluates it against the specified criteria</li> <li>If the variant satisfies the criteria, writes it to standard output</li> <li>If the variant fails the criteria, discards it</li> </ol> <p>Criteria can be specified for: - Standard VCF fields: <code>POS</code> (numeric), <code>QUAL</code> (numeric), <code>FILTER</code> (string) - Any key in the INFO column (automatically detected as numeric or string)</p> <p>Each criterion must use one of the following operators: - Numeric comparisons: <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code> - String comparisons: <code>==</code>, <code>!=</code> (equality and inequality only)</p>"},{"location":"VCFX_record_filter/#output-format","title":"Output Format","text":"<p>The output is a standard VCF file with the same format as the input, but containing only variants that meet the specified filtering criteria. All header lines are preserved.</p>"},{"location":"VCFX_record_filter/#examples","title":"Examples","text":""},{"location":"VCFX_record_filter/#basic-filtering","title":"Basic Filtering","text":"<p>Filter variants by position: <pre><code>VCFX_record_filter --filter \"POS&gt;10000\" &lt; input.vcf &gt; filtered.vcf\n</code></pre></p>"},{"location":"VCFX_record_filter/#quality-filtering","title":"Quality Filtering","text":"<p>Filter variants with QUAL score at least 30: <pre><code>VCFX_record_filter --filter \"QUAL&gt;=30\" &lt; input.vcf &gt; filtered.vcf\n</code></pre></p>"},{"location":"VCFX_record_filter/#multiple-criteria-with-and-logic","title":"Multiple Criteria with AND Logic","text":"<p>Keep only variants that pass all criteria (default AND logic): <pre><code>VCFX_record_filter --filter \"POS&gt;=1000;FILTER==PASS;DP&gt;10\" &lt; input.vcf &gt; filtered.vcf\n</code></pre></p>"},{"location":"VCFX_record_filter/#multiple-criteria-with-or-logic","title":"Multiple Criteria with OR Logic","text":"<p>Keep variants that pass any of the criteria: <pre><code>VCFX_record_filter --filter \"AF&gt;0.1;DP&gt;100\" --logic or &lt; input.vcf &gt; filtered.vcf\n</code></pre></p>"},{"location":"VCFX_record_filter/#filtering-on-info-fields","title":"Filtering on INFO Fields","text":"<p>Filter based on allele frequency and depth: <pre><code>VCFX_record_filter --filter \"AF&lt;0.01;DP&gt;=50\" &lt; input.vcf &gt; rare_variants.vcf\n</code></pre></p>"},{"location":"VCFX_record_filter/#string-comparison","title":"String Comparison","text":"<p>Filter variants by FILTER status: <pre><code>VCFX_record_filter --filter \"FILTER==PASS\" &lt; input.vcf &gt; passing_variants.vcf\n</code></pre></p>"},{"location":"VCFX_record_filter/#criterion-parsing","title":"Criterion Parsing","text":""},{"location":"VCFX_record_filter/#field-types","title":"Field Types","text":"<p>The tool automatically determines field types: - <code>POS</code> and <code>QUAL</code> are always treated as numeric fields - <code>FILTER</code> is always treated as a string field - INFO fields are parsed as numeric if possible, otherwise as strings</p>"},{"location":"VCFX_record_filter/#numeric-values","title":"Numeric Values","text":"<p>For numeric fields, the value specified in the criterion is converted to a double and compared using the specified operator: <pre><code>QUAL&gt;=30  # Passes if QUAL is at least 30\nDP&gt;10     # Passes if DP INFO field is greater than 10\n</code></pre></p>"},{"location":"VCFX_record_filter/#string-values","title":"String Values","text":"<p>For string fields, only equality (<code>==</code>) and inequality (<code>!=</code>) operators are supported: <pre><code>FILTER==PASS     # Passes if FILTER is exactly \"PASS\"\nSVTYPE!=DEL      # Passes if SVTYPE INFO field is not \"DEL\"\n</code></pre></p>"},{"location":"VCFX_record_filter/#handling-special-cases","title":"Handling Special Cases","text":""},{"location":"VCFX_record_filter/#missing-values","title":"Missing Values","text":"<ul> <li>Missing <code>QUAL</code> values (<code>.</code>) are treated as 0.0</li> <li>Missing INFO fields cause the criterion to fail</li> <li>Empty fields are handled appropriately</li> </ul>"},{"location":"VCFX_record_filter/#multiple-criteria","title":"Multiple Criteria","text":"<ul> <li>With AND logic, a variant must pass ALL criteria to be included</li> <li>With OR logic, a variant passes if ANY criterion is satisfied</li> </ul>"},{"location":"VCFX_record_filter/#malformed-lines","title":"Malformed Lines","text":"<ul> <li>Lines with fewer than 8 columns are skipped</li> <li>Data lines before the <code>#CHROM</code> header are skipped with a warning</li> </ul>"},{"location":"VCFX_record_filter/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>The tool processes VCF files line by line, requiring minimal memory</li> <li>Each line is evaluated independently, allowing for efficient processing</li> <li>For large files with many criteria, using AND logic can be more efficient as it can short-circuit on the first failing criterion</li> </ul>"},{"location":"VCFX_record_filter/#limitations","title":"Limitations","text":"<ul> <li>String fields only support equality and inequality comparisons, not substring or pattern matching</li> <li>No built-in support for sample genotype filtering (focuses on variant-level data)</li> <li>Cannot filter based on the number of samples with a particular genotype</li> <li>No support for parentheses or complex boolean expressions beyond simple AND/OR logic</li> <li>INFO flags (without values) are treated as having a value of 1.0 for numeric comparisons </li> </ul>"},{"location":"VCFX_ref_comparator/","title":"VCFX_ref_comparator","text":""},{"location":"VCFX_ref_comparator/#overview","title":"Overview","text":"<p>VCFX_ref_comparator validates VCF variant records by comparing their REF and ALT alleles against a reference genome FASTA file, helping to identify discrepancies and annotate variants with their relation to the reference sequence.</p>"},{"location":"VCFX_ref_comparator/#usage","title":"Usage","text":"<pre><code>VCFX_ref_comparator --reference &lt;reference.fasta&gt; &lt; input.vcf &gt; annotated.vcf\n</code></pre>"},{"location":"VCFX_ref_comparator/#options","title":"Options","text":"Option Description <code>-r</code>, <code>--reference</code> Required. Path to reference genome in FASTA format <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_ref_comparator/#description","title":"Description","text":"<p>VCFX_ref_comparator analyzes VCF variants by comparing them to a reference genome. The tool:</p> <ol> <li>Loads a reference genome from a specified FASTA file</li> <li>Processes each variant in the input VCF file</li> <li>For each variant, compares the REF field with the corresponding sequence in the reference genome</li> <li>Also determines if each ALT allele matches the reference sequence</li> <li>Annotates each variant with a <code>REF_COMPARISON</code> tag in the INFO field, indicating the result of the comparison</li> <li>Outputs an annotated VCF with all original fields preserved</li> </ol> <p>This tool is particularly useful for: - Validating the accuracy of variant calls - Identifying potential errors in variant representation - Distinguishing true variants from reference matching records - Quality control of variant datasets</p>"},{"location":"VCFX_ref_comparator/#output-format","title":"Output Format","text":"<p>The output is a valid VCF file with the same format as the input, but with an additional <code>REF_COMPARISON</code> field added to the INFO column of each variant line. The output also includes a new header line defining the <code>REF_COMPARISON</code> INFO field.</p> <p>The <code>REF_COMPARISON</code> field can have the following values: - <code>REF_MISMATCH</code>: The REF allele does not match the reference genome - <code>REF_MATCH</code>: The REF allele matches the reference genome - <code>NOVEL</code>: The variant's ALT allele differs from the reference sequence - <code>ALT_IS_REF</code>: The ALT allele matches the reference sequence (potential reference/alternate swap) - <code>UNKNOWN_CHROM</code>: The chromosome is not found in the reference genome - <code>INVALID_POS</code>: The position is out of bounds for the chromosome</p>"},{"location":"VCFX_ref_comparator/#examples","title":"Examples","text":""},{"location":"VCFX_ref_comparator/#basic-usage","title":"Basic Usage","text":"<pre><code># Compare variants against a reference genome\nVCFX_ref_comparator --reference genome.fa &lt; input.vcf &gt; validated.vcf\n</code></pre>"},{"location":"VCFX_ref_comparator/#filtering-for-reference-mismatches","title":"Filtering for Reference Mismatches","text":"<pre><code># Find variants where the REF allele doesn't match the reference genome\nVCFX_ref_comparator --reference genome.fa &lt; input.vcf | grep \"REF_MISMATCH\" &gt; mismatches.vcf\n</code></pre>"},{"location":"VCFX_ref_comparator/#identifying-alt-alleles-that-match-reference","title":"Identifying ALT Alleles that Match Reference","text":"<pre><code># Find variants where the ALT allele actually matches the reference\nVCFX_ref_comparator --reference genome.fa &lt; input.vcf | grep \"ALT_IS_REF\" &gt; potential_swaps.vcf\n</code></pre>"},{"location":"VCFX_ref_comparator/#checking-for-invalid-coordinates","title":"Checking for Invalid Coordinates","text":"<pre><code># Identify variants with invalid chromosomes or positions\nVCFX_ref_comparator --reference genome.fa &lt; input.vcf | grep -E \"UNKNOWN_CHROM|INVALID_POS\" &gt; invalid_coords.vcf\n</code></pre>"},{"location":"VCFX_ref_comparator/#reference-comparison-process","title":"Reference Comparison Process","text":"<p>The tool performs these steps for each variant:</p> <ol> <li>Checks if the variant's chromosome exists in the reference genome</li> <li>Verifies that the position is valid within the chromosome's sequence</li> <li>Extracts the reference sequence at the specified position, matching the length of the REF allele</li> <li>Compares the extracted sequence with the REF allele</li> <li>For each ALT allele, determines if it matches the reference sequence</li> </ol> <p>All comparisons are case-insensitive, and the reference genome is converted to uppercase during loading.</p>"},{"location":"VCFX_ref_comparator/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Chromosome not found: If a chromosome in the VCF is not found in the reference genome, the variant is marked with <code>UNKNOWN_CHROM</code></li> <li>Position out of bounds: If a position exceeds the length of the chromosome, the variant is marked with <code>INVALID_POS</code></li> <li>Multiple ALT alleles: Each ALT allele is compared separately, and the result is included in the annotation</li> <li>Symbolic alleles: Not specially handled; will likely result in <code>REF_MATCH,NOVEL</code> annotations</li> <li>Empty lines: Preserved with a single newline</li> <li>Header lines: Preserved with a new INFO definition line added before the #CHROM header</li> <li>Malformed VCF lines: Lines with fewer than 8 columns are skipped with a warning</li> <li>Data before header: Skipped with a warning</li> </ul>"},{"location":"VCFX_ref_comparator/#performance","title":"Performance","text":"<p>The tool is designed with the following considerations:</p> <ol> <li>The entire reference genome is loaded into memory for fast random access</li> <li>Chromosome names are converted to uppercase for case-insensitive matching</li> <li>Whitespace is removed from FASTA sequences during loading</li> <li>The VCF file is processed line by line, avoiding loading the entire file into memory</li> <li>Only the required fields from each variant line are extracted and processed</li> </ol> <p>For extremely large reference genomes, memory usage may be significant.</p>"},{"location":"VCFX_ref_comparator/#limitations","title":"Limitations","text":"<ol> <li>Requires loading the entire reference genome into memory</li> <li>Limited to exact string comparison; no alignment is performed for complex variants</li> <li>No special handling for symbolic alleles (like , , etc.) <li>Does not normalize variants before comparison</li> <li>Cannot handle reference genomes with duplicate chromosome names</li> <li>No support for compressed reference files; FASTA must be uncompressed</li> <li>No support for validating only a subset of variants or chromosomes </li>"},{"location":"VCFX_reformatter/","title":"VCFX_reformatter","text":""},{"location":"VCFX_reformatter/#overview","title":"Overview","text":"<p><code>VCFX_reformatter</code> is a tool for reformatting INFO and FORMAT fields in VCF files. It provides functionality to compress (remove) specific fields and reorder fields in both INFO and FORMAT columns, making VCF files more organized and efficient.</p>"},{"location":"VCFX_reformatter/#usage","title":"Usage","text":"<pre><code>VCFX_reformatter [options] &lt; input.vcf &gt; output.vcf\n</code></pre>"},{"location":"VCFX_reformatter/#options","title":"Options","text":"Option Description <code>-h, --help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-c, --compress-info &lt;keys&gt;</code> Remove specified INFO keys (comma-separated) <code>-f, --compress-format &lt;keys&gt;</code> Remove specified FORMAT keys (comma-separated) <code>-i, --reorder-info &lt;keys&gt;</code> Reorder INFO keys (comma-separated) <code>-o, --reorder-format &lt;keys&gt;</code> Reorder FORMAT keys (comma-separated)"},{"location":"VCFX_reformatter/#description","title":"Description","text":"<p><code>VCFX_reformatter</code> modifies VCF files in several ways:</p> <ol> <li>INFO Field Compression:</li> <li>Removes specified keys from the semicolon-separated INFO field</li> <li>Preserves remaining fields in their original order</li> <li> <p>Handles both key-value pairs and flag fields</p> </li> <li> <p>FORMAT Field Compression:</p> </li> <li>Removes specified keys from the colon-separated FORMAT field</li> <li>Updates all sample columns to match the new FORMAT structure</li> <li> <p>Maintains data consistency across all samples</p> </li> <li> <p>INFO Field Reordering:</p> </li> <li>Places specified keys at the beginning of the INFO field</li> <li>Appends remaining keys in their original order</li> <li> <p>Preserves all key-value pairs and flags</p> </li> <li> <p>FORMAT Field Reordering:</p> </li> <li>Reorders the FORMAT column keys</li> <li>Updates all sample columns to match the new order</li> <li>Maintains data alignment across all samples</li> </ol>"},{"location":"VCFX_reformatter/#input-requirements","title":"Input Requirements","text":"<ul> <li>Input must be a valid VCF file</li> <li>File can be piped through stdin</li> <li>Supports both VCFv4.0 and VCFv4.2 formats</li> <li>Handles both single-sample and multi-sample VCFs</li> </ul>"},{"location":"VCFX_reformatter/#output-format","title":"Output Format","text":"<p>The output is a VCF file with: - All header lines preserved - Modified INFO and FORMAT fields according to specifications - Updated sample columns to match new FORMAT structure - Original VCF format maintained</p>"},{"location":"VCFX_reformatter/#examples","title":"Examples","text":""},{"location":"VCFX_reformatter/#basic-usage","title":"Basic Usage","text":"<p>Remove specific INFO fields and reorder others:</p> <pre><code>VCFX_reformatter --compress-info AF,DP --reorder-info AF,DP &lt; input.vcf &gt; output.vcf\n</code></pre>"},{"location":"VCFX_reformatter/#format-field-manipulation","title":"Format Field Manipulation","text":"<p>Remove and reorder FORMAT fields:</p> <pre><code>VCFX_reformatter --compress-format PL,AD --reorder-format GT,DP &lt; input.vcf &gt; output.vcf\n</code></pre>"},{"location":"VCFX_reformatter/#combined-operations","title":"Combined Operations","text":"<p>Perform multiple operations in one command:</p> <pre><code>VCFX_reformatter \\\n  --compress-info AF,DP \\\n  --compress-format PL,AD \\\n  --reorder-info AF,DP \\\n  --reorder-format GT,DP \\\n  &lt; input.vcf &gt; output.vcf\n</code></pre>"},{"location":"VCFX_reformatter/#integration-with-other-tools","title":"Integration with Other Tools","text":"<p>Combine with other VCFX tools:</p> <pre><code>cat input.vcf | \\\n  VCFX_validator | \\\n  VCFX_reformatter --compress-info AF,DP | \\\n  VCFX_metadata_summarizer\n</code></pre>"},{"location":"VCFX_reformatter/#field-handling","title":"Field Handling","text":""},{"location":"VCFX_reformatter/#info-field-processing","title":"INFO Field Processing","text":"<ul> <li>Handles key-value pairs (e.g., \"DP=10\")</li> <li>Handles flag fields (e.g., \"PASS\")</li> <li>Preserves field separators</li> <li>Maintains field order when specified</li> </ul>"},{"location":"VCFX_reformatter/#format-field-processing","title":"FORMAT Field Processing","text":"<ul> <li>Updates FORMAT column structure</li> <li>Modifies all sample columns accordingly</li> <li>Preserves data alignment</li> <li>Handles missing values (\".\")</li> </ul>"},{"location":"VCFX_reformatter/#error-handling","title":"Error Handling","text":"<p>The tool handles various error conditions: - Malformed VCF lines - Missing fields - Invalid field formats - Inconsistent sample data - Lines with fewer than 8 columns</p>"},{"location":"VCFX_reformatter/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Processes input streamingly</li> <li>Efficient memory usage</li> <li>Handles large files</li> <li>Preserves original data integrity</li> </ul>"},{"location":"VCFX_reformatter/#limitations","title":"Limitations","text":"<ul> <li>Only modifies INFO and FORMAT fields</li> <li>Does not validate VCF format (use VCFX_validator for validation)</li> <li>Does not modify other VCF columns</li> <li>Requires at least 8 columns in data lines</li> </ul>"},{"location":"VCFX_reformatter/#common-use-cases","title":"Common Use Cases","text":"<ol> <li>Removing unnecessary fields to reduce file size</li> <li>Reordering fields for better readability</li> <li>Standardizing VCF format across different sources</li> <li>Preparing VCF files for specific analysis tools</li> <li>Cleaning up VCF files before processing</li> </ol>"},{"location":"VCFX_reformatter/#best-practices","title":"Best Practices","text":"<ol> <li>Validate input VCF before reformatting</li> <li>Back up original files before modification</li> <li>Verify output format meets requirements</li> <li>Use appropriate field combinations</li> <li>Document field modifications </li> </ol>"},{"location":"VCFX_region_subsampler/","title":"VCFX_region_subsampler","text":""},{"location":"VCFX_region_subsampler/#overview","title":"Overview","text":"<p><code>VCFX_region_subsampler</code> is a tool for filtering VCF variants based on genomic regions specified in a BED file. It keeps only variants whose positions fall within the specified regions, efficiently handling multiple regions and overlapping intervals.</p>"},{"location":"VCFX_region_subsampler/#usage","title":"Usage","text":"<pre><code>VCFX_region_subsampler --region-bed FILE &lt; input.vcf &gt; output.vcf\n</code></pre>"},{"location":"VCFX_region_subsampler/#options","title":"Options","text":"Option Description <code>-h, --help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-b, --region-bed FILE</code> BED file listing regions to keep"},{"location":"VCFX_region_subsampler/#description","title":"Description","text":"<p><code>VCFX_region_subsampler</code> processes a VCF file and a BED file to:</p> <ol> <li>Read and parse the BED file containing genomic regions</li> <li>Convert 0-based BED coordinates to 1-based VCF coordinates</li> <li>Merge overlapping or contiguous intervals for efficiency</li> <li>Filter VCF variants to keep only those falling within specified regions</li> <li>Preserve all VCF header information and variant details</li> </ol> <p>The tool uses binary search for efficient region lookup and handles multiple regions per chromosome.</p>"},{"location":"VCFX_region_subsampler/#input-requirements","title":"Input Requirements","text":""},{"location":"VCFX_region_subsampler/#vcf-input","title":"VCF Input","text":"<ul> <li>Must be a valid VCF file</li> <li>Can be piped through stdin</li> <li>Supports both VCFv4.0 and VCFv4.2 formats</li> <li>Must have at least 8 columns (CHROM through INFO)</li> </ul>"},{"location":"VCFX_region_subsampler/#bed-input","title":"BED Input","text":"<ul> <li>Standard BED format (chromosome, start, end)</li> <li>0-based coordinates (automatically converted to 1-based)</li> <li>One region per line</li> <li>Supports multiple regions per chromosome</li> <li>Invalid lines are skipped with warnings</li> </ul>"},{"location":"VCFX_region_subsampler/#output-format","title":"Output Format","text":"<p>The output is a VCF file containing: - All original VCF header lines - Only variants falling within specified regions - Original variant information preserved - Same format as input VCF</p>"},{"location":"VCFX_region_subsampler/#examples","title":"Examples","text":""},{"location":"VCFX_region_subsampler/#basic-usage","title":"Basic Usage","text":"<p>Filter variants using a single region:</p> <pre><code>VCFX_region_subsampler --region-bed regions.bed &lt; input.vcf &gt; filtered.vcf\n</code></pre>"},{"location":"VCFX_region_subsampler/#multiple-regions","title":"Multiple Regions","text":"<p>Filter using multiple regions across chromosomes:</p> <pre><code># regions.bed:\nchr1    0    100\nchr2    100  200\nVCFX_region_subsampler --region-bed regions.bed &lt; input.vcf &gt; filtered.vcf\n</code></pre>"},{"location":"VCFX_region_subsampler/#integration-with-other-tools","title":"Integration with Other Tools","text":"<p>Combine with other VCFX tools:</p> <pre><code>cat input.vcf | \\\n  VCFX_validator | \\\n  VCFX_region_subsampler --region-bed regions.bed | \\\n  VCFX_metadata_summarizer\n</code></pre>"},{"location":"VCFX_region_subsampler/#region-handling","title":"Region Handling","text":""},{"location":"VCFX_region_subsampler/#coordinate-system","title":"Coordinate System","text":"<ul> <li>Input BED: 0-based coordinates</li> <li>Internal processing: 1-based coordinates</li> <li>Automatic conversion between systems</li> </ul>"},{"location":"VCFX_region_subsampler/#interval-merging","title":"Interval Merging","text":"<ul> <li>Overlapping intervals are merged</li> <li>Contiguous intervals are combined</li> <li>Maintains efficiency for large region sets</li> </ul>"},{"location":"VCFX_region_subsampler/#region-validation","title":"Region Validation","text":"<ul> <li>Skips invalid BED lines</li> <li>Handles negative intervals</li> <li>Ignores zero-length intervals</li> <li>Reports warnings for invalid entries</li> </ul>"},{"location":"VCFX_region_subsampler/#error-handling","title":"Error Handling","text":"<p>The tool handles various error conditions: - Missing --region-bed argument - Invalid BED file format - Invalid VCF lines - Missing or malformed coordinates - Data lines before header</p>"},{"location":"VCFX_region_subsampler/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Uses binary search for region lookup</li> <li>Merges overlapping intervals for efficiency</li> <li>Processes input streamingly</li> <li>Memory efficient for large region sets</li> <li>Handles large VCF files</li> </ul>"},{"location":"VCFX_region_subsampler/#limitations","title":"Limitations","text":"<ul> <li>Only filters by position (CHROM, POS)</li> <li>Does not validate VCF format (use VCFX_validator for validation)</li> <li>Requires at least 8 columns in VCF</li> <li>Skips data lines before #CHROM header</li> <li>Treats invalid BED lines as warnings, not errors</li> </ul>"},{"location":"VCFX_region_subsampler/#common-use-cases","title":"Common Use Cases","text":"<ol> <li>Extracting variants from specific genomic regions</li> <li>Focusing analysis on particular chromosomal segments</li> <li>Creating region-specific VCF subsets</li> <li>Preparing data for region-based analysis</li> <li>Filtering variants for specific genomic features</li> </ol>"},{"location":"VCFX_region_subsampler/#best-practices","title":"Best Practices","text":"<ol> <li>Validate input VCF before filtering</li> <li>Verify BED file format and coordinates</li> <li>Check region coverage before processing</li> <li>Monitor warning messages for invalid regions</li> <li>Document region selection criteria </li> </ol>"},{"location":"VCFX_sample_extractor/","title":"VCFX_sample_extractor","text":""},{"location":"VCFX_sample_extractor/#overview","title":"Overview","text":"<p>VCFX_sample_extractor is a tool that extracts a subset of samples from a VCF file, allowing you to create a smaller, focused VCF containing only the samples of interest.</p>"},{"location":"VCFX_sample_extractor/#usage","title":"Usage","text":"<pre><code>VCFX_sample_extractor [OPTIONS] &lt; input.vcf &gt; subset.vcf\n</code></pre>"},{"location":"VCFX_sample_extractor/#options","title":"Options","text":"Option Description <code>-s</code>, <code>--samples</code> LIST Comma or space separated list of sample names to extract <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_sample_extractor/#description","title":"Description","text":"<p>VCFX_sample_extractor reads a VCF file from standard input, identifies the samples specified in the command line, and produces a new VCF file containing only those samples. This is useful for:</p> <ul> <li>Reducing file size by extracting only relevant samples</li> <li>Creating sample-specific VCF files for specialized analyses</li> <li>Focusing on specific cohorts or subgroups</li> <li>Compliance with data sharing permissions that allow sharing only specific samples</li> </ul> <p>The tool: 1. Reads the VCF header to identify sample columns 2. Maintains all meta-information and header lines 3. Extracts only the specified samples, preserving order and data integrity 4. Warns about any requested samples that aren't found in the input VCF</p>"},{"location":"VCFX_sample_extractor/#output-format","title":"Output Format","text":"<p>The output is a standard VCF file containing: - All header lines from the input file - A modified #CHROM header line that includes only the selected samples - All variant lines from the input with only the selected sample columns</p>"},{"location":"VCFX_sample_extractor/#examples","title":"Examples","text":""},{"location":"VCFX_sample_extractor/#extract-a-single-sample","title":"Extract a Single Sample","text":"<pre><code>./VCFX_sample_extractor --samples \"SAMPLE1\" &lt; input.vcf &gt; single_sample.vcf\n</code></pre>"},{"location":"VCFX_sample_extractor/#extract-multiple-samples-with-comma-delimiter","title":"Extract Multiple Samples with Comma Delimiter","text":"<pre><code>./VCFX_sample_extractor --samples \"SAMPLE1,SAMPLE2,SAMPLE3\" &lt; input.vcf &gt; subset.vcf\n</code></pre>"},{"location":"VCFX_sample_extractor/#extract-multiple-samples-with-space-delimiter","title":"Extract Multiple Samples with Space Delimiter","text":"<pre><code>./VCFX_sample_extractor --samples \"SAMPLE1 SAMPLE2 SAMPLE3\" &lt; input.vcf &gt; subset.vcf\n</code></pre>"},{"location":"VCFX_sample_extractor/#process-large-files","title":"Process Large Files","text":"<pre><code># Extract a few samples from a large compressed VCF\nzcat large_file.vcf.gz | ./VCFX_sample_extractor --samples \"SAMPLE1,SAMPLE2\" | gzip &gt; subset.vcf.gz\n</code></pre>"},{"location":"VCFX_sample_extractor/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Missing samples: If a requested sample isn't found in the input VCF, a warning is issued but processing continues with the samples that were found</li> <li>No samples found: If none of the requested samples are found in the input VCF, the output will contain only the header and variant lines with no sample columns</li> <li>Malformed VCF: Lines with fewer than 8 columns are skipped with a warning</li> <li>No sample columns: Input variant lines without sample columns (fewer than 10 columns) are skipped</li> <li>Empty sample names: Empty sample names in the input list are ignored</li> </ul>"},{"location":"VCFX_sample_extractor/#performance","title":"Performance","text":"<p>The tool processes VCF files line by line, with minimal memory requirements even for very large VCF files. Performance scales with: - Number of samples in the input VCF (parsing time) - Number of samples being extracted (output size)</p>"},{"location":"VCFX_sample_extractor/#limitations","title":"Limitations","text":"<ul> <li>No wildcards or regular expressions for sample name matching</li> <li>Cannot extract samples based on properties or metadata</li> <li>Cannot reorder samples in the output file (order follows the original VCF)</li> <li>No option to rename samples in the output file </li> </ul>"},{"location":"VCFX_sorter/","title":"VCFX_sorter","text":""},{"location":"VCFX_sorter/#overview","title":"Overview","text":"<p><code>VCFX_sorter</code> is a utility tool for sorting VCF files by chromosome and position. It provides two sorting methods: standard lexicographic sorting and natural chromosome sorting, which handles chromosome numbering in a more intuitive way.</p>"},{"location":"VCFX_sorter/#usage","title":"Usage","text":"<pre><code>VCFX_sorter [OPTIONS] &lt; input.vcf &gt; output.vcf\n</code></pre>"},{"location":"VCFX_sorter/#options","title":"Options","text":"Option Description <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-n</code>, <code>--natural-chr</code> Use natural chromosome sorting (chr1 &lt; chr2 &lt; chr10) instead of lexicographic sorting"},{"location":"VCFX_sorter/#description","title":"Description","text":"<p><code>VCFX_sorter</code> processes a VCF file to organize variants in a consistent order by:</p> <ol> <li>Reading the VCF file from standard input</li> <li>Preserving all header lines without modification</li> <li>Loading all data lines into memory</li> <li>Sorting the data lines by chromosome and position</li> <li>Writing the header lines followed by the sorted data lines to standard output</li> </ol> <p>The tool supports two distinct sorting methods: - Lexicographic sorting (default): Sorts chromosomes alphabetically (chr1, chr10, chr2, ...) - Natural sorting: Sorts chromosomes in numeric order when possible (chr1, chr2, ..., chr10, ...)</p> <p>This tool is particularly useful for: - Preparing VCF files for downstream analysis tools that expect sorted input - Merging multiple VCF files that need consistent ordering - Improving readability and navigation of VCF files - Making binary searches possible on VCF data</p>"},{"location":"VCFX_sorter/#sorting-details","title":"Sorting Details","text":""},{"location":"VCFX_sorter/#lexicographic-sorting","title":"Lexicographic Sorting","text":"<p>In the default lexicographic mode: - Chromosomes are compared as strings (e.g., 'chr2' comes after 'chr10') - Positions are compared numerically within the same chromosome</p>"},{"location":"VCFX_sorter/#natural-chromosome-sorting","title":"Natural Chromosome Sorting","text":"<p>When the <code>--natural-chr</code> option is used: 1. The \"chr\" prefix (case-insensitive) is identified and removed 2. Any leading digits are parsed as a number 3. Remaining characters are treated as a suffix 4. Sorting precedence:    - First by chromosome prefix (if different)    - Then by numeric part (if both have numbers)    - Then by suffix (if both have the same number)    - Finally by position</p> <p>This results in more intuitive ordering where chr1 &lt; chr2 &lt; chr10, instead of chr1 &lt; chr10 &lt; chr2.</p>"},{"location":"VCFX_sorter/#examples","title":"Examples","text":""},{"location":"VCFX_sorter/#basic-lexicographic-sorting","title":"Basic Lexicographic Sorting","text":"<p>Sort a VCF file using standard lexicographic chromosome ordering: <pre><code>VCFX_sorter &lt; unsorted.vcf &gt; sorted.vcf\n</code></pre></p>"},{"location":"VCFX_sorter/#natural-chromosome-sorting_1","title":"Natural Chromosome Sorting","text":"<p>Sort a VCF file using natural chromosome ordering: <pre><code>VCFX_sorter --natural-chr &lt; unsorted.vcf &gt; sorted.vcf\n</code></pre></p>"},{"location":"VCFX_sorter/#example-transformations","title":"Example Transformations","text":""},{"location":"VCFX_sorter/#lexicographic-sorting_1","title":"Lexicographic Sorting","text":"<pre><code>Before:\nchr2  1000  .  A  T  .  PASS  .\nchr1  2000  .  G  C  .  PASS  .\nchr10 1500  .  T  A  .  PASS  .\n\nAfter:\nchr1  2000  .  G  C  .  PASS  .\nchr10 1500  .  T  A  .  PASS  .\nchr2  1000  .  A  T  .  PASS  .\n</code></pre>"},{"location":"VCFX_sorter/#natural-chromosome-sorting_2","title":"Natural Chromosome Sorting","text":"<pre><code>Before:\nchr2  1000  .  A  T  .  PASS  .\nchr1  2000  .  G  C  .  PASS  .\nchr10 1500  .  T  A  .  PASS  .\n\nAfter:\nchr1  2000  .  G  C  .  PASS  .\nchr2  1000  .  A  T  .  PASS  .\nchr10 1500  .  T  A  .  PASS  .\n</code></pre>"},{"location":"VCFX_sorter/#handling-special-cases","title":"Handling Special Cases","text":""},{"location":"VCFX_sorter/#malformed-lines","title":"Malformed Lines","text":"<ul> <li>Lines with fewer than 8 columns are skipped with a warning</li> <li>Lines with an invalid position value are skipped with a warning</li> </ul>"},{"location":"VCFX_sorter/#empty-input","title":"Empty Input","text":"<ul> <li>If no input is provided, the help message is displayed</li> </ul>"},{"location":"VCFX_sorter/#missing-header","title":"Missing Header","text":"<ul> <li>If no #CHROM header line is found in the input, a warning is issued but processing continues</li> </ul>"},{"location":"VCFX_sorter/#complex-chromosome-names","title":"Complex Chromosome Names","text":"<ul> <li>Chromosomes with non-standard naming follow sorting rules based on the selected mode</li> <li>Examples of parsing in natural mode:</li> <li>\"chr1\" \u2192 prefix=\"chr\", number=1, suffix=\"\"</li> <li>\"chrX\" \u2192 prefix=\"chr\", number=none, suffix=\"X\"</li> <li>\"chr10_alt\" \u2192 prefix=\"chr\", number=10, suffix=\"_alt\"</li> <li>\"scaffold_123\" \u2192 prefix=\"\", number=none, suffix=\"scaffold_123\"</li> </ul>"},{"location":"VCFX_sorter/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>The tool reads the entire VCF file into memory before sorting</li> <li>Memory usage scales with the number of variants in the input file</li> <li>Very large VCF files may require significant memory</li> <li>Processing time is dominated by the sorting operation, which is O(n log n)</li> </ul>"},{"location":"VCFX_sorter/#limitations","title":"Limitations","text":"<ul> <li>No support for on-disk sorting of files too large to fit in memory</li> <li>Cannot sort by other fields besides chromosome and position</li> <li>Does not validate VCF format beyond basic column counting</li> <li>No handling of compressed (gzipped) VCF files directly</li> <li>Cannot maintain the original order of variants at the same chromosome and position </li> </ul>"},{"location":"VCFX_subsampler/","title":"VCFX_subsampler","text":""},{"location":"VCFX_subsampler/#overview","title":"Overview","text":"<p><code>VCFX_subsampler</code> is a tool for randomly selecting a specified number of variants from a VCF file. It uses reservoir sampling to efficiently select a random subset of variants while preserving the VCF header information. The tool is particularly useful for creating smaller test datasets or reducing the size of large VCF files for preliminary analysis.</p>"},{"location":"VCFX_subsampler/#usage","title":"Usage","text":"<pre><code>VCFX_subsampler [options] &lt; input.vcf &gt; output.vcf\n</code></pre>"},{"location":"VCFX_subsampler/#options","title":"Options","text":"Option Description <code>-s, --subsample &lt;N&gt;</code> Required: Number of variants to keep in the output <code>--seed &lt;INT&gt;</code> Optional: Use a specific random seed for reproducible results <code>-h, --help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>)"},{"location":"VCFX_subsampler/#description","title":"Description","text":"<p><code>VCFX_subsampler</code> processes a VCF file to:</p> <ol> <li>Preserve all header lines (starting with #)</li> <li>Randomly select N variants from the data section</li> <li>Skip invalid lines (those with fewer than 8 columns)</li> <li>Output the selected variants while maintaining VCF format</li> </ol> <p>The tool uses reservoir sampling to ensure unbiased random selection, even when the total number of variants is unknown in advance.</p>"},{"location":"VCFX_subsampler/#input-requirements","title":"Input Requirements","text":"<ul> <li>Must be a valid VCF file</li> <li>Can be piped through stdin</li> <li>Must have at least 8 columns (CHROM through INFO)</li> <li>Header lines must start with #</li> </ul>"},{"location":"VCFX_subsampler/#output-format","title":"Output Format","text":"<p>The output is a VCF file containing: - All original VCF header lines - N randomly selected variants (or all variants if input has fewer than N) - Same format as input VCF - Invalid lines (with &lt;8 columns) are skipped with warnings</p>"},{"location":"VCFX_subsampler/#examples","title":"Examples","text":""},{"location":"VCFX_subsampler/#basic-usage","title":"Basic Usage","text":"<p>Select 1000 random variants:</p> <pre><code>VCFX_subsampler --subsample 1000 &lt; input.vcf &gt; subset.vcf\n</code></pre>"},{"location":"VCFX_subsampler/#reproducible-sampling","title":"Reproducible Sampling","text":"<p>Use a fixed seed for reproducible results:</p> <pre><code>VCFX_subsampler --subsample 1000 --seed 1234 &lt; input.vcf &gt; subset.vcf\n</code></pre>"},{"location":"VCFX_subsampler/#integration-with-other-tools","title":"Integration with Other Tools","text":"<p>Combine with other VCFX tools:</p> <pre><code>cat input.vcf | \\\n  VCFX_validator | \\\n  VCFX_subsampler --subsample 1000 | \\\n  VCFX_metadata_summarizer\n</code></pre>"},{"location":"VCFX_subsampler/#sampling-algorithm","title":"Sampling Algorithm","text":"<p>The tool uses reservoir sampling to: - Process the input streamingly - Maintain a reservoir of N variants - Replace variants in the reservoir with probability N/count - Ensure unbiased random selection</p>"},{"location":"VCFX_subsampler/#error-handling","title":"Error Handling","text":"<p>The tool handles various error conditions: - Missing --subsample argument - Invalid subsample size (must be &gt;0) - Invalid seed value - Invalid VCF lines (with &lt;8 columns) - Data lines before header</p>"},{"location":"VCFX_subsampler/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Memory efficient: only stores N variants in memory</li> <li>Processes input streamingly</li> <li>Preserves header information</li> <li>Skips invalid lines efficiently</li> </ul>"},{"location":"VCFX_subsampler/#limitations","title":"Limitations","text":"<ul> <li>Only samples variants (data lines)</li> <li>Skips lines with &lt;8 columns</li> <li>Requires at least 8 columns in VCF</li> <li>Skips data lines before #CHROM header</li> <li>No support for weighted sampling</li> </ul>"},{"location":"VCFX_subsampler/#common-use-cases","title":"Common Use Cases","text":"<ol> <li>Creating test datasets</li> <li>Reducing large VCF files for quick analysis</li> <li>Generating random subsets for validation</li> <li>Preparing data for development and testing</li> <li>Creating smaller datasets for preliminary analysis</li> </ol>"},{"location":"VCFX_subsampler/#best-practices","title":"Best Practices","text":"<ol> <li>Validate input VCF before sampling</li> <li>Use --seed for reproducible results</li> <li>Monitor warning messages for skipped lines</li> <li>Consider using VCFX_validator before sampling</li> <li>Document sampling parameters for reproducibility </li> </ol>"},{"location":"VCFX_sv_handler/","title":"VCFX_sv_handler","text":""},{"location":"VCFX_sv_handler/#overview","title":"Overview","text":"<p><code>VCFX_sv_handler</code> is a utility tool for filtering and modifying structural variant (SV) records in VCF files. It can identify variants with the SVTYPE annotation, either keeping only structural variants or enhancing their annotations with additional information.</p>"},{"location":"VCFX_sv_handler/#usage","title":"Usage","text":"<pre><code>VCFX_sv_handler [OPTIONS] &lt; input.vcf &gt; output.vcf\n</code></pre>"},{"location":"VCFX_sv_handler/#options","title":"Options","text":"Option Description <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-f</code>, <code>--sv-filter-only</code> Keep only lines that have 'SVTYPE=' in their INFO field <code>-m</code>, <code>--sv-modify</code> Modify the INFO field of structural variants to add additional annotations"},{"location":"VCFX_sv_handler/#description","title":"Description","text":"<p><code>VCFX_sv_handler</code> processes a VCF file to manage structural variant records by:</p> <ol> <li>Reading the VCF file from standard input</li> <li>Preserving all header lines without modification</li> <li>For each data line:</li> <li>Checking if it contains 'SVTYPE=' in the INFO field to identify structural variants</li> <li>If filtering is enabled, keeping only structural variant records</li> <li>If modification is enabled, adding additional annotations to structural variant records</li> <li>Writing the processed VCF to standard output</li> </ol> <p>Structural variants (SVs) are genomic alterations that involve segments of DNA and include deletions (DEL), duplications (DUP), inversions (INV), and breakends (BND). This tool helps to specifically process these variants, which often require special handling in downstream analyses.</p>"},{"location":"VCFX_sv_handler/#modification-details","title":"Modification Details","text":"<p>When the <code>--sv-modify</code> option is used, the tool adds several annotations to structural variant records:</p> <ol> <li>For all structural variants:</li> <li> <p>Adds <code>SV_VALIDATED=1</code> to indicate the variant has been processed</p> </li> <li> <p>For deletions (DEL) and duplications (DUP):</p> </li> <li> <p>Calculates and adds <code>SV_SIZE=&lt;size&gt;</code> based on the difference between END and POS positions</p> </li> <li> <p>For inversions (INV):</p> </li> <li> <p>Adds <code>INV_TYPE=PARALLEL</code></p> </li> <li> <p>For breakends (BND):</p> </li> <li>Adds <code>BND_ORIENTATION=PAIR</code></li> </ol> <p>These modifications can be useful for downstream analyses that rely on standardized annotations or require specific information about structural variants.</p>"},{"location":"VCFX_sv_handler/#examples","title":"Examples","text":""},{"location":"VCFX_sv_handler/#filter-structural-variants","title":"Filter Structural Variants","text":"<p>Keep only structural variant records in a VCF file: <pre><code>VCFX_sv_handler --sv-filter-only &lt; input.vcf &gt; sv_only.vcf\n</code></pre></p>"},{"location":"VCFX_sv_handler/#modify-structural-variants","title":"Modify Structural Variants","text":"<p>Enhance structural variant records with additional annotations: <pre><code>VCFX_sv_handler --sv-modify &lt; input.vcf &gt; annotated.vcf\n</code></pre></p>"},{"location":"VCFX_sv_handler/#combined-operation","title":"Combined Operation","text":"<p>Filter and modify structural variants in one operation: <pre><code>VCFX_sv_handler --sv-filter-only --sv-modify &lt; input.vcf &gt; processed_sv.vcf\n</code></pre></p>"},{"location":"VCFX_sv_handler/#example-transformations","title":"Example Transformations","text":""},{"location":"VCFX_sv_handler/#filtering-structural-variants","title":"Filtering Structural Variants","text":"<pre><code>Before:\nchr1 100 . A T . PASS DP=30\nchr1 200 . T G . PASS SVTYPE=DEL;END=300\n\nAfter (with --sv-filter-only):\nchr1 200 . T G . PASS SVTYPE=DEL;END=300\n</code></pre>"},{"location":"VCFX_sv_handler/#modifying-structural-variants","title":"Modifying Structural Variants","text":"<pre><code>Before:\nchr1 200 . T G . PASS SVTYPE=DEL;END=300\n\nAfter (with --sv-modify):\nchr1 200 . T G . PASS SVTYPE=DEL;END=300;SV_VALIDATED=1;SV_SIZE=100\n</code></pre> <pre><code>Before:\nchr1 400 . G C . PASS SVTYPE=INV;END=500\n\nAfter (with --sv-modify):\nchr1 400 . G C . PASS SVTYPE=INV;END=500;SV_VALIDATED=1;INV_TYPE=PARALLEL\n</code></pre>"},{"location":"VCFX_sv_handler/#special-case-handling","title":"Special Case Handling","text":""},{"location":"VCFX_sv_handler/#multiple-options","title":"Multiple Options","text":"<ul> <li>When both <code>--sv-filter-only</code> and <code>--sv-modify</code> are used, records are first filtered and then modified</li> </ul>"},{"location":"VCFX_sv_handler/#missing-fields","title":"Missing Fields","text":"<ul> <li>If a variant has SVTYPE but no END position, it will still be processed</li> <li>For size calculations, if either POS or END is missing/invalid, SV_SIZE will not be added</li> </ul>"},{"location":"VCFX_sv_handler/#malformed-lines","title":"Malformed Lines","text":"<ul> <li>Lines with fewer than 8 columns are skipped with a warning</li> <li>Lines with invalid POS values are skipped when attempting to modify</li> </ul>"},{"location":"VCFX_sv_handler/#non-structural-variants","title":"Non-Structural Variants","text":"<ul> <li>Non-SV records are preserved unless filtering is enabled</li> </ul>"},{"location":"VCFX_sv_handler/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>The tool processes the VCF file line by line, with minimal memory requirements</li> <li>Performance scales linearly with the size of the input file</li> <li>No external dependencies or reference files are required</li> </ul>"},{"location":"VCFX_sv_handler/#limitations","title":"Limitations","text":"<ul> <li>The tool identifies structural variants solely by the presence of \"SVTYPE=\" in the INFO field</li> <li>It adds fixed annotations without validating if they're appropriate for the specific variant</li> <li>No support for custom annotations or handling of specific structural variant subtypes</li> <li>Does not validate the correctness of existing structural variant annotations</li> <li>Cannot handle compressed (gzipped) VCF files directly </li> </ul>"},{"location":"VCFX_validator/","title":"VCFX_validator","text":""},{"location":"VCFX_validator/#overview","title":"Overview","text":"<p><code>VCFX_validator</code> is a utility tool for checking the validity of VCF files according to the basic VCF format specifications. It performs various checks on the file structure, header format, and data lines to ensure the file is properly formatted and contains valid data.</p>"},{"location":"VCFX_validator/#usage","title":"Usage","text":"<pre><code>VCFX_validator [OPTIONS] &lt; input.vcf\n</code></pre>"},{"location":"VCFX_validator/#options","title":"Options","text":"Option Description <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-s</code>, <code>--strict</code> Enable stricter validation checks <code>-d</code>, <code>--report-dups</code> Report duplicate records to stderr"},{"location":"VCFX_validator/#description","title":"Description","text":"<p><code>VCFX_validator</code> processes a VCF file to verify its structural validity by:</p> <ol> <li>Reading the VCF file from standard input (plain or gzip/BGZF compressed)</li> <li>Checking that all meta-information lines (starting with '##') are properly formatted</li> <li>Validating that the #CHROM header line is present and has at least 8 required columns</li> <li>For each data line:</li> <li>Ensuring it has at least 8 columns</li> <li>Verifying that CHROM is not empty</li> <li>Confirming POS is a positive integer</li> <li>Checking that REF and ALT contain only valid bases</li> <li>Validating that QUAL is either '.' or a non-negative float</li> <li>Ensuring FILTER is not empty</li> <li>Checking INFO and FORMAT fields against header definitions</li> <li>Validating genotype syntax</li> <li>Detecting duplicate records when <code>--report-dups</code> is used</li> <li>Reporting errors for any validation failures</li> <li>Returning exit code 0 if the file is valid, or 1 if it contains errors</li> </ol> <p>This tool is useful for validating VCF files before processing them with other tools, ensuring they meet the basic requirements of the VCF format specification.</p>"},{"location":"VCFX_validator/#validation-details","title":"Validation Details","text":""},{"location":"VCFX_validator/#meta-information-lines","title":"Meta-Information Lines","text":"<ul> <li>Must start with '##'</li> <li>No specific content validation beyond the prefix</li> </ul>"},{"location":"VCFX_validator/#chrom-header-line","title":"#CHROM Header Line","text":"<ul> <li>Must be present in the file</li> <li>Must start with '#CHROM'</li> <li>Must have at least 8 columns (CHROM, POS, ID, REF, ALT, QUAL, FILTER, INFO)</li> <li>Must appear before any data lines</li> </ul>"},{"location":"VCFX_validator/#data-lines","title":"Data Lines","text":"<ul> <li>Must have at least 8 columns</li> <li>CHROM: Must not be empty</li> <li>POS: Must be a positive integer</li> <li>ID: Can be empty or '.' (not validated)</li> <li>REF: Must contain only A,C,G,T,N</li> <li>ALT: Must contain only A,C,G,T,N</li> <li>QUAL: Must be '.' or a non-negative float</li> <li>FILTER: Must not be empty</li> <li>INFO: Keys must be defined in the header. Numeric counts are validated when numeric. Flags are allowed.</li> </ul>"},{"location":"VCFX_validator/#strict-mode","title":"Strict Mode","text":"<p>When <code>--strict</code> is used, additional checks are applied: - The number of columns in every data line must exactly match the <code>#CHROM</code> header. - If FORMAT/sample columns are present, each sample field must contain the same   number of sub-fields as specified in the FORMAT column. - Any warning that would normally be emitted is treated as an error and causes   the validator to exit with a non-zero status.</p>"},{"location":"VCFX_validator/#examples","title":"Examples","text":""},{"location":"VCFX_validator/#basic-validation","title":"Basic Validation","text":"<p>Check if a VCF file is valid: <pre><code>VCFX_validator &lt; input.vcf &gt; validated.vcf\n</code></pre></p>"},{"location":"VCFX_validator/#using-strict-mode","title":"Using Strict Mode","text":"<p>Enable stricter validation with additional checks: <pre><code>VCFX_validator --strict &lt; input.vcf &gt; validated.vcf\n</code></pre></p> <p>When the input is valid, the original VCF is written unchanged to standard output, allowing <code>VCFX_validator</code> to be used as a filter in processing pipelines. Informational messages such as <code>VCF file is valid.</code> are printed to standard error.</p>"},{"location":"VCFX_validator/#redirecting-error-messages","title":"Redirecting Error Messages","text":"<p>Save validation errors to a file: <pre><code>VCFX_validator &lt; input.vcf 2&gt; validation_errors.txt\n</code></pre></p>"},{"location":"VCFX_validator/#example-output","title":"Example Output","text":""},{"location":"VCFX_validator/#for-valid-files","title":"For Valid Files","text":"<pre><code>VCF file is valid.\n</code></pre>"},{"location":"VCFX_validator/#for-invalid-files","title":"For Invalid Files","text":"<p><pre><code>Error: line 15 has &lt;8 columns.\n</code></pre> <pre><code>Error: line 42 POS must be &gt;0.\n</code></pre> <pre><code>Error: no #CHROM line found in file.\n</code></pre></p>"},{"location":"VCFX_validator/#special-case-handling","title":"Special Case Handling","text":""},{"location":"VCFX_validator/#empty-lines","title":"Empty Lines","text":"<ul> <li>Empty lines are ignored during validation</li> </ul>"},{"location":"VCFX_validator/#malformed-header-lines","title":"Malformed Header Lines","text":"<ul> <li>Lines starting with '#' that are neither '##' meta-information lines nor the '#CHROM' header line are considered errors</li> </ul>"},{"location":"VCFX_validator/#missing-chrom-line","title":"Missing #CHROM Line","text":"<ul> <li>If no #CHROM line is found in the file, an error is reported</li> <li>Data lines encountered before a #CHROM line will cause validation to fail</li> </ul>"},{"location":"VCFX_validator/#whitespace","title":"Whitespace","text":"<ul> <li>Leading and trailing whitespace is trimmed from field values before validation</li> </ul>"},{"location":"VCFX_validator/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>The tool processes the VCF file line by line, with minimal memory requirements</li> <li>Performance scales linearly with the size of the input file</li> <li>No external dependencies or reference files are required</li> </ul>"},{"location":"VCFX_validator/#limitations","title":"Limitations","text":"<ul> <li>Does not validate VCF version compatibility</li> <li>No validation of the content of meta-information lines beyond the '##' prefix</li> </ul>"},{"location":"VCFX_variant_classifier/","title":"VCFX_variant_classifier","text":""},{"location":"VCFX_variant_classifier/#overview","title":"Overview","text":"<p>The VCFX_variant_classifier tool analyzes VCF files and classifies variants into various types: SNP, INDEL, MNV, or STRUCTURAL. It can either produce a TSV summary or append classifications to the original VCF file.</p>"},{"location":"VCFX_variant_classifier/#usage","title":"Usage","text":"<pre><code>VCFX_variant_classifier [OPTIONS] &lt; input.vcf &gt; output.vcf_or_tsv\n</code></pre>"},{"location":"VCFX_variant_classifier/#options","title":"Options","text":"Option Description <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-a</code>, <code>--append-info</code> Instead of producing a TSV, output a valid VCF with a new 'VCF_CLASS' subfield in the INFO column"},{"location":"VCFX_variant_classifier/#description","title":"Description","text":"<p>VCFX_variant_classifier reads each variant line from a VCF file and determines its type based on the following criteria:</p> <ul> <li>SNP: Single nucleotide polymorphism, where both reference and alternate alleles are single bases</li> <li>INDEL: Insertions or deletions with length difference less than 50 bp</li> <li>MNV: Multi-nucleotide variants with the same length but multiple bases changed</li> <li>STRUCTURAL: Complex variants including:</li> <li>Symbolic ALT fields (<code>&lt;DEL&gt;</code>, <code>&lt;INS&gt;</code>, etc.)</li> <li>Breakend notation (containing <code>[</code> or <code>]</code>)</li> <li>Variants with length difference \u226550 bp</li> <li>Very large reference or alternate alleles (\u226540 bp)</li> <li>UNKNOWN: Reserved for special cases like missing or identical REF/ALT</li> </ul>"},{"location":"VCFX_variant_classifier/#output-formats","title":"Output Formats","text":""},{"location":"VCFX_variant_classifier/#tsv-mode-default","title":"TSV Mode (Default)","text":"<p>By default, the tool outputs a TSV file with the following columns: <pre><code>CHROM  POS  ID  REF  ALT  Classification\n</code></pre></p>"},{"location":"VCFX_variant_classifier/#vcf-mode-with-append-info","title":"VCF Mode (with --append-info)","text":"<p>When using the <code>--append-info</code> option, the tool: - Preserves the original VCF format including all headers - Adds a <code>VCF_CLASS=TYPE</code> entry to the INFO field of each variant - Maintains all other VCF fields</p>"},{"location":"VCFX_variant_classifier/#examples","title":"Examples","text":""},{"location":"VCFX_variant_classifier/#basic-classification-to-tsv","title":"Basic Classification to TSV","text":"<pre><code>./VCFX_variant_classifier &lt; input.vcf &gt; classified.tsv\n</code></pre>"},{"location":"VCFX_variant_classifier/#append-classification-to-vcf","title":"Append Classification to VCF","text":"<pre><code>./VCFX_variant_classifier --append-info &lt; input.vcf &gt; annotated.vcf\n</code></pre>"},{"location":"VCFX_variant_classifier/#filtering-based-on-classification","title":"Filtering Based on Classification","text":"<pre><code># First classify, then filter for structural variants only\n./VCFX_variant_classifier &lt; input.vcf | grep \"STRUCTURAL\" &gt; structural_variants.tsv\n</code></pre>"},{"location":"VCFX_variant_classifier/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Multi-allelic sites: The most complex type among all alternates is assigned (STRUCTURAL &gt; MNV &gt; INDEL &gt; SNP)</li> <li>Malformed lines: Lines with fewer than 8 columns are skipped with a warning</li> <li>Missing data: Missing ALT fields or identical REF/ALT entries are classified as UNKNOWN</li> <li>Symbolic alleles: Any variant with symbolic notation (e.g., <code>&lt;DEL&gt;</code>) is classified as STRUCTURAL</li> </ul>"},{"location":"VCFX_variant_classifier/#performance","title":"Performance","text":"<p>The tool efficiently processes VCF files line by line, allowing it to handle very large files with minimal memory requirements.</p>"},{"location":"VCFX_variant_classifier/#limitations","title":"Limitations","text":"<ul> <li>Classification is based on standard VCF conventions and may need adjustment for non-standard VCFs</li> <li>Cannot detect complex structural variants that aren't properly annotated in the VCF</li> <li>Edge cases like very long identical stretches may be classified in unexpected ways </li> </ul>"},{"location":"VCFX_variant_counter/","title":"VCFX_variant_counter","text":""},{"location":"VCFX_variant_counter/#overview","title":"Overview","text":"<p><code>VCFX_variant_counter</code> is a simple utility tool that counts the total number of valid variants (data lines) in a VCF file. It reads input from standard input, processes each line, and outputs the total count of valid variant records.</p>"},{"location":"VCFX_variant_counter/#usage","title":"Usage","text":"<pre><code>VCFX_variant_counter [OPTIONS] &lt; input.vcf\n</code></pre>"},{"location":"VCFX_variant_counter/#options","title":"Options","text":"Option Description <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-s</code>, <code>--strict</code> Fail on any data line with fewer than 8 columns"},{"location":"VCFX_variant_counter/#description","title":"Description","text":"<p><code>VCFX_variant_counter</code> processes a VCF file by:</p> <ol> <li>Reading the VCF file from standard input</li> <li>Ignoring all header lines (those starting with <code>#</code>)</li> <li>For each data line:</li> <li>Checking if it has at least 8 columns (CHROM, POS, ID, REF, ALT, QUAL, FILTER, INFO)</li> <li>If it has 8 or more columns, counting it as a valid variant</li> <li>If it has fewer than 8 columns:<ul> <li>In strict mode: exiting with an error</li> <li>In normal mode: skipping the line with a warning</li> </ul> </li> <li>Finally, printing the total count of valid variants</li> </ol> <p>This tool is useful for quickly determining the number of variants in a VCF file, which can be helpful for quality control, workflow validation, or simply getting an overview of a dataset's size.</p>"},{"location":"VCFX_variant_counter/#vcf-format-requirements","title":"VCF Format Requirements","text":"<p>The tool assumes a standard VCF format where: - Header lines start with <code>#</code> - Data lines have at least 8 tab-separated columns (CHROM, POS, ID, REF, ALT, QUAL, FILTER, INFO) - Optional FORMAT and sample columns may follow</p>"},{"location":"VCFX_variant_counter/#examples","title":"Examples","text":""},{"location":"VCFX_variant_counter/#basic-usage","title":"Basic Usage","text":"<p>Count the variants in a VCF file: <pre><code>VCFX_variant_counter &lt; input.vcf\n</code></pre> Output: <pre><code>Total Variants: 1234\n</code></pre></p>"},{"location":"VCFX_variant_counter/#using-strict-mode","title":"Using Strict Mode","text":"<p>Count variants with strict validation (will fail on malformed lines): <pre><code>VCFX_variant_counter --strict &lt; input.vcf\n</code></pre></p>"},{"location":"VCFX_variant_counter/#using-in-a-pipeline","title":"Using in a Pipeline","text":"<p>Count variants after filtering: <pre><code>cat input.vcf | grep -v \"FILTER=FAIL\" | VCFX_variant_counter\n</code></pre></p>"},{"location":"VCFX_variant_counter/#error-handling","title":"Error Handling","text":""},{"location":"VCFX_variant_counter/#invalid-lines","title":"Invalid Lines","text":"<ul> <li>In normal mode (default):</li> <li>Lines with fewer than 8 columns are skipped</li> <li>A warning is printed to standard error for each skipped line</li> <li> <p>The count continues with valid lines</p> </li> <li> <p>In strict mode (<code>--strict</code>):</p> </li> <li>If any line has fewer than 8 columns, the program exits with an error</li> <li>The error message includes the line number</li> <li>The exit code is 1 to indicate failure</li> </ul>"},{"location":"VCFX_variant_counter/#empty-lines","title":"Empty Lines","text":"<p>Empty lines are ignored and not counted.</p>"},{"location":"VCFX_variant_counter/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>The tool processes the VCF file line by line, with minimal memory requirements</li> <li>It performs only basic parsing and doesn't validate the content of each field</li> <li>Performance scales linearly with the number of lines in the input file</li> <li>No external dependencies or reference files are required</li> </ul>"},{"location":"VCFX_variant_counter/#limitations","title":"Limitations","text":"<ul> <li>The tool only checks the number of columns, not their content</li> <li>It doesn't validate if the VCF follows the specification for field formats</li> <li>No specific handling for compressed files (use external tools like zcat)</li> <li>No detailed reporting (e.g., breakdown by chromosome or variant type)</li> <li>Cannot handle VCF files with non-standard line endings </li> </ul>"},{"location":"citation/","title":"Citing VCFX","text":"<p>If you use VCFX in your research, publications, or projects, please cite the following paper:</p>"},{"location":"citation/#bibtex-citation","title":"BibTeX Citation","text":"<pre><code>@inproceedings{silva2025vcfx,\n  title={VCFX: A Minimalist, Modular Toolkit for Streamlined Variant Analysis},\n  author={Silva, Jorge Miguel and Oliveira, Jos{\\'e} Luis},\n  booktitle={12th International Work-Conference on Bioinformatics and Biomedical Engineering (IWBBIO 2025)},\n  year={2025},\n  organization={Springer}\n}\n</code></pre>"},{"location":"citation/#text-citation","title":"Text Citation","text":"<p>Silva JM, Oliveira JL. VCFX: A Minimalist, Modular Toolkit for Streamlined Variant Analysis. In: Proceedings of the 12th International Work-Conference on Bioinformatics and Biomedical Engineering (IWBBIO 2025); 2025; Gran Canaria, Spain. Springer.</p>"},{"location":"citation/#publication-information","title":"Publication Information","text":"<p>The VCFX toolkit was presented at the 12th International Work-Conference on Bioinformatics and Biomedical Engineering (IWBBIO 2025), held in Gran Canaria, Spain, from July 16-18, 2025.</p>"},{"location":"citation/#abstract","title":"Abstract","text":"<p>VCFX is a collection of specialized C/C++ command-line tools designed for efficient manipulation, analysis, and transformation of VCF (Variant Call Format) files used in genomic research and bioinformatics. Each tool is an independent executable that follows the Unix philosophy: do one thing well and work seamlessly with other tools through standard input/output streams. The toolkit includes 60 specialized utilities covering the entire lifecycle of variant data analysis from filtering and annotation to merging, phasing, and structural variant manipulation.</p>"},{"location":"citation/#how-to-cite-in-different-formats","title":"How to Cite in Different Formats","text":""},{"location":"citation/#apa-format","title":"APA Format","text":"<p>Silva, J. M., &amp; Oliveira, J. L. (2025). VCFX: A Minimalist, Modular Toolkit for Streamlined Variant Analysis. In Proceedings of the 12th International Work-Conference on Bioinformatics and Biomedical Engineering (IWBBIO 2025). Springer.</p>"},{"location":"citation/#mla-format","title":"MLA Format","text":"<p>Silva, Jorge Miguel, and Jos\u00e9 Luis Oliveira. \"VCFX: A Minimalist, Modular Toolkit for Streamlined Variant Analysis.\" Proceedings of the 12th International Work-Conference on Bioinformatics and Biomedical Engineering (IWBBIO 2025), Springer, 2025.</p>"},{"location":"citation/#ieee-format","title":"IEEE Format","text":"<p>J. M. Silva and J. L. Oliveira, \"VCFX: A Minimalist, Modular Toolkit for Streamlined Variant Analysis,\" in Proc. 12th Int. Work-Conf. Bioinformatics Biomedical Engineering (IWBBIO), 2025. </p>"},{"location":"docker/","title":"Docker Usage Guide for VCFX","text":"<p>This document explains how to use VCFX with Docker.</p>"},{"location":"docker/#using-the-pre-built-image-recommended","title":"Using the Pre-built Image (Recommended)","text":"<p>VCFX is available as a pre-built Docker image on GitHub Container Registry:</p> <pre><code># Pull the image (only needed once)\ndocker pull ghcr.io/jorgemfs/vcfx:latest\n\n# Run a VCFX tool\ndocker run --rm ghcr.io/jorgemfs/vcfx:latest VCFX_tool_name [options]\n\n# Mount a directory with your data\ndocker run --rm -v /path/to/your/data:/data ghcr.io/jorgemfs/vcfx:latest VCFX_tool_name [options]\n\n# Example: Process a VCF file (using tests/data/valid.vcf as an example)\ndocker run --rm -v $(pwd)/tests/data:/data ghcr.io/jorgemfs/vcfx:latest 'cat /data/valid.vcf | VCFX_allele_freq_calc &gt; /data/output.tsv'\n</code></pre> <p>Using the pre-built image is recommended for most users as it:</p> <ul> <li>Requires no build time</li> <li>Is automatically updated with each release</li> <li>Has been tested and verified to work correctly</li> </ul>"},{"location":"docker/#testing-the-docker-image","title":"Testing the Docker Image","text":"<p>A test script is provided to verify the Docker image works correctly with VCFX:</p> <pre><code># Run the Docker test script\n./tests/test_docker.sh\n</code></pre> <p>This script will:</p> <ol> <li>Pull the latest Docker image</li> <li>Test several VCFX tools using test data</li> <li>Verify the tools work correctly in the Docker environment</li> </ol>"},{"location":"docker/#building-your-own-image","title":"Building Your Own Image","text":"<p>If you need to customize the Docker image, you can build it yourself:</p> <pre><code># Clone the repository\ngit clone https://github.com/ieeta-pt/VCFX.git\ncd VCFX\n\n# Using Docker directly\ndocker build -t vcfx:local .\n\n# Using Docker Compose\ndocker-compose build\n</code></pre>"},{"location":"docker/#entrypoint-script-and-passing-commands","title":"Entrypoint Script and Passing Commands","text":"<p>The image uses <code>/usr/local/bin/docker_entrypoint.sh</code> as its entrypoint. This script adds all VCFX tools to the <code>PATH</code> and then executes whatever command you pass to <code>docker run</code>.</p> <pre><code>docker run --rm ghcr.io/jorgemfs/vcfx:latest VCFX_variant_counter &lt; input.vcf\n</code></pre> <p>You can substitute <code>VCFX_variant_counter</code> with any other tool or quote a more complex shell command.</p>"},{"location":"docker/#running-vcfx-tools","title":"Running VCFX Tools","text":"<p>There are several ways to run VCFX tools with Docker:</p>"},{"location":"docker/#using-docker-directly","title":"Using Docker Directly","text":"<pre><code># With the pre-built image\ndocker run --rm ghcr.io/jorgemfs/vcfx:latest VCFX_tool_name [options]\n\n# With a locally built image\ndocker run --rm vcfx:local VCFX_tool_name [options]\n\n# Mount the tests/data directory to access test files\ndocker run --rm -v $(pwd)/tests/data:/data ghcr.io/jorgemfs/vcfx:latest VCFX_tool_name [options]\n\n# Process files in the tests/data directory\ndocker run --rm -v $(pwd)/tests/data:/data ghcr.io/jorgemfs/vcfx:latest 'cat /data/valid.vcf | VCFX_validator'\n\n# Example: Calculate allele frequencies for a VCF file\ndocker run --rm -v $(pwd)/tests/data:/data ghcr.io/jorgemfs/vcfx:latest 'cat /data/valid.vcf | VCFX_allele_freq_calc &gt; /data/output.tsv'\n</code></pre>"},{"location":"docker/#using-docker-compose","title":"Using Docker Compose","text":"<pre><code># Basic usage (with locally built image)\ndocker-compose run --rm vcfx VCFX_tool_name [options]\n\n# Example: List all available tools\ndocker-compose run --rm vcfx 'ls -1 /usr/local/bin/VCFX_*'\n\n# Example: Process a VCF file from tests/data\ndocker-compose run --rm vcfx 'cat /data/valid.vcf | VCFX_allele_freq_calc &gt; /data/output.tsv'\n</code></pre>"},{"location":"docker/#data-management","title":"Data Management","text":"<p>When using Docker directly, you need to mount a directory to access your files:</p> <pre><code>docker run --rm -v $(pwd)/tests/data:/data ghcr.io/jorgemfs/vcfx:latest VCFX_tool_name [options]\n</code></pre> <p>When using Docker Compose, the <code>tests/data</code> directory is mounted by default:</p> <ol> <li>VCF files in the tests/data directory are accessible in the container at <code>/data</code></li> <li>Output files will be saved back to the tests/data directory</li> </ol> <p>You can modify the docker-compose.yml file to mount a different directory if needed.</p>"},{"location":"docker/#advanced-usage","title":"Advanced Usage","text":""},{"location":"docker/#creating-pipelines","title":"Creating Pipelines","text":"<p>You can create complex pipelines by chaining VCFX tools:</p> <pre><code>docker run --rm -v $(pwd)/tests/data:/data ghcr.io/jorgemfs/vcfx:latest 'cat /data/classifier_mixed.vcf | VCFX_variant_classifier --append-info | grep \"VCF_CLASS=SNP\" | VCFX_allele_freq_calc &gt; /data/snp_frequencies.tsv'\n</code></pre>"},{"location":"docker/#creating-shell-scripts","title":"Creating Shell Scripts","text":"<p>For complex workflows, consider creating a shell script:</p> <pre><code>#!/bin/bash\n# save as vcfx_workflow.sh\n\ndocker run --rm -v $(pwd)/tests/data:/data ghcr.io/jorgemfs/vcfx:latest 'cat /data/valid.vcf | \\\n  VCFX_validator | \\\n  VCFX_variant_classifier --append-info | \\\n  VCFX_allele_freq_calc &gt; /data/pipeline_output.tsv'\n</code></pre> <p>Then make it executable and run it:</p> <pre><code>chmod +x vcfx_workflow.sh\n./vcfx_workflow.sh\n</code></pre>"},{"location":"docker/#troubleshooting","title":"Troubleshooting","text":""},{"location":"docker/#permission-issues","title":"Permission Issues","text":"<p>If you encounter permission issues with files created in the container:</p> <pre><code># Run the container with your user ID\ndocker run --rm -v $(pwd)/tests/data:/data -u $(id -u):$(id -g) ghcr.io/jorgemfs/vcfx:latest VCFX_tool_name [options]\n</code></pre>"},{"location":"docker/#container-not-finding-commands","title":"Container Not Finding Commands","text":"<p>If the container can't find VCFX commands, ensure they were properly built in the image:</p> <pre><code># List available VCFX tools in the container\ndocker run --rm ghcr.io/jorgemfs/vcfx:latest 'ls -1 /usr/local/bin/VCFX_*'\n</code></pre>"},{"location":"docker/#citation","title":"Citation","text":"<p>If you use VCFX with Docker in your research, please cite:</p> <pre><code>@inproceedings{silva2025vcfx,\n  title={VCFX: A Minimalist, Modular Toolkit for Streamlined Variant Analysis},\n  author={Silva, Jorge Miguel and Oliveira, Jos{\\'e} Luis},\n  booktitle={12th International Work-Conference on Bioinformatics and Biomedical Engineering (IWBBIO 2025)},\n  year={2025},\n  organization={Springer}\n}\n</code></pre> <p>For more citation formats and information, see the Citation page. </p>"},{"location":"installation/","title":"Installation Guide","text":"<p>This guide explains how to install the VCFX toolkit on your system.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing VCFX, ensure you have the following prerequisites:</p> <ul> <li>A Unix-like operating system (Linux, macOS)</li> <li>C++ compiler (GCC 5.0+ or Clang 3.8+)</li> <li>CMake (version 3.10 or higher)</li> <li>Git (for cloning the repository)</li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#method-1-using-bioconda-recommended","title":"Method 1: Using Bioconda (Recommended)","text":"<p>VCFX is available in the Bioconda channel, providing an easy installation method:</p> <pre><code># Set up Bioconda channels if you haven't already\nconda config --add channels defaults\nconda config --add channels bioconda\nconda config --add channels conda-forge\n\n# Install VCFX\nconda install vcfx\n</code></pre> <p>This method automatically handles all dependencies and provides a ready-to-use installation of VCFX.</p>"},{"location":"installation/#method-2-using-docker","title":"Method 2: Using Docker","text":"<p>The simplest way to use VCFX is with Docker, which requires no compilation:</p> <pre><code># Pull the VCFX Docker image (only needed once)\ndocker pull ghcr.io/jorgemfs/vcfx:latest\n\n# Run a VCFX tool\ndocker run --rm ghcr.io/jorgemfs/vcfx:latest VCFX_tool_name [options]\n\n# Process files by mounting a directory with your data\ndocker run --rm -v /path/to/your/data:/data ghcr.io/jorgemfs/vcfx:latest 'cat /data/input.vcf | VCFX_tool_name &gt; /data/output.tsv'\n</code></pre> <p>This method is ideal for: - Quick testing without installing anything locally - Running VCFX in any environment with Docker - Ensuring consistent tool behavior across different systems</p> <p>For more advanced Docker usage, see the Docker Guide.</p>"},{"location":"installation/#method-3-building-from-source","title":"Method 3: Building from Source","text":"<p>This method ensures you have the latest version of VCFX.</p> <ol> <li>Clone the VCFX repository:</li> </ol> <pre><code>git clone https://github.com/ieeta-pt/VCFX.git\ncd VCFX\n</code></pre> <ol> <li>Create a build directory and build the tools:</li> </ol> <pre><code>mkdir -p build\ncd build\ncmake ..\nmake\n</code></pre> <ol> <li>(Optional) Install the tools:    <pre><code>make install\n</code></pre></li> </ol> <p>By default the tools are installed into <code>~/.local</code>, so no administrator    privileges are required. You can change the destination with    <code>cmake -DCMAKE_INSTALL_PREFIX=/your/path ..</code> if desired.</p> <p>After installation, you should be able to run VCFX tools from your terminal.</p>"},{"location":"installation/#method-4-building-individual-tools","title":"Method 4: Building Individual Tools","text":"<p>If you only need specific tools, you can build them individually:</p> <pre><code>cd VCFX/build\nmake VCFX_tool_name\n</code></pre> <p>Replace <code>VCFX_tool_name</code> with the actual tool name (e.g., <code>VCFX_allele_freq_calc</code>).</p>"},{"location":"installation/#method-5-building-your-own-docker-image","title":"Method 5: Building Your Own Docker Image","text":"<p>If you need to customize the Docker image, you can build it yourself:</p> <ol> <li>Clone the VCFX repository:</li> </ol> <pre><code>git clone https://github.com/ieeta-pt/VCFX.git\ncd VCFX\n</code></pre> <ol> <li>Build the Docker image:</li> </ol> <pre><code>docker build -t vcfx:local .\n</code></pre> <p>Or use docker-compose:</p> <pre><code>docker-compose build\n</code></pre> <ol> <li>Run a VCFX tool:</li> </ol> <pre><code># Using docker directly\ndocker run --rm -v $(pwd)/data:/data vcfx:local VCFX_tool_name [options]\n\n# Using docker-compose\ndocker-compose run --rm vcfx VCFX_tool_name [options]\n</code></pre>"},{"location":"installation/#verifying-installation","title":"Verifying Installation","text":"<p>To verify that VCFX tools are installed correctly, you can run:</p> <pre><code>VCFX_validator --help\n</code></pre> <p>You should see the help message for the VCFX_validator tool.</p>"},{"location":"installation/#adding-vcfx-to-your-path","title":"Adding VCFX to Your PATH","text":"<p>If you didn't use <code>make install</code> or want to run tools directly from the build directory, you can add them to your PATH:</p> <pre><code># Add to ~/.bashrc or ~/.zshrc\nexport PATH=\"$PATH:/path/to/VCFX/build/src\"\n</code></pre> <p>Replace <code>/path/to/VCFX</code> with the absolute path to your VCFX repository.</p>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#missing-dependencies","title":"Missing Dependencies","text":"<p>If CMake complains about missing dependencies, you may need to install additional libraries:</p> <p>Ubuntu/Debian: <pre><code>sudo apt-get install build-essential cmake git\n</code></pre></p> <p>macOS (with Homebrew): <pre><code>brew install cmake\n</code></pre></p>"},{"location":"installation/#compilation-errors","title":"Compilation Errors","text":"<p>If you encounter compilation errors, ensure you're using a compatible compiler version and have all necessary dependencies installed.</p>"},{"location":"installation/#path-issues","title":"Path Issues","text":"<p>If you get \"command not found\" errors when trying to run VCFX tools, check that:</p> <ol> <li>The tools were built successfully</li> <li>The tools are in your PATH</li> <li>The executable files have execute permissions</li> </ol>"},{"location":"installation/#getting-help","title":"Getting Help","text":"<p>If you encounter any issues during installation, please:</p> <ol> <li>Check the GitHub Issues to see if your problem has been reported</li> <li>Open a new issue if necessary, including details about your system and the exact error messages</li> </ol>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>Now that you have VCFX installed, you can:</p> <ul> <li>Follow the Quick Start Guide to learn how to use VCFX</li> <li>Explore the Tool Documentation to learn about specific tools </li> </ul>"},{"location":"python_api/","title":"Python API","text":"<p>VCFX provides optional Python bindings exposing a subset of helper functions from the C++ <code>vcfx_core</code> library. The bindings are built as a native Python extension and can be enabled through CMake.</p>"},{"location":"python_api/#installation","title":"Installation","text":"<p>Build the project with the <code>PYTHON_BINDINGS</code> option enabled:</p> <pre><code>mkdir build &amp;&amp; cd build\ncmake -DPYTHON_BINDINGS=ON ..\nmake -j\n</code></pre> <p>The compiled module will be placed in the <code>build/python</code> directory. You can also install the package via <code>pip</code> which will invoke CMake automatically. We recommend using a Python virtual environment because some systems mark the system Python as \"externally managed\", which can prevent direct installation. Create and activate a virtual environment before running <code>pip</code>:</p> <pre><code>python3 -m venv venv &amp;&amp; source venv/bin/activate\npip install --no-build-isolation ./python\n</code></pre> <p>If you are offline, ensure that the required build dependencies are already installed because <code>--no-build-isolation</code> uses your current environment.</p>"},{"location":"python_api/#available-functions","title":"Available Functions","text":"<p>The module exposes the following helpers:</p> <ul> <li><code>trim(text)</code> \u2013 remove leading and trailing whitespace.</li> <li><code>split(text, delimiter)</code> \u2013 split <code>text</code> by the given delimiter and   return a list of strings.</li> <li><code>read_file_maybe_compressed(path)</code> \u2013 read a plain or gzip/BGZF   compressed file and return its contents as a string.</li> <li><code>read_maybe_compressed(data)</code> \u2013 decompress a bytes object if it is   gzip/BGZF compressed and return the resulting bytes.</li> <li><code>get_version()</code> \u2013 return the VCFX version string.</li> </ul>"},{"location":"python_api/#example-usage","title":"Example Usage","text":"<pre><code>import vcfx\n\nprint(vcfx.trim(\"  abc  \"))\n# 'abc'\n\nprint(vcfx.split(\"A,B,C\", \",\"))\n# ['A', 'B', 'C']\n\ndata = vcfx.read_maybe_compressed(b\"hello\")\nprint(data)\n\nversion = vcfx.get_version()\nprint(\"VCFX version:\", version)\n</code></pre>"},{"location":"python_api/#tool-wrappers","title":"Tool Wrappers","text":"<p>Besides the helper functions, the package provides lightweight wrappers for all command line tools shipped with VCFX. The wrappers simply invoke the corresponding <code>VCFX_*</code> executable via <code>subprocess</code>.</p> <p>For the wrappers to work, either the <code>vcfx</code> wrapper script or the individual <code>VCFX_*</code> binaries must be available on your <code>PATH</code>. After building the project you can source <code>add_vcfx_tools_to_path.sh</code> to add the build directories to <code>PATH</code>:</p> <pre><code>source /path/to/VCFX/add_vcfx_tools_to_path.sh\n</code></pre> <p>Use <code>vcfx.available_tools()</code> to see which tools are accessible on your <code>PATH</code> and call them either via <code>vcfx.run_tool(name, *args)</code> or by using the tool name as a function:</p> <pre><code>import vcfx\n\nprint(vcfx.available_tools())\n\n# run through the generic helper\nvcfx.run_tool(\"alignment_checker\", \"--help\")\n</code></pre> <p>If <code>VCFX_alignment_checker</code> (or any other tool) is not present on <code>PATH</code>, <code>run_tool</code> automatically tries to execute <code>vcfx</code> with the tool name as the first argument when the <code>vcfx</code> wrapper is available.</p> <p>For a full script demonstrating how to set up <code>PATH</code> with <code>add_vcfx_tools_to_path.sh</code> and handle errors when running tools, see <code>examples/python_usage.py</code>.</p>"},{"location":"python_api/#convenience-wrappers","title":"Convenience Wrappers","text":"<p>Several tools have Python helpers that run the command line program and parse its output into structured data. Many wrappers return dataclasses from <code>vcfx.results</code> rather than raw dictionaries. When using these helpers numeric columns are automatically converted to <code>int</code> or <code>float</code> based on the dataclass field annotations.</p> <pre><code>import vcfx\n\n# Check alignment discrepancies and get dataclass instances\nrows = vcfx.alignment_checker(\"tests/data/align_Y.vcf\", \"tests/data/align_refY.fa\")\nprint(rows[0].Discrepancy_Type)  # 'ALT_MISMATCH'\n\n# Count alleles for all samples\ncounts = vcfx.allele_counter(\"tests/data/allele_counter_A.vcf\")\nprint(counts[0].Alt_Count)  # 1\n\n# Simply count the variants in a VCF\nn = vcfx.variant_counter(\"tests/data/variant_counter_normal.vcf\")\nprint(n)\n</code></pre> <p>Additional wrappers are available for other tools:</p> <pre><code># Allele frequency calculation\nfreqs = vcfx.allele_freq_calc(\"tests/data/allele_freq_calc/simple.vcf\")\nprint(freqs[0].Allele_Frequency)  # 0.5000\n\n# Aggregate INFO fields and read the updated VCF text\nannotated = vcfx.info_aggregator(\"tests/data/aggregator/basic.vcf\", [\"DP\"])\nprint(\"#AGGREGATION_SUMMARY\" in annotated)\n\n# Parse INFO fields into dictionaries\ninfo_rows = vcfx.info_parser(\"tests/data/info_parser/basic.vcf\", [\"DP\"])\nprint(info_rows[0][\"DP\"])  # '10'\n\n# Summarize INFO fields\nsummary = vcfx.info_summarizer(\"tests/data/info_summarizer/basic.vcf\", [\"DP\"])\nprint(summary[0].Mean)  # 20.0000\n\n# Convert VCF to FASTA alignment\nfasta = vcfx.fasta_converter(\"tests/data/fasta_converter/basic.vcf\")\nprint(fasta.splitlines()[0])  # '&gt;SAMPLE1'\n</code></pre>"},{"location":"python_api/#additional-wrappers","title":"Additional Wrappers","text":"<p><pre><code># Calculate allele balance for all samples\nbalance = vcfx.allele_balance_calc(\"tests/data/allele_balance_calc_A.vcf\")\nprint(balance[0].Allele_Balance)  # 1.000000\n\n# Check concordance between two samples\nconc = vcfx.concordance_checker(\n    \"tests/data/concordance_input.vcf\",\n    \"SAMPLE1\",\n    \"SAMPLE2\",\n)\nprint(conc[0].Concordance)  # 'Concordant'\n</code></pre> <pre><code># Query variants with heterozygous genotypes\nfiltered = vcfx.genotype_query(\n    \"tests/data/genotype_query/sample.vcf\",\n    \"0/1\",\n)\nprint(filtered.startswith(\"##\"))  # True\n\n# Remove duplicate records\ndedup = vcfx.duplicate_remover(\"tests/data/allele_balance_calc_A.vcf\")\nprint(dedup.splitlines()[0].startswith(\"#\"))  # True\n</code></pre></p> <pre><code># Subset variants by allele frequency range\nsubset = vcfx.af_subsetter(\"tests/data/af_subsetter_A.vcf\", \"0.01-0.1\")\nprint(subset.startswith(\"##\"))\n\n# Detect missing genotypes\nflagged = vcfx.missing_detector(\"tests/data/concordance_missing_data.vcf\")\nprint(\"MISSING_GENOTYPES=1\" in flagged)\n\n# Hardy-Weinberg equilibrium test\nhwe = vcfx.hwe_tester(\"tests/data/hwe_tester/basic_hwe.vcf\")\nprint(hwe[0].HWE_pvalue)\n\n# Inbreeding coefficient calculation\ncoeff = vcfx.inbreeding_calculator(\n    \"tests/data/inbreeding_calculator/single_sample_excludeSample_false.vcf\",\n    freq_mode=\"excludeSample\",\n)\nprint(coeff[0].InbreedingCoefficient)\n\n# Variant classification\nclasses = vcfx.variant_classifier(\"tests/data/classifier_mixed.vcf\")\nprint(classes[0].Classification)  # 'SNP'\n\n# Cross-sample concordance\nxconc = vcfx.cross_sample_concordance(\"tests/data/concordance_some_mismatch.vcf\")\nprint(xconc[0].Concordance_Status)  # 'CONCORDANT'\n\n# Extract specific fields\nfields = vcfx.field_extractor(\n    \"tests/data/field_extractor_input.vcf\", [\"CHROM\", \"POS\", \"ID\"]\n)\nprint(fields[0][\"ID\"])  # 'rs123'\n</code></pre> <p><pre><code># Assign ancestry to samples\nassign = vcfx.ancestry_assigner(\n    \"tests/data/ancestry_assigner/input.vcf\",\n    \"tests/data/ancestry_assigner/freq.tsv\",\n)\n# ``assign`` is a list of :class:`vcfx.results.AncestryAssignment` objects\nprint(assign[0].Assigned_Population)  # 'EUR'\n</code></pre> <pre><code># Calculate genotype dosages\ndosage = vcfx.dosage_calculator(\"tests/data/dosage_calculator/basic.vcf\")\nprint(dosage[0].Dosages)  # '0,1,2'\n</code></pre></p> <pre><code># Create a position index\nindex_rows = vcfx.indexer(\"tests/data/indexer/basic.vcf\")\nprint(index_rows[0].FILE_OFFSET)  # 255\n</code></pre>"},{"location":"python_api/#further-wrappers","title":"Further Wrappers","text":"<p>Additional helper functions mirror the rest of the <code>VCFX_*</code> tools. They work like the wrappers above. A few examples:</p> <pre><code># Infer population ancestry\ninfer = vcfx.ancestry_inferrer(\n    \"tests/data/ancestry_inferrer/eur_samples.vcf\",\n    \"tests/data/ancestry_inferrer/population_freqs.txt\",\n)\nprint(infer[0].Inferred_Population)  # 'EUR'\n\n# Extract annotation fields\nrows = vcfx.annotation_extractor(\n    \"tests/data/haplotype_extractor/basic.vcf\",\n    [\"ANN\", \"Gene\"],\n)\nprint(rows[0][\"Gene\"])\n\n# Normalize indels\nnormalized = vcfx.indel_normalizer(\"tests/data/indel_normalizer/basic.vcf\")\nprint(normalized.startswith(\"##\"))\n\n# Validate a file\nreport = vcfx.validator(\"tests/data/variant_counter_normal.vcf\")\nprint(\"VCF\" in report)\n</code></pre>"},{"location":"quickstart/","title":"Quick Start Guide","text":"<p>This guide provides a quick introduction to using the VCFX toolkit with practical examples.</p>"},{"location":"quickstart/#overview","title":"Overview","text":"<p>VCFX consists of multiple small command-line tools that are designed to be combined in pipelines. Each tool follows these principles:</p> <ul> <li>Reads from standard input and writes to standard output</li> <li>Performs a single, focused task</li> <li>Can be combined with other tools via pipes</li> <li>Has a consistent command-line interface</li> </ul>"},{"location":"quickstart/#basic-usage-pattern","title":"Basic Usage Pattern","text":"<p>Most VCFX tools follow this basic pattern:</p> <pre><code>VCFX_tool_name [options] &lt; input.vcf &gt; output.vcf\n</code></pre> <p>For example:</p> <pre><code>VCFX_variant_classifier &lt; input.vcf &gt; classified.vcf\n</code></pre>"},{"location":"quickstart/#common-examples","title":"Common Examples","text":"<p>Here are some common use cases for VCFX tools:</p>"},{"location":"quickstart/#example-1-basic-filtering","title":"Example 1: Basic Filtering","text":"<p>Filter for high-quality SNPs:</p> <pre><code>cat input.vcf | \\\n  VCFX_variant_classifier --append-info | \\\n  grep 'VCF_CLASS=SNP' | \\\n  VCFX_phred_filter --phred-filter 30 &gt; high_quality_snps.vcf\n</code></pre>"},{"location":"quickstart/#example-2-population-analysis","title":"Example 2: Population Analysis","text":"<p>Extract European samples and calculate allele frequencies:</p> <pre><code>cat input.vcf | \\\n  VCFX_population_filter --population EUR --pop-map populations.txt | \\\n  VCFX_allele_freq_calc &gt; eur_frequencies.tsv\n</code></pre>"},{"location":"quickstart/#example-3-data-transformation","title":"Example 3: Data Transformation","text":"<p>Normalize indels and split multiallelic variants:</p> <pre><code>cat input.vcf | \\\n  VCFX_indel_normalizer | \\\n  VCFX_multiallelic_splitter &gt; normalized_biallelic.vcf\n</code></pre>"},{"location":"quickstart/#example-4-quality-control","title":"Example 4: Quality Control","text":"<p>Check concordance between two samples in a single VCF file:</p> <pre><code>cat sample.vcf | VCFX_concordance_checker --samples \"SAMPLE1 SAMPLE2\" &gt; concordance_report.tsv\n</code></pre>"},{"location":"quickstart/#working-with-compressed-files","title":"Working with Compressed Files","text":"<p>Most VCFX tools don't directly support compressed input/output. Use standard Unix tools:</p> <pre><code># Reading from compressed files\nzcat input.vcf.gz | VCFX_tool_name &gt; output.vcf\n\n# Writing to compressed files\nVCFX_tool_name &lt; input.vcf | gzip &gt; output.vcf.gz\n</code></pre>"},{"location":"quickstart/#getting-help","title":"Getting Help","text":"<p>All VCFX tools provide help information:</p> <pre><code>VCFX_tool_name --help\n</code></pre> <p>This will display the tool's purpose, options, and usage examples.</p>"},{"location":"quickstart/#tool-categories","title":"Tool Categories","text":"<p>VCFX tools are categorized by their function:</p>"},{"location":"quickstart/#data-analysis","title":"Data Analysis","text":"<p>Tools for extracting information from VCF files (e.g., <code>VCFX_allele_freq_calc</code>)</p>"},{"location":"quickstart/#data-filtering","title":"Data Filtering","text":"<p>Tools for selecting variants based on criteria (e.g., <code>VCFX_phred_filter</code>)</p>"},{"location":"quickstart/#data-transformation","title":"Data Transformation","text":"<p>Tools for converting or reformatting VCF data (e.g., <code>VCFX_indel_normalizer</code>)</p>"},{"location":"quickstart/#quality-control","title":"Quality Control","text":"<p>Tools for validating and checking data quality (e.g., <code>VCFX_validator</code>)</p>"},{"location":"quickstart/#file-management","title":"File Management","text":"<p>Tools for handling VCF files (e.g., <code>VCFX_indexer</code>)</p>"},{"location":"quickstart/#common-workflows","title":"Common Workflows","text":"<p>Here are some common workflows that combine multiple VCFX tools:</p>"},{"location":"quickstart/#variant-qc-pipeline","title":"Variant QC Pipeline","text":"<pre><code>cat input.vcf | \\\n  VCFX_validator | \\\n  VCFX_variant_classifier --append-info | \\\n  VCFX_missing_detector --max-missing 0.1 | \\\n  VCFX_phred_filter --phred-filter 20 &gt; qc_passed.vcf\n</code></pre>"},{"location":"quickstart/#sample-comparison","title":"Sample Comparison","text":"<pre><code># Check concordance between two samples in a single VCF\ncat input.vcf | VCFX_concordance_checker --samples \"SAMPLE1 SAMPLE2\" &gt; concordance.tsv\n</code></pre>"},{"location":"quickstart/#population-structure-analysis","title":"Population Structure Analysis","text":"<pre><code># Extract population-specific VCFs\ncat input.vcf | VCFX_population_filter --population EUR --pop-map pop_map.txt &gt; eur.vcf\ncat input.vcf | VCFX_population_filter --population AFR --pop-map pop_map.txt &gt; afr.vcf\n\n# Calculate allele frequencies for each population\ncat eur.vcf | VCFX_allele_freq_calc &gt; eur_afs.tsv\ncat afr.vcf | VCFX_allele_freq_calc &gt; afr_afs.tsv\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<p>After becoming familiar with the basic usage of VCFX tools, you can:</p> <ol> <li>Explore the complete tool documentation for details on each tool</li> <li>Check the installation guide if you need to install additional tools</li> <li>Browse through the example VCF files in the repository to practice</li> </ol> <p>For more complex workflows and advanced examples, refer to the individual tool documentation pages. </p>"},{"location":"tool_template/","title":"VCFX_tool_name","text":""},{"location":"tool_template/#overview","title":"Overview","text":"<p>Briefly describe what the tool does and its primary purpose in 1-2 sentences.</p>"},{"location":"tool_template/#usage","title":"Usage","text":"<pre><code>VCFX_tool_name [OPTIONS] &lt; input.vcf &gt; output.format\n</code></pre>"},{"location":"tool_template/#options","title":"Options","text":"Option Description <code>-h</code>, <code>--help</code> Display help message and exit (handled by <code>vcfx::handle_common_flags</code>) <code>-v</code>, <code>--version</code> Show program version and exit <code>-o</code>, <code>--option1</code> Description of option 1 <code>-p</code>, <code>--option2 VALUE</code> Description of option 2 which requires a value"},{"location":"tool_template/#description","title":"Description","text":"<p>Provide a detailed description of what the tool does. Explain: - The purpose of the tool - How it processes the data - What transformations or calculations it performs - Any key algorithms or methodologies used</p>"},{"location":"tool_template/#output-format","title":"Output Format","text":"<p>Describe the output format in detail. Include: - The structure of the output (VCF, TSV, etc.) - Column descriptions if applicable - Any special formatting considerations</p> <pre><code>COLUMN1  COLUMN2  COLUMN3\n</code></pre>"},{"location":"tool_template/#examples","title":"Examples","text":""},{"location":"tool_template/#basic-usage","title":"Basic Usage","text":"<pre><code>./VCFX_tool_name &lt; input.vcf &gt; output.format\n</code></pre>"},{"location":"tool_template/#advanced-example","title":"Advanced Example","text":"<pre><code>./VCFX_tool_name --option1 --option2 value &lt; input.vcf &gt; output.format\n</code></pre>"},{"location":"tool_template/#integration-with-other-tools","title":"Integration with Other Tools","text":"<pre><code># Example of using this tool in a pipeline\ncat input.vcf | ./VCFX_tool1 | ./VCFX_tool_name | ./VCFX_tool3 &gt; final_output.format\n</code></pre>"},{"location":"tool_template/#handling-special-cases","title":"Handling Special Cases","text":"<ul> <li>Case 1: How the tool handles this special case</li> <li>Case 2: How the tool handles another special case</li> <li>Edge cases: Information about edge cases and how they're handled</li> </ul>"},{"location":"tool_template/#performance","title":"Performance","text":"<p>Information about: - Time complexity - Memory usage - Performance characteristics with large files - Any optimizations made</p>"},{"location":"tool_template/#limitations","title":"Limitations","text":"<ul> <li>List known limitations</li> <li>Describe any constraints or assumptions</li> <li>Note any compatibility issues </li> </ul>"},{"location":"tools_overview/","title":"VCFX Tools Overview","text":"<p>VCFX is a collection of C/C++ tools for processing and analyzing VCF (Variant Call Format) files, with optional WebAssembly compatibility. Each tool is an independent command-line executable that can parse input from <code>stdin</code> and write to <code>stdout</code>, enabling flexible piping and integration into bioinformatics pipelines.</p> <p>The suite also includes a convenience wrapper <code>vcfx</code> so you can run commands as <code>vcfx &lt;subcommand&gt;</code>. For example, <code>vcfx variant_counter</code> is equivalent to running <code>VCFX_variant_counter</code>. Use <code>vcfx --list</code> or the alias <code>vcfx list</code> to see available subcommands. To view Markdown documentation for a tool, run <code>vcfx help &lt;tool&gt;</code>. All individual <code>VCFX_*</code> binaries remain available if you prefer calling them directly. Every tool now supports the common flags <code>--help</code> and <code>--version</code> for quick usage or version information.</p>"},{"location":"tools_overview/#tool-categories","title":"Tool Categories","text":""},{"location":"tools_overview/#data-analysis","title":"Data Analysis","text":"<p>These tools help extract statistical information and insights from variant data:</p> <ul> <li>VCFX_allele_freq_calc - Calculate allele frequencies</li> <li>VCFX_variant_classifier - Classify variants into SNP, INDEL, MNV, or STRUCTURAL</li> <li>VCFX_inbreeding_calculator - Calculate inbreeding coefficients</li> <li>VCFX_dosage_calculator - Calculate allele dosage from genotypes</li> <li>VCFX_hwe_tester - Test for Hardy-Weinberg equilibrium</li> <li>VCFX_distance_calculator - Calculate genetic distances between samples</li> <li>VCFX_allele_counter - Count alleles in VCF files</li> <li>VCFX_allele_balance_calc - Calculate allele balance metrics</li> <li>VCFX_variant_counter - Count variants in VCF files</li> <li>VCFX_ancestry_inferrer - Infer ancestry from genetic data</li> <li>VCFX_ancestry_assigner - Assign ancestry to samples</li> <li>VCFX_ld_calculator - Calculate pairwise linkage disequilibrium (r\u00b2) between variants</li> </ul>"},{"location":"tools_overview/#data-filtering","title":"Data Filtering","text":"<p>Tools for selecting variants based on specific criteria:</p> <ul> <li>VCFX_phase_checker - Filter variants to keep only fully phased genotypes</li> <li>VCFX_phred_filter - Filter variants based on Phred-scaled quality scores</li> <li>VCFX_record_filter - Filter variants based on various VCF fields</li> <li>VCFX_gl_filter - Filter variants based on genotype likelihoods</li> <li>VCFX_allele_balance_filter - Filter variants based on allele balance</li> <li>VCFX_population_filter - Filter variants based on population statistics</li> <li>VCFX_probability_filter - Filter variants based on probability scores</li> <li>VCFX_nonref_filter - Filter to keep only non-reference variants</li> <li>VCFX_impact_filter - Filter variants based on predicted impact</li> <li>VCFX_phase_quality_filter - Filter variants based on phasing quality scores</li> <li>VCFX_region_subsampler - Filter variants based on genomic regions</li> </ul>"},{"location":"tools_overview/#data-transformation","title":"Data Transformation","text":"<p>Tools for converting or reformatting VCF data:</p> <ul> <li>VCFX_multiallelic_splitter - Split multiallelic variants into biallelic records</li> <li>VCFX_sample_extractor - Extract specific samples from a VCF file</li> <li>VCFX_position_subsetter - Extract variants at specific positions</li> <li>VCFX_format_converter - Convert VCF files to other formats</li> <li>VCFX_genotype_query - Query specific genotype patterns</li> <li>VCFX_indel_normalizer - Normalize indel representations</li> <li>VCFX_sv_handler - Handle structural variants in VCF files</li> <li>VCFX_fasta_converter - Convert VCF files to FASTA format</li> <li>VCFX_sorter - Sort VCF files by position</li> <li>VCFX_af_subsetter - Extract variants based on allele frequency</li> <li>VCFX_reformatter - Reformat VCF files for better readability</li> </ul>"},{"location":"tools_overview/#quality-control","title":"Quality Control","text":"<p>Tools for validating and checking data quality:</p> <ul> <li>VCFX_concordance_checker - Check concordance between samples in a VCF file</li> <li>VCFX_missing_detector - Detect and report missing data</li> <li>VCFX_outlier_detector - Detect outlier samples or variants</li> <li>VCFX_alignment_checker - Check alignment of variants</li> <li>VCFX_cross_sample_concordance - Check concordance between samples</li> <li>VCFX_validator - Validate VCF format compliance</li> </ul>"},{"location":"tools_overview/#file-management","title":"File Management","text":"<p>Tools for handling VCF files:</p> <ul> <li>VCFX_indexer - Create an index file for random access</li> <li>VCFX_file_splitter - Split VCF files into smaller chunks</li> <li>VCFX_compressor - Compress VCF files efficiently</li> <li>VCFX_diff_tool - Find differences between VCF files</li> <li>VCFX_subsampler - Subsample variants from a VCF file</li> <li>VCFX_duplicate_remover - Remove duplicate variants</li> <li>VCFX_merger - Merge multiple VCF files by position</li> </ul>"},{"location":"tools_overview/#annotation-and-reporting","title":"Annotation and Reporting","text":"<p>Tools for annotating and extracting information from VCF files:</p> <ul> <li>VCFX_custom_annotator - Add custom annotations to VCF files</li> <li>VCFX_info_summarizer - Summarize INFO fields in VCF files</li> <li>VCFX_header_parser - Parse and extract information from VCF headers</li> <li>VCFX_annotation_extractor - Extract annotations from VCF files</li> <li>VCFX_ref_comparator - Compare variants against a reference genome</li> <li>VCFX_field_extractor - Extract specific fields from VCF files</li> <li>VCFX_info_aggregator - Aggregate INFO fields across variants</li> <li>VCFX_info_parser - Parse INFO fields in VCF files</li> <li>VCFX_metadata_summarizer - Summarize key metadata from VCF files</li> </ul>"},{"location":"tools_overview/#data-processing","title":"Data Processing","text":"<p>Tools for processing variants and samples:</p> <ul> <li>VCFX_missing_data_handler - Handle missing data in VCF files</li> <li>VCFX_quality_adjuster - Adjust quality scores in VCF files</li> <li>VCFX_haplotype_phaser - Phase haplotypes in VCF files</li> <li>VCFX_haplotype_extractor - Extract haplotype information</li> </ul>"},{"location":"tools_overview/#common-usage-patterns","title":"Common Usage Patterns","text":"<p>VCFX tools are designed to be combined in pipelines. Here are some common usage patterns:</p>"},{"location":"tools_overview/#basic-filtering-and-analysis","title":"Basic Filtering and Analysis","text":"<pre><code># Extract phased variants, filter by quality, and calculate allele frequencies\ncat input.vcf | \\\n  VCFX_phase_checker | \\\n  VCFX_phred_filter --phred-filter 30 | \\\n  VCFX_allele_freq_calc &gt; result.tsv\n</code></pre>"},{"location":"tools_overview/#variant-classification-and-filtering","title":"Variant Classification and Filtering","text":"<pre><code># Classify variants and filter for SNPs with high quality\ncat input.vcf | \\\n  VCFX_variant_classifier --append-info | \\\n  grep 'VCF_CLASS=SNP' | \\\n  VCFX_phred_filter --phred-filter 30 &gt; high_quality_snps.vcf\n</code></pre>"},{"location":"tools_overview/#sample-comparison","title":"Sample Comparison","text":"<pre><code># Check concordance between two samples in a single VCF\ncat input.vcf | VCFX_concordance_checker --samples \"SAMPLE1 SAMPLE2\" &gt; concordance.tsv\n</code></pre>"},{"location":"tools_overview/#linkage-disequilibrium-analysis","title":"Linkage Disequilibrium Analysis","text":"<pre><code># Calculate LD in a specific region after filtering for common variants\ncat input.vcf | \\\n  VCFX_af_subsetter --af-filter '0.05-1.0' | \\\n  VCFX_ld_calculator --region chr1:10000-20000 &gt; ld_matrix.txt\n</code></pre>"},{"location":"tools_overview/#normalization-and-splitting","title":"Normalization and Splitting","text":"<pre><code># Normalize indels and split multiallelic variants\ncat input.vcf | \\\n  VCFX_indel_normalizer | \\\n  VCFX_multiallelic_splitter &gt; normalized_biallelic.vcf\n</code></pre>"},{"location":"tools_overview/#population-analysis","title":"Population Analysis","text":"<pre><code># Extract population-specific VCFs and calculate allele frequencies\ncat input.vcf | VCFX_population_filter --population EUR --pop-map pop_map.txt &gt; eur.vcf\ncat eur.vcf | VCFX_allele_freq_calc &gt; eur_afs.tsv\n</code></pre>"},{"location":"tools_overview/#quality-control-pipeline","title":"Quality Control Pipeline","text":"<pre><code># Validate, classify, detect missing data, and filter by quality\ncat input.vcf | \\\n  VCFX_validator | \\\n  VCFX_variant_classifier --append-info | \\\n  VCFX_missing_detector --max-missing 0.1 | \\\n  VCFX_phred_filter --phred-filter 20 &gt; qc_passed.vcf\n</code></pre>"}]}